[{"title":"数据结构-Trie树","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-Trie树/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-Trie树","slug":"数据结构-Trie树","permalink":"http://yoursite.com/tags/数据结构-Trie树/"}]},{"title":"数据结构-二叉树","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-二叉树/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-二叉树","slug":"数据结构-二叉树","permalink":"http://yoursite.com/tags/数据结构-二叉树/"}]},{"title":"数据结构-图","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-图/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-图","slug":"数据结构-图","permalink":"http://yoursite.com/tags/数据结构-图/"}]},{"title":"数据结构-堆","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-堆/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-堆","slug":"数据结构-堆","permalink":"http://yoursite.com/tags/数据结构-堆/"}]},{"title":"数据结构-散列表","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-散列表/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-散列表","slug":"数据结构-散列表","permalink":"http://yoursite.com/tags/数据结构-散列表/"}]},{"title":"数据结构-栈","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-栈/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-栈","slug":"数据结构-栈","permalink":"http://yoursite.com/tags/数据结构-栈/"}]},{"title":"数据结构-链表","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-链表/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-链表","slug":"数据结构-链表","permalink":"http://yoursite.com/tags/数据结构-链表/"}]},{"title":"数据结构-跳表","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-跳表/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-跳表","slug":"数据结构-跳表","permalink":"http://yoursite.com/tags/数据结构-跳表/"}]},{"title":"数据结构-队列","date":"2019-05-14T11:57:10.000Z","path":"2019/05/14/数据结构-队列/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-队列","slug":"数据结构-队列","permalink":"http://yoursite.com/tags/数据结构-队列/"}]},{"title":"数据结构-数组","date":"2019-05-12T11:57:10.000Z","path":"2019/05/12/数据结构-数组/","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构-数组","slug":"数据结构-数组","permalink":"http://yoursite.com/tags/数据结构-数组/"}]},{"title":"LeetCode之数组求和","date":"2019-05-03T15:34:34.000Z","path":"2019/05/03/LeetCode之数组求和/","text":"题目：给定一个整数数组nums和一个目标值target,请你在改数组中找出和为目标值的那两个整数，返回他们的数组下标； 方法一： private static int[] arraySum(int[] nums, int target){ for(int i = 0; i &lt; nums.length; i++){ for (int j = i+1; j &lt; nums.length; j++){ if (nums[i] + nums[j] == target){ return new int[]{i, j}; } } } return null; } public static void main(String[] args) { int[] arr = new int[]{2, 12, 3, 6, 0, 10}; int target = 9; int[] ints = arraySum(arr, target); if (null != ints){ for (int anInt : ints) { System.out.println(anInt); } } }方法二： public static void main(String[] args) { int[] arr = new int[]{2, 12, 3, 6, 0, 10}; int target = 9; int[] ints = arraySum(arr, target); if (null != ints){ for (int anInt : ints) { System.out.println(anInt); } } } private static int[] arraySum(int[] sums, int target){ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; sums.length; i++) { if (map.containsKey(target - sums[i])){ return new int[]{map.get(target - sums[i]), i}; } map.put(sums[i], i); } return null; }方法一比较暴力，使用的是双层循环，时间复杂度比较高；方法二比较柔和一点，没有采用双循环的方法，复杂度比较低，推荐第一种方法；","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构系列","slug":"数据结构系列","permalink":"http://yoursite.com/tags/数据结构系列/"}]},{"title":"volatile关键字","date":"2019-04-26T11:17:29.000Z","path":"2019/04/26/volatile/","text":"","categories":[{"name":"java多线程","slug":"java多线程","permalink":"http://yoursite.com/categories/java多线程/"}],"tags":[{"name":"多线程volatile","slug":"多线程volatile","permalink":"http://yoursite.com/tags/多线程volatile/"}]},{"title":"为何非要学数据结构和算法","date":"2019-04-22T11:36:34.000Z","path":"2019/04/22/为何非要学数据结构和算法/","text":"计算机专业里数据结构这门课在大学是必修课，很多程序员在毕业之后都忘得差不多了。总觉得数据结构与算法、操作系统、计算机网络是脱离实际工作的知识。在实际工作中即使你不懂数据结构和算法，照样也可以把代码敲得飞起。那么既然不懂这些也可以，为什么还要学数据结构和算法呢，大概是不想做一个CRUD boy吧! 只要对编程还有追求，就应该学一下数据结构，这样你就不在是只会写能用的代码了，而是高性能的代码。掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。在我看来数据结构和算法应该算得上是程序员的核心竞争力了，而且学习数据结构和算法可以改变你的思维方式。我大学老师曾经和我们说过程序员有两个是必须要会的，一是数据结构与算法，二是英语。你会其中一个，只能说你走的比较快而已，只有两个都会，你才能飞起来。当初不以为然，工作时间越长，发现老师说的非常对。接下来的一段时间我会持续更新数据结构与算法。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构系列","slug":"数据结构系列","permalink":"http://yoursite.com/tags/数据结构系列/"}]},{"title":"Synchronized关键字总结","date":"2019-04-15T12:04:48.000Z","path":"2019/04/15/Synchronized关键字总结/","text":"当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法，但是其他线程还是可以访问该实例对象的其他非 synchronized 方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1 (当前对象锁是 obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2 (当前对象锁是 obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了。 1.synchronized用在类中的非静态方法中，synchronized锁住的是对象this，只有调用同一个对象的方法才需要获取锁，并且同一个对象中所有加了synchronized关键字的非静态方法只能一次调用一个。 2.两个线程用同一个对象分别访问该对象的两个同步方法，会产生互斥。因为synchronized锁针对的是对象，当对象调用一个 synchronized 方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。 3.不同对象在两个线程中调用同一个同步方法，不会产生互斥。因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是 new 一个对象，那么就会出现两个空间，两把钥匙； 1.synchronized用在类中的静态方法中，synchronized锁住的是（类.class），改类中所有加了synchronized的静态方法，一次只能被调用一个。 2.用类直接在两个线程中调用两个不同的同步方法，会产生互斥。因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有 N 个房间，一把锁，因此房间（同步方法）之间一定是互斥的。注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。 3.用一个类的静态对象在两个线程中调用静态方法或非静态方法，会产生互斥。解释：因为是一个对象调用，同上。 4.一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法，不会产生互斥。","categories":[{"name":"java多线程","slug":"java多线程","permalink":"http://yoursite.com/categories/java多线程/"}],"tags":[{"name":"多线程Synchronized","slug":"多线程Synchronized","permalink":"http://yoursite.com/tags/多线程Synchronized/"}]},{"title":"java集合","date":"2019-04-15T10:38:34.000Z","path":"2019/04/15/java集合/","text":"Java 集合大致可以分为 Set、List、Queue 和 Map 四种体系，其中 Set 代表无序、不可重复的集合；List 代表有序、重复的集合；而 Map 则代表具有映射关系的集合；Java 5 又增加了 Queue 体系集合，代表一种队列集合实现。Java 集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进” 该容器中。从 Java 5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。Java 集合和数组的区别： 数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 Java 集合类之间的继承关系:Java 的集合类主要由两个接口派生而出：Collection 和 Map,Collection 和 Map 是 Java 集合框架的根接口。 Collection-Set --SortedSet ---TreeSet --HashSet ---LinkedHashSet --EnumSet -Queue --PriorityQueue --Deque ---ArraryDeque ---LinkedList -List --ArrayList ---AttributeList --Vector ---Stack ---LinkedList 图中，ArrayList,HashSet,LinkedList,TreeSet 是我们经常会有用到的已实现的集合类。list是有序(插入顺序和输出顺序)有重，set无序无重；1.list–&gt;ArrayList,linkedList,Vector介绍：元素都是通过索引的方式访问的，元素都是object子对象；底层实现linkedList是链表，其他两个都是数组；使用场景ArrayList：查询频率高，线程不安全LinkedList：增加删除频率高，线程不安全vector：线程安全 2.set–&gt;HashSet,TreeSet,LinkedHashSetHashSet是无序的，TreeSet有序遍历成员，LinkedHashSet按照插入顺序遍历，都不允许重复元素；底层实现HashSet是hash表TreeSet是二叉树(红黑树)LinkedHashSet是链表、散列表使用场景HashSet查询最快TreeSet升序排序LinkedHashSet按照插入顺序排序 Map -SortedMap --TreeMap -HashMap --LinkedHashMap -HashTable --Properties Map 实现类用于保存具有映射关系的数据。Map 保存的每项数据都是 key-value 对，也就是由 key 和 value 两个值组成。Map 里的 key 是不可重复的，key 用户标识集合里的每项数据.1.Map–&gt;HashMap、TreeMapHashMap底层是hash表，无序，频繁的插入、删除、查询元素TreeMap底层是二叉树(红黑树)，有序，按照键升序遍历输出 阻塞队列阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 JDK7提供的阻塞队列：ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。DelayQueue：一个使用优先级队列实现的无界阻塞队列。SynchronousQueue：一个不存储元素的阻塞队列。LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);访问者的公平性是使用可重入锁实现的，代码如下： public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); }LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 详情请看阻塞队列","categories":[{"name":"java基础知识","slug":"java基础知识","permalink":"http://yoursite.com/categories/java基础知识/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"java多线程概念","date":"2019-04-14T03:39:16.000Z","path":"2019/04/14/java多线程概念/","text":"线程和进程的概念：线程：进程中负责程序执行的执行单元，线程本身依靠程序进行运行；线程是程序中顺序控制流，只能使用分配给程序的资源和环境；进程：执行中的程序，一个进程至少包含一个线程；单线程：程序中只存在一个线程，实际上主方法就是一个主线程；多线程：在一个程序中运行多个任务，目的是更好的使用CPU资源； 并发与并行的概念：并行：多个CPU实例或者多台机器同时执行一段处理逻辑，是真正的同时；并发：通过CPU的调度算法，让用户看上去同时执行，实际上从CPU操作层面不是真正的同时，并发往往在场景中有公共的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反映系统的处理能力；线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu 是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。同步：Java中同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的正确。例如在代码中简单的加入synchronize关键字，在保证结果正确的同时，提高了性能，线程安全优先级高于性能。 即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停的切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下个任务，但是在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务的保存到再加载的过程就是一次上下文切换。 Java程序是操作系统的一个进程，而线程是进程中创建的贡献进程的资源。多线程主要是利用多处理器实现并发功能的。并发原理：多个线程“同时”运行只是我们感官上的一种表现。事实上线程是并发运行的（时间片轮转进程调度算法），单个CPU的情况下任何一个时间内有且仅有一个进程占有CPU，如果有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，各个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。OS将时间划分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行，而其他线程全部等，只要每个时间片段足够小，用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。所有并发技术不是绝对意义上的“同时发生”。 单核CPU(单处理器)上，只可能存在并发而不可能存在并行。并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作，每个小时间片执行一个操作，多个操作快速切换执行. 注意：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。 Java中线程也是用一个对象(java.lang.Thread)来表示的。每个进程至少有一个线程，作为程序的入口，通常情况下这个线程我们称之为主线程。在Java中，程序的入口是main方法，因此main方法实际上就是运行在主线程中的。","categories":[{"name":"java多线程","slug":"java多线程","permalink":"http://yoursite.com/categories/java多线程/"}],"tags":[{"name":"java多线程实现","slug":"java多线程实现","permalink":"http://yoursite.com/tags/java多线程实现/"}]},{"title":"hdfs原理","date":"2019-04-13T11:36:47.000Z","path":"2019/04/13/hdfs原理/","text":"","categories":[{"name":"大数据技术","slug":"大数据技术","permalink":"http://yoursite.com/categories/大数据技术/"}],"tags":[{"name":"hadoop原理","slug":"hadoop原理","permalink":"http://yoursite.com/tags/hadoop原理/"}]},{"title":"冒泡排序","date":"2019-04-13T11:32:13.000Z","path":"2019/04/13/冒泡排序/","text":"","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"垃圾回收机制","date":"2019-04-13T11:10:22.000Z","path":"2019/04/13/垃圾回收机制/","text":"","categories":[],"tags":[]},{"title":"java类加载机制","date":"2019-04-13T11:09:58.000Z","path":"2019/04/13/java类加载机制/","text":"","categories":[{"name":"java虚拟机","slug":"java虚拟机","permalink":"http://yoursite.com/categories/java虚拟机/"}],"tags":[{"name":"java类加载机制原理","slug":"java类加载机制原理","permalink":"http://yoursite.com/tags/java类加载机制原理/"}]},{"title":"java内存管理","date":"2019-04-13T11:09:40.000Z","path":"2019/04/13/java内存管理/","text":"","categories":[{"name":"java虚拟机","slug":"java虚拟机","permalink":"http://yoursite.com/categories/java虚拟机/"}],"tags":[{"name":"java内存机制原理","slug":"java内存机制原理","permalink":"http://yoursite.com/tags/java内存机制原理/"}]}]