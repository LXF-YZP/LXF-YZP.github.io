<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-10T03:24:05.501Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我没以前帅了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>绕过https验证</title>
    <link href="http://yoursite.com/2020/12/10/%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2020/12/10/绕过https验证/</id>
    <published>2020-12-10T11:57:10.000Z</published>
    <updated>2020-12-10T03:24:05.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在postman中请求方式如下："><a href="#在postman中请求方式如下：" class="headerlink" title="在postman中请求方式如下："></a>在postman中请求方式如下：</h3><p><img src="%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/ccc.png" alt></p><a id="more"></a><p>后台代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">private static final TrustManager[] trustAllCerts = new TrustManager[]&#123;</span><br><span class="line">new X509TrustManager() &#123;</span><br><span class="line">@Override</span><br><span class="line">public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">return new X509Certificate[]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void checkServerTrusted(X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置不验证主机</span><br><span class="line"> */</span><br><span class="line">private static final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 信任所有</span><br><span class="line"> * @param connection</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static SSLSocketFactory trustAllHosts(HttpsURLConnection connection) &#123;</span><br><span class="line">SSLSocketFactory oldFactory = connection.getSSLSocketFactory();</span><br><span class="line">try &#123;</span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sc.init(null, trustAllCerts, new java.security.SecureRandom());</span><br><span class="line">SSLSocketFactory newFactory = sc.getSocketFactory();</span><br><span class="line">connection.setSSLSocketFactory(newFactory);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return oldFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static String doPost(String url, Map&lt;String, Object&gt; params,Map&lt;String, String&gt; headers) &#123;</span><br><span class="line">URL u = null;</span><br><span class="line">HttpURLConnection con = null;</span><br><span class="line">HttpsURLConnection cons;</span><br><span class="line">//构建请求参数</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">if(params!=null)&#123;</span><br><span class="line">for (Entry&lt;String, Object&gt; e : params.entrySet()) &#123;</span><br><span class="line">sb.append(e.getKey());</span><br><span class="line">sb.append(&quot;=&quot;);</span><br><span class="line">sb.append(e.getValue());</span><br><span class="line">sb.append(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">sb.substring(0, sb.length() - 2);</span><br><span class="line">&#125;</span><br><span class="line">//尝试发送请求</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">u = new URL(url);</span><br><span class="line">if ((&quot;https&quot;).equals(u.getProtocol().toLowerCase())) &#123;</span><br><span class="line">cons = (HttpsURLConnection) u.openConnection();</span><br><span class="line">trustAllHosts(cons);</span><br><span class="line">cons.setHostnameVerifier(DO_NOT_VERIFY);</span><br><span class="line">con = cons;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">con = (HttpURLConnection) u.openConnection();</span><br><span class="line">&#125;</span><br><span class="line">con.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">con.setDoOutput(true);</span><br><span class="line">con.setDoInput(true);</span><br><span class="line">con.setUseCaches(false);</span><br><span class="line">con.setConnectTimeout(CON_TIME_OUT); </span><br><span class="line">con.setReadTimeout(READ_TIME_OUT);</span><br><span class="line">if(headers != null)&#123;</span><br><span class="line">for (Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">con.setRequestProperty(entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">con.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(con.getOutputStream(), &quot;UTF-8&quot;);</span><br><span class="line">if(params != null) &#123;</span><br><span class="line">String cont = sb.substring(0, sb.length() - 1).toString();</span><br><span class="line">osw.write(cont);</span><br><span class="line">&#125;</span><br><span class="line">osw.flush();</span><br><span class="line">osw.close();</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">logger.error(&quot;API对接异常！&quot;+url+&quot;参数——》&quot;+sb);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (con != null) &#123;</span><br><span class="line">       con.disconnect();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">//读取返回内容</span><br><span class="line">StringBuffer buffer = new StringBuffer();</span><br><span class="line">try &#123;</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), &quot;UTF-8&quot;));</span><br><span class="line">String temp;</span><br><span class="line">while ((temp = br.readLine()) != null)&#123;</span><br><span class="line">buffer.append(temp);</span><br><span class="line">buffer.append(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">logger.error(&quot;API数据读取异常！&quot;+url+&quot;参数——》&quot;+sb);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return buffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在postman中请求方式如下：-1"><a href="#在postman中请求方式如下：-1" class="headerlink" title="在postman中请求方式如下："></a>在postman中请求方式如下：</h3><p><img src="%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/bbb.png" alt><br><img src="%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/aaa.png" alt></p><p>后台代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public static String sendPost(String url, JSONObject jsonObject, String token) &#123;</span><br><span class="line"></span><br><span class="line">String body = &quot;&quot;;</span><br><span class="line">//创建自定义的httpclient对象</span><br><span class="line">CloseableHttpClient client = createSSLClientDefault();</span><br><span class="line">//CloseableHttpClient client = HttpClients.createDefault();</span><br><span class="line">//执行请求操作，并拿到结果（同步阻塞）</span><br><span class="line">CloseableHttpResponse response = null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建post方式请求对象</span><br><span class="line">HttpPost httpPost = new HttpPost(url);</span><br><span class="line">//装填参数</span><br><span class="line">StringEntity s = new StringEntity(jsonObject.toString(), &quot;utf-8&quot;);</span><br><span class="line">s.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE,</span><br><span class="line">&quot;application/json&quot;));</span><br><span class="line">//设置参数到请求对象中</span><br><span class="line">httpPost.setEntity(s);</span><br><span class="line"></span><br><span class="line">//设置header信息</span><br><span class="line">//指定报文头【Content-type】、【User-Agent】</span><br><span class="line">httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;);</span><br><span class="line">httpPost.setHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + token);</span><br><span class="line">httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);</span><br><span class="line">response = client.execute(httpPost);</span><br><span class="line">//获取结果实体</span><br><span class="line">HttpEntity entity = response.getEntity();</span><br><span class="line">if (entity != null) &#123;</span><br><span class="line">//按指定编码转换结果实体为String类型</span><br><span class="line">body = EntityUtils.toString(entity, &quot;UTF-8&quot;);</span><br><span class="line">&#125;</span><br><span class="line">EntityUtils.consume(entity);</span><br><span class="line">//释放链接</span><br><span class="line">response.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">try &#123;</span><br><span class="line">client.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return body;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static CloseableHttpClient createSSLClientDefault() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() &#123;</span><br><span class="line">// 信任所有</span><br><span class="line">@Override</span><br><span class="line">public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build();</span><br><span class="line">SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext, new HostnameVerifier() &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean verify(String s, SSLSession sslSession) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return HttpClients.custom().setSSLSocketFactory(sslsf).build();</span><br><span class="line">&#125; catch (KeyManagementException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (KeyStoreException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return HttpClients.createDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/aaa.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在postman中请求方式如下：&quot;&gt;&lt;a href=&quot;#在postman中请求方式如下：&quot; class=&quot;headerlink&quot; title=&quot;在postman中请求方式如下：&quot;&gt;&lt;/a&gt;在postman中请求方式如下：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;%E7%BB%95%E8%BF%87https%E9%AA%8C%E8%AF%81/ccc.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="https" scheme="http://yoursite.com/categories/https/"/>
    
    
      <category term="https、绕过验证" scheme="http://yoursite.com/tags/https%E3%80%81%E7%BB%95%E8%BF%87%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>gitignore文件</title>
    <link href="http://yoursite.com/2020/12/03/gitignore%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/12/03/gitignore文件/</id>
    <published>2020-12-03T11:57:10.000Z</published>
    <updated>2020-12-08T08:01:03.899Z</updated>
    
    <content type="html"><![CDATA[<p>在git项目中想忽略一些文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a   # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a# 但 lib.a 除外</span><br><span class="line">/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/# 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><p>有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在git项目中想忽略一些文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
      <category term="git命令" scheme="http://yoursite.com/categories/git%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="git用法" scheme="http://yoursite.com/tags/git%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>go语言命名返回值</title>
    <link href="http://yoursite.com/2020/08/20/go%E8%AF%AD%E8%A8%80%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>http://yoursite.com/2020/08/20/go语言命名返回值/</id>
    <published>2020-08-20T11:57:10.000Z</published>
    <updated>2020-12-08T07:53:55.116Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go语言闭包</title>
    <link href="http://yoursite.com/2020/08/19/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2020/08/19/go语言闭包/</id>
    <published>2020-08-19T11:57:10.000Z</published>
    <updated>2020-09-22T02:15:16.730Z</updated>
    
    <content type="html"><![CDATA[<p>删除当前行 command + shift + k</p><p>向上/向下复制当前行 shift + alt + ⏬/⏫</p><p>补全代码 alt + /</p><p>快速修复 alt + /</p><p>快速格式化代码 shift + alt + f</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;删除当前行 command + shift + k&lt;/p&gt;
&lt;p&gt;向上/向下复制当前行 shift + alt + ⏬/⏫&lt;/p&gt;
&lt;p&gt;补全代码 alt + /&lt;/p&gt;
&lt;p&gt;快速修复 alt + /&lt;/p&gt;
&lt;p&gt;快速格式化代码 shift + alt + f&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go语言值传递和引用传递</title>
    <link href="http://yoursite.com/2020/08/18/go%E8%AF%AD%E8%A8%80%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/08/18/go语言值传递和引用传递/</id>
    <published>2020-08-18T11:57:10.000Z</published>
    <updated>2020-08-19T02:25:44.280Z</updated>
    
    <content type="html"><![CDATA[<p>其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。</p><a id="more"></a><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>1) 值类型:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；变量直接存储的值；内存通常在栈中分配；</p><p>2) 引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型 ；变量存储的是一个地址，这个地址存储最终的值；内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，通过GC回收；</p><h3 id="值传递和引用传递使用特点"><a href="#值传递和引用传递使用特点" class="headerlink" title="值传递和引用传递使用特点"></a>值传递和引用传递使用特点</h3><p>定义了一个数组a，它是值类型，复制给b是copy，当b发生变化后a并不会发生任何变化；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go语言defer详解</title>
    <link href="http://yoursite.com/2020/08/17/go%E8%AF%AD%E8%A8%80defer%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/17/go语言defer详解/</id>
    <published>2020-08-17T11:57:10.000Z</published>
    <updated>2020-08-18T01:09:50.970Z</updated>
    
    <content type="html"><![CDATA[<p>在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p><a id="more"></a><p>为了更好的学习defer的行为，我们首先来看下面一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">written, err = io.Copy(dst, src)</span><br><span class="line">dst.Close()</span><br><span class="line">src.Close()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以运行，但存在’安全隐患’。如果调用dst, err := os.Create(dstName)失败，则函数会执行return退出运行。但之前创建的src(文件句柄)没有被释放。 上面这段代码很简单，所以我们可以一眼看出存在文件未被释放的问题。 如果我们的逻辑复杂或者代码调用过多时，这样的错误未必会被及时发现。 而使用defer则可以避免这种情况的发生，下面是使用defer的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer src.Close()</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dst.Close()</span><br><span class="line"></span><br><span class="line">return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过defer，我们可以在代码中优雅的关闭/清理代码中所使用的变量。defer作为golang清理变量的特性，有其独有且明确的行为。以下是defer三条使用规则。</p><h2 id="规则一-当defer被声明时，其参数就会被实时解析"><a href="#规则一-当defer被声明时，其参数就会被实时解析" class="headerlink" title="规则一 当defer被声明时，其参数就会被实时解析"></a>规则一 当defer被声明时，其参数就会被实时解析</h2><p>我们通过以下代码来解释这条规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们说过，defer函数会在return之后被调用。那么这段函数执行完之后，是不用应该输出1呢？</p><p>读者自行编译看一下，结果输出的是0. why？</p><p>这是因为虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量(i)在defer被声明的时候，就已经确定其确定的值了。 换言之，上面的代码等同于下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(0) //因为i=0，所以此时就明确告诉golang在程序退出时，执行输出0的操作</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更为明确的说明这个问题，我们继续定义一个defer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i) //输出0，因为i此时就是0</span><br><span class="line">i++</span><br><span class="line">defer fmt.Println(i) //输出1，因为i此时就是1</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行结果，可以看到defer输出的值，就是定义时的值。<strong>而不是defer真正执行时的变量值(很重要，搞不清楚的话就会产生于预期不一致的结果)</strong></p><p>但为什么是先输出1，在输出0呢？ 看下面的规则二。</p><h2 id="规则二-defer执行顺序为先进后出"><a href="#规则二-defer执行顺序为先进后出" class="headerlink" title="规则二 defer执行顺序为先进后出"></a>规则二 defer执行顺序为先进后出</h2><p>当同时定义了多个defer代码块时，golang安装<strong>先定义后执行</strong>的顺序依次调用defer。不要为什么，golang就是这么定义的。我们用下面的代码加深记忆和理解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func b() &#123;</span><br><span class="line">for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">defer fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环中，依次定义了四个defer代码块。结合规则一，我们可以明确得知每个defer代码块应该输出什么值。 安装先进后出的原则，我们可以看到依次输出了3210.</p><h2 id="规则三-defer可以读取有名返回值"><a href="#规则三-defer可以读取有名返回值" class="headerlink" title="规则三 defer可以读取有名返回值"></a>规则三 defer可以读取有名返回值</h2><p>先看下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func c() (i int) &#123;</span><br><span class="line">defer func() &#123; i++ &#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是2. 在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢….)。</p><p>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p><p>掌握了defer以上三条使用规则，那么当我们遇到defer代码块时，就可以明确得知defer的预期结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go基础知识</title>
    <link href="http://yoursite.com/2020/08/16/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/08/16/go基础知识/</id>
    <published>2020-08-16T11:57:10.000Z</published>
    <updated>2020-09-22T02:28:07.017Z</updated>
    
    <content type="html"><![CDATA[<ul><li>go语言中“++”、“–”从运算符降级为语句；</li><li>Golang 的++ 和 – 只能写在变量的后面，不能写在变量的前面，即:只有 a++ a– 没有 ++a –a</li><li>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；</li><li>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的；</li><li>字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的；</li><li>Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换；</li><li>被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化；</li><li>值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推；</li><li>值类型包括:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；</li><li>引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型；</li><li>值类型:变量直接存储值，内存通常在栈中分配；</li><li>引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆 上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收;</li><li>case/switch 后是一个表达式( 即:常量值、变量、一个有返回值的函数等都可以);</li><li>break 语句用于终止某个语句块的执行，用于中断当前 for 循环（不再执行余下的循环）或跳出 switch 语句；</li></ul><a id="more"></a><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;go语言中“++”、“–”从运算符降级为语句；&lt;/li&gt;
&lt;li&gt;Golang 的++ 和 – 只能写在变量的后面，不能写在变量的前面，即:只有 a++ a– 没有 ++a –a&lt;/li&gt;
&lt;li&gt;Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；&lt;/li&gt;
&lt;li&gt;字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的；&lt;/li&gt;
&lt;li&gt;字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的；&lt;/li&gt;
&lt;li&gt;Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换；&lt;/li&gt;
&lt;li&gt;被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化；&lt;/li&gt;
&lt;li&gt;值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推；&lt;/li&gt;
&lt;li&gt;值类型包括:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；&lt;/li&gt;
&lt;li&gt;引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型；&lt;/li&gt;
&lt;li&gt;值类型:变量直接存储值，内存通常在栈中分配；&lt;/li&gt;
&lt;li&gt;引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆 上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收;&lt;/li&gt;
&lt;li&gt;case/switch 后是一个表达式( 即:常量值、变量、一个有返回值的函数等都可以);&lt;/li&gt;
&lt;li&gt;break 语句用于终止某个语句块的执行，用于中断当前 for 循环（不再执行余下的循环）或跳出 switch 语句；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go指针用法</title>
    <link href="http://yoursite.com/2020/08/15/go%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/15/go指针用法/</id>
    <published>2020-08-15T11:57:10.000Z</published>
    <updated>2020-09-22T02:38:36.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识指针地址和指针类型"><a href="#认识指针地址和指针类型" class="headerlink" title="认识指针地址和指针类型"></a>认识指针地址和指针类型</h2><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。</p><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加<code>&amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v   // v 的类型为 T</span><br></pre></td></tr></table></figure><p>其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为<code>*T</code>，称做 T 的指针类型，<code>*</code>代表指针。</p><a id="more"></a><p>指针实际用法，可以通过下面的例子了解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (    </span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;    </span><br><span class="line">var cat int = 1    </span><br><span class="line">var str string = &quot;banana&quot;    </span><br><span class="line">fmt.Printf(&quot;%p %p&quot;, &amp;cat, &amp;str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 8 行，声明整型变量 cat。</li><li>第 9 行，声明字符串变量 str。</li><li>第 10 行，使用 fmt.Printf 的动词<code>%p</code>打印 cat 和 str 变量的内存地址，指针的值是带有<code>0x</code>十六进制前缀的一组数据。</li></ul><p>提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</p><h2 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h2><p>当使用<code>&amp;</code>操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用<code>*</code>操作符，也就是指针取值，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (    </span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;    </span><br><span class="line">// 准备一个字符串类型    </span><br><span class="line">var house = &quot;Malibu Point 10880, 90265&quot;    </span><br><span class="line">// 对字符串取地址, ptr类型为*string    </span><br><span class="line">ptr := &amp;house    </span><br><span class="line">// 打印ptr的类型    </span><br><span class="line">fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)    </span><br><span class="line">// 打印ptr的指针地址    </span><br><span class="line">fmt.Printf(&quot;address: %p\n&quot;, ptr)    </span><br><span class="line">// 对指针进行取值操作    value := *ptr    </span><br><span class="line">// 取值后的类型    </span><br><span class="line">fmt.Printf(&quot;value type: %T\n&quot;, value)    </span><br><span class="line">// 指针取值后就是指向变量的值    </span><br><span class="line">fmt.Printf(&quot;value: %s\n&quot;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 10 行，准备一个字符串并赋值。</li><li>第 13 行，对字符串取地址，将指针保存到变量 ptr 中。</li><li>第 16 行，打印变量 ptr 的类型，其类型为 *string。</li><li>第 19 行，打印 ptr 的指针地址，地址每次运行都会发生变化。</li><li>第 22 行，对 ptr 指针变量进行取值操作，变量 value 的类型为 string。</li><li>第 25 行，打印取值后 value 的类型。</li><li>第 28 行，打印 value 的值。</li></ul><p>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址操作使用<code>&amp;</code>操作符，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值操作使用<code>*</code>操作符，可以获得指针变量指向的原变量的值。</li></ul><h2 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h2><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">// 交换函数</span><br><span class="line">func swap(a, b *int) &#123;    </span><br><span class="line">// 取a指针的值, 赋给临时变量t    </span><br><span class="line">t := *a    </span><br><span class="line">// 取b指针的值, 赋给a指针指向的变量    </span><br><span class="line">*a = *b    </span><br><span class="line">// 将a指针的值赋给b指针指向的变量    </span><br><span class="line">*b = t</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">// 准备两个变量, 赋值1和2    </span><br><span class="line">x, y := 1, 2    </span><br><span class="line">// 交换变量值    </span><br><span class="line">swap(&amp;x, &amp;y)    </span><br><span class="line">// 输出变量值    </span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。</li><li>第 9 行，取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。</li><li>第 12 行，取 b 的指针值，赋给指针 a 指向的变量。注意，此时<code>*a</code>的意思不是取 a 指针的值，而是“a 指向的变量”。</li><li>第 15 行，将 t 的值赋给指针 b 指向的变量。</li><li>第 21 行，准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。</li><li>第 24 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。</li><li>第 27 行，交换完毕时，输出 x 和 y 的值。</li></ul><p><code>*</code>操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，<code>*</code>操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p><p>如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func swap(a, b *int) &#123;    </span><br><span class="line">b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;    </span><br><span class="line">x, y := 1, 2    </span><br><span class="line">swap(&amp;x, &amp;y)    </span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><p>结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识指针地址和指针类型&quot;&gt;&lt;a href=&quot;#认识指针地址和指针类型&quot; class=&quot;headerlink&quot; title=&quot;认识指针地址和指针类型&quot;&gt;&lt;/a&gt;认识指针地址和指针类型&lt;/h2&gt;&lt;p&gt;一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。&lt;/p&gt;
&lt;p&gt;每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加&lt;code&gt;&amp;amp;&lt;/code&gt;操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ptr := &amp;amp;v   // v 的类型为 T&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为&lt;code&gt;*T&lt;/code&gt;，称做 T 的指针类型，&lt;code&gt;*&lt;/code&gt;代表指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go中new和make区别</title>
    <link href="http://yoursite.com/2020/08/14/go%E4%B8%ADnew%E5%92%8Cmake%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/08/14/go中new和make区别/</id>
    <published>2020-08-14T11:57:10.000Z</published>
    <updated>2020-08-26T03:14:03.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/14/go中new和make区别/aaa.png" alt></p><p>Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二者都是用来分配空间.</p><p>Go 语言中 new 和 make 是内建的两个函数，主要用来创建分配类型内存. 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用.</p><a id="more"></a><h2 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h2><p>new (T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T, 该指针指向 T 的新分配的零值.</p><p>new 要点</p><ul><li>内置函数 new 分配空间.</li><li>传递给 new 函数的是一个类型，不是一个值.</li><li>返回值是 指向这个新分配的零值的指针.</li></ul><h2 id="2-make"><a href="#2-make" class="headerlink" title="2. make"></a>2. make</h2><p>make (T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T, 是经过初始化之后的 T 的引用. make 也是内建函数，你可以从 <a href="http://golang.org/pkg/builtin/#make" target="_blank" rel="noopener">http://golang.org/pkg/builtin/#make</a> 看到它， 它的函数原型 比 new 多了一个（长度）参数，返回值也不同.</p><p><strong><em>make 只能用于 slice,map,channel 三种类型\</em></strong> , 并且只能是这三种对象。和 new 一样，第一个参数是 类型，不是一个值. 但是 make 的返回值就是这个类型（即使一个引用类型）, 而不是指针。具体的返回值，依赖具体传入的类型.</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>new (T) 返回 T 的指针 *T 并指向 T 的零值.</li><li>make (T) 返回的初始化的 T, 只能用于 slice,map,channel, 要获得一个显式的指针，使用 new 进行分配，或者显式地使用一个变量的地址.</li><li>new 函数分配内存，make 函数初始化；</li></ul><p>下图给出了区别：</p><p><img src="/2020/08/14/go中new和make区别/bbb.png" alt></p><p>new 和 make 区别代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := new([]int) //p == nil; with len and cap 0</span><br><span class="line">    fmt.Println(p)</span><br><span class="line"></span><br><span class="line">    v := make([]int, 10, 50) // v is initialed with len 10, cap 50</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"></span><br><span class="line">    /*********Output****************</span><br><span class="line">        &amp;[]</span><br><span class="line">        [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">    *********************************/</span><br><span class="line"></span><br><span class="line">    (*p)[0] = 18        // panic: runtime error: index out of range</span><br><span class="line">                        // because p is a nil pointer, with len and cap 0</span><br><span class="line">    v[1] = 18           // ok</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/08/14/go中new和make区别/aaa.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二者都是用来分配空间.&lt;/p&gt;
&lt;p&gt;Go 语言中 new 和 make 是内建的两个函数，主要用来创建分配类型内存. 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用.&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>kill掉多个进程</title>
    <link href="http://yoursite.com/2020/08/11/kill%E6%8E%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/kill掉多个进程/</id>
    <published>2020-08-11T11:57:10.000Z</published>
    <updated>2020-08-11T07:06:29.091Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep beh-oss-minio-test-1.0-SNAPSHOT.jar | grep -v grep| awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux、进程" scheme="http://yoursite.com/tags/Linux%E3%80%81%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux下定时任务命令</title>
    <link href="http://yoursite.com/2020/08/10/linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/08/10/linux下定时任务命令/</id>
    <published>2020-08-10T11:57:10.000Z</published>
    <updated>2020-08-11T08:34:32.055Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、定时任务" scheme="http://yoursite.com/categories/Linux%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>grep命令使用</title>
    <link href="http://yoursite.com/2020/08/09/grep%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/09/grep命令使用/</id>
    <published>2020-08-09T11:57:10.000Z</published>
    <updated>2020-08-11T09:00:54.784Z</updated>
    
    <content type="html"><![CDATA[<p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、以递归的方式查找符合条件的文件。例如，查找指定目录 /etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串 “update” 的文件，并打印出该字符串所在行的内容，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update /etc/acpi</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update</span><br></pre></td></tr></table></figure><p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过 “-v” 参数可以打印出不符合条件行的内容。</p><p>查找文件名中包含 test 的文件中不包含 test 的行，此时，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure><p><strong>查找指定进程个数</strong></p><p><strong>命令：</strong></p><p>ps -ef|grep svn -c</p><p>ps -ef|grep -c svn</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef|grep svn -c</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ps -ef|grep -c svn </span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>从文件中读取关键词进行搜索</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -f test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -f test2.txt</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行</p><p><strong>从文件中读取关键词进行搜索 且显示行号</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -nf test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -nf test2.txt</span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">6:Redhat</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行，并显示每一行的行号</p><p><strong>从文件中查找关键词</strong></p><p><strong>命令：</strong></p><p>grep ‘linux’ test.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# grep &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# grep -n &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>找出以u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^u</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^u</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出非 u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^[^u]</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^[^u]</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出以 hat 结尾的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep hat$</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep hat$</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>显示包含 ed 或者 at 字符的内容行</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep -E “ed|at”</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;peida|com&quot;</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;ed|at&quot;</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grep test *file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;结果如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:Linux test #列出testfile_2 文件中包含test字符的行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux、grep" scheme="http://yoursite.com/categories/Linux%E3%80%81grep/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>sed命令使用</title>
    <link href="http://yoursite.com/2020/08/08/sed%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/08/sed命令使用/</id>
    <published>2020-08-08T11:57:10.000Z</published>
    <updated>2020-08-11T08:28:58.506Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、sed" scheme="http://yoursite.com/categories/Linux%E3%80%81sed/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>awk命令使用</title>
    <link href="http://yoursite.com/2020/08/07/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/07/awk命令使用/</id>
    <published>2020-08-07T11:57:10.000Z</published>
    <updated>2020-08-12T03:25:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>./java -jar /home/bdc/beh-oss.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin filetest 5.flv19 single</p><p>java -jar /home/bdc/beh-oss-minio-test-1.0-SNAPSHOT.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /home/bdc/test uploa<br>ad 10 10 10 420000</p><p>./mc ls mycloud/filetest/6.xml | wc -l</p><p>#!/bin/bash</p><p>sum_num=300000<br>for((i=0;i&lt;=10;i++));do<br>  echo $sum_num</p><p>  #java -cp beh-oss-minio-test-1.0-SNAPSHOT.jar com.bonc.beh.oss.MinioTest <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /opt/beh/core/MinIO/alone/ upload 10 10 10 $sum_num<br>  sum_num=<code>expr 10000 + $sum_num</code><br>done</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;./java -jar /home/bdc/beh-oss.jar &lt;a href=&quot;http://172.16.48.1:8000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://172.16.48.1:8000&lt;/a&gt; minioadmin
      
    
    </summary>
    
    
      <category term="Linux、awk" scheme="http://yoursite.com/categories/Linux%E3%80%81awk/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux上CPU内存使用查看</title>
    <link href="http://yoursite.com/2020/08/06/linux%E4%B8%8ACPU%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2020/08/06/linux上CPU内存使用查看/</id>
    <published>2020-08-06T11:57:10.000Z</published>
    <updated>2020-08-07T01:16:16.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top 命令的显示结果如下所示：</span><br><span class="line"></span><br><span class="line">top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 </span><br><span class="line">Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie </span><br><span class="line">Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si </span><br><span class="line">Mem: 191272k total, 173656k used, 17616k free, 22052k buffers </span><br><span class="line">Swap: 192772k total, 0k used, 192772k free, 123988k cached </span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </span><br><span class="line">1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd </span><br><span class="line">14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top </span><br><span class="line">1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init </span><br><span class="line">2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 </span><br><span class="line">3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>统计信息区</strong></p><p>前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p><table><thead><tr><th>01:06:48</th><th>当前时间</th></tr></thead><tbody><tr><td>up 1:22</td><td>系统运行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值。</td></tr></tbody></table><p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用 CPU 百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用 CPU 百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>98.7% id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><p>最后两行为内存信息。内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。 相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><p><strong><em>free [选项]</em></strong></p><p><strong>默认情况下，即在没有选项的情况下，\</strong>“*<em>free”命令显示内存的使用信息。默认按照k（b）的计数单位统计。*</em></p><ul><li>total：表示 总计物理内存的大小。</li><li>used：表示 已使用多少。</li><li>free：表示 可用内存多少。</li><li>Shared：表示多个进程共享的内存总额。</li><li>Buffers/cached：表示 磁盘缓存的大小。</li></ul><p><strong>注意：free命令的选项区分大小写，请认真对照上图中是大写还是小写</strong></p><ol><li>free -b：以bytes为单位来显示内存的信息。</li><li>free -k：以kb为单位来显示内存的信息。</li><li>free -m：以m为单位来显示内存的信息。</li><li>free -g：以G为单位来显示内存的信息。</li><li>free -h：以适于人类可读方式显示内存信息。-h与其他命令最大不同是<strong>-h</strong>选项会在数字后面加上适于人类可读的单位</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;top命令&quot;&gt;&lt;a href=&quot;#top命令&quot; class=&quot;headerlink&quot; title=&quot;top命令&quot;&gt;&lt;/a&gt;top命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;top 命令的显示结果如下所示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mem: 191272k total, 173656k used, 17616k free, 22052k buffers &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swap: 192772k total, 0k used, 192772k free, 123988k cached &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>NERDTree快捷键</title>
    <link href="http://yoursite.com/2020/07/23/NERDTree%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/23/NERDTree快捷键/</id>
    <published>2020-07-23T11:57:10.000Z</published>
    <updated>2020-08-04T09:35:20.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换工作台和目录"><a href="#切换工作台和目录" class="headerlink" title="切换工作台和目录"></a>切换工作台和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><h3 id="NerdTree-在-vimrc-中的常用配置"><a href="#NerdTree-在-vimrc-中的常用配置" class="headerlink" title="NerdTree 在 .vimrc 中的常用配置"></a>NerdTree 在 .vimrc 中的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="line">autocmd VimEnter * NERDTree</span><br><span class="line"></span><br><span class="line">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class="line">map  :silent! NERDTreeToggle</span><br><span class="line"></span><br><span class="line">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;切换工作台和目录&quot;&gt;&lt;a href=&quot;#切换工作台和目录&quot; class=&quot;headerlink&quot; title=&quot;切换工作台和目录&quot;&gt;&lt;/a&gt;切换工作台和目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + h    光标 focus 左侧树形目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + l    光标 focus 右侧文件显示窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + w    光标自动在左右侧窗口切换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + r    移动当前窗口的布局位置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>MacVim编辑器使用</title>
    <link href="http://yoursite.com/2020/07/22/MacVim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/22/MacVim编辑器使用/</id>
    <published>2020-07-22T11:57:10.000Z</published>
    <updated>2020-09-18T03:31:03.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式区分"><a href="#Vim-模式区分" class="headerlink" title="Vim 模式区分"></a>Vim 模式区分</h3><h5 id="普通模式-Normal-mode"><a href="#普通模式-Normal-mode" class="headerlink" title="普通模式 (Normal mode)"></a>普通模式 (Normal mode)</h5><ul><li>Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑</li></ul><h5 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h5><ul><li>该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.</li></ul><h5 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h5><ul><li>与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式</li></ul><h5 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h5><ul><li>新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)</li></ul><h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><ul><li>在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启</li></ul><a id="more"></a><h3 id="元字符的存在"><a href="#元字符的存在" class="headerlink" title="元字符的存在"></a>元字符的存在</h3><p>元字符是 Vim 对模糊匹配的一个附加属性，通过元字符可以快速找出目标字段.</p><ul><li><code>.</code>: 表示匹配任意 <strong>一个</strong> 字符。例: <code>c..l</code> 表示任意以 c 开头，中间有两个任意字符，l 结尾的字段.</li><li><code>.*</code>: 表示匹配 <strong>任意多个</strong> 字符。例: <code>c.*l</code> 表示任意以 c 开头 l 结尾的字段 (不会将一个字段进行跨行处理，因此非常智能，很频繁使用)</li><li><code>$</code>: 匹配行尾。例: <code>/d.*$</code> 表示匹配到以 d 开头到行尾中的所有内容，<code>/123$</code> 表示以 123 结尾的所有字段</li><li><code>^</code>: 匹配行首。例: <code>^.*d</code> 表示匹配到行首到 d 的所有内容，<code>/^123</code> 表示以 123 开头的字段</li><li><code>\&lt;</code> : 匹配单词词首</li><li><code>\&gt;</code>: 匹配单词词尾。例: <code>/\&lt;f\&gt;</code> 表示只匹配 <code>f</code> 单词，如果其前有任何字符它就不是单词，不会被匹配到.</li><li><code>\( \)</code>: 括号内的内容可以在后面被引用，引用方式为 <code>\1</code>, <code>\2</code></li><li><code>*</code>: 表示其前字符可以重复 0~ 无数 次。如 <code>/be*</code> 会匹配到 <code>b</code>, <code>be</code>, <code>bee</code> …, 因为 e 重复零次就是没有，所以会返回 b</li><li><code>\+</code>: 表示其前字符必须重复 1~ 无数 次，如 <code>/be\+</code> 会匹配到 <code>be</code>, <code>bee</code>, <code>beee</code> …</li><li><code>\=</code>: 代表其前字符必须重复 0 或者 1 次.</li><li><code>\{n,m}</code> : 其前字符必须重复 n 到 m 次</li><li><code>[adz]</code>: 匹配 <code>a</code>, <code>d</code>, <code>z</code> 中的任意 <strong>一个</strong> , 括号内也可是数字，如 <code>[2-5]</code> 表示匹配 <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> 中的任意一个数字</li><li><code>\|</code>; 或的意思，表示只要符合其前或其后任意一个字符即可。例: <code>/one\|two\|three</code> 表示匹配 one, two, three 中的任意一个. <code>end\(if\|while\|for\)</code> 表示会查找到 endif, endwhile, endfor 中的任意一个.</li><li><code>[^a]</code>: 匹配除 <code>a</code> 以外的任意 <strong>字符</strong></li><li><code>[a-c]</code>: 匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个，递增的顺序</li><li><code>\d</code>: 匹配十进制数字中的任意一个，等同于 <code>[0-9]</code>. 例: <code>/\d\d:\d\d:\d\d</code> 表示查找如 <code>17:31:00</code> 格式的字符</li><li><code>\D</code>: 匹配除十进制数字外的任意一个字符，等同于 <code>[^0-9]</code></li><li><code>\x</code>: 匹配十六进制数字中的任意一个，等同于 <code>[0-9A-Fa-f]</code></li><li><code>\X</code>: 匹配除十六进制数字外的任意一个字符，等同于 <code>[^0-9A-Fa-f]</code></li><li><code>\w</code>: 匹配一个单词 (对中文来说非常鸡肋，因为只有 Vim 判定是单词的才会进行匹配，与 <code>w</code>, <code>b</code>, <code>e</code> , 的匹配规则相同)</li><li><code>\W</code>: 匹配除单词外的所有字符。因为在 vim 中中文全部不被认为是单词，因此，此匹配会选中所有中文字段.</li><li><code>\t</code>: 匹配 tab , 可使用此方法将所有 tab 替换为空格</li><li><code>\s</code>: 匹配空白字段，包含 tab 与空格，在 pattern 中使用此查找空白，在 string 中就可以直接使用空格或者 tab 来输入以替换了</li><li><code>\S</code>: 匹配非空白字段，等同于 <code>[^\s]</code></li><li><code>\n</code>: 匹配换行符</li><li><code>\r</code>: 换行，在 pattern 中使用 <code>\n</code> 作为搜索串，在 string 中使用 <code>\r</code> 作为换行命令 (如果在 string 中仍然使用 \n 的话会出错)</li><li><code>\_s</code>: 匹配换行或空白</li><li><code>\_a</code>: 匹配换行或单词 (因为是单词，vim 不会匹配中文)</li><li><code>\C</code>: 区分大小写地查找或替换，例: <code>/\CText</code> 表示只会查找 <code>Text</code>, 不会查找 <code>text</code> 或 <code>tExt</code> 等</li><li><code>\c</code>: 不区分大小写地查找替换 (已经在 vim 中设置了默认不区分了)</li></ul><p>如上所述，<code>.</code>, <code>*</code>, <code>[</code>, <code>]</code>, <code>^</code>, <code>%</code>, <code>/</code>, <code>?</code>, <code>~</code>, <code>$</code> 这十个字符有特殊含义，如果对这十个字符进行匹配，需要添加 <code>\</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h5 id="查找逻辑"><a href="#查找逻辑" class="headerlink" title="查找逻辑"></a>查找逻辑</h5><ul><li><code>/单词</code>: 全文查找 view 关键字 (n 为向下方向)</li><li><code>/\c单词</code>: 全文查找 view 关键字 (大小写不敏感)</li><li><code>?单词</code>: 全文查找 view 关键字 (n 为向上方向)</li><li><code>:noh</code> : 退出查找模式</li><li><code>*</code>: 全文查找光标处词组 (n 为向下方向)</li><li><code>#</code>: 全文查找光标处词组 (n 为向上方向)</li><li><code>n</code>: 下一个列出的关键字</li><li><code>N</code>: 上一个列出的关键字</li></ul><h5 id="查找实例"><a href="#查找实例" class="headerlink" title="查找实例"></a>查找实例</h5><p><code>/\&lt;单词\&gt;</code>: 查找只为 <code>单词</code> 的字符</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>假如有这么一行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thee best time to see thee flowers is in thee spring.</span><br></pre></td></tr></table></figure><ul><li>当我键入<code>:s/thee/the &lt;回车&gt;</code>，那么该行的第一 <code>thee</code> 就被我替换成了 <code>the</code></li><li>如果想将所有的 <code>thee</code> 替换，可以键入<code>:s/thee/the/g</code></li><li>要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :% s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :% s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li></ul><h2 id="文本编辑之删除"><a href="#文本编辑之删除" class="headerlink" title="文本编辑之删除"></a>文本编辑之删除</h2><p>只需要将光标移动到你想要删除的文本位置，按下 <code>x</code> 键即可</p><blockquote><p>提示：当我对某个操作不满意，想要撤回的时候，只要键入 u 即可</p></blockquote><h2 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h2><p>简单来说，如果我想要删除一个单词只需要键入 <code>dw</code>，如果我键入 <code>d$</code>，那么这一整行的内容都被我删了(dd也可以达到相同的效果)</p><h2 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h2><p><strong><em>假如 vim 打开的文件中某一个行有这样一句的内容</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is just a line with words you can move around in.</span><br></pre></td></tr></table></figure><p>我的光标在开头的 T 位置</p><ul><li>键入一次 e，我的光标位置就会出现在 This 这个单词的末尾 s 处，键入两次，就会出现在下一个单词的末尾。</li><li>键入 w，就会出现在下一个单词的开头，多次键入与 e 的效果雷同。</li><li>键入 0(数字0)，能使我的光标出现在行首。</li><li>键入 $，能使我的光标出现在行末。</li></ul><h2 id="使用计数已删除更多"><a href="#使用计数已删除更多" class="headerlink" title="使用计数已删除更多"></a>使用计数已删除更多</h2><p>上面已经提到过删除操作符和动作的组合，你可以在组合中动作之前插入一个数字以删除更多</p><p> d number (数字) motion</p><p>比如键入 <code>d2w</code>，我们就可以删除光标所在位置起的两个单词</p><h2 id="操作整行"><a href="#操作整行" class="headerlink" title="操作整行"></a>操作整行</h2><ul><li>之前用 <code>d$</code> 命令删除整行内容后，我们会发现这一行变成了一个空行，所以可能用清除整行内容来称呼它更加合适</li><li>如果我们要删除当前行，可以键入 <code>dd</code> 命令</li><li>你也可以键入 <code>2dd</code>，来删除当前行起的两行(向下)</li></ul><h2 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h2><ul><li>之前有提到过，如果你操作失误，可以键入 <code>u</code> 来撤销最后一次执行的命令</li><li>如果你嫌一次一次的撤销太麻烦，你可以键入 <code>U</code>，来使当前行恢复到初始状态</li></ul><h2 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h2><p>之前所说的 <code>dd</code> 命令删除了一整行内容，其实呢，并没有消失，而是保存在了 vim 的寄存器中。</p><ul><li>当使用 <code>dd</code> 命令删除了某一行内容后，光标移到某一行，键入 <code>p</code>，刚刚删除掉的那一行内容就会粘贴到当前行的下一行了</li></ul><h2 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h2><ul><li>键入 <code>cw</code>，然后输入正确的内容，我们就可以更改整个单词了。</li></ul><h2 id="复制一行"><a href="#复制一行" class="headerlink" title="复制一行"></a>复制一行</h2><ul><li><code>yy</code> 复制光标所在位置的一行， <code>yw</code>复制光标所在的单词， 使用<code>p</code>进行粘贴；</li></ul><h2 id="在-vim-内执行外部命令的方法"><a href="#在-vim-内执行外部命令的方法" class="headerlink" title="在 vim 内执行外部命令的方法"></a>在 vim 内执行外部命令的方法</h2><p>再用 vim 编程的时候，如果我想输入一个外部命令怎么办，难道我还需要新建个终端窗口吗？当然不需要</p><p>1、 按下我们所熟悉的 <code>:</code> 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。</p><p>2、 接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3、 我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样</p><p>经常遇到这样的场景，复制多行，然后粘贴。</p><ol><li>将光标移动到要复制的文本开始的地方，按<code>v</code>进入可视模式。</li><li>将光标移动到要复制的文本的结束的地方，按 y 复制。此时 vim 会自动将光标定位到选中文本的开始的地方，并退出可视模式。</li><li>我移动光标到文本结束的地方，按<code>p</code>粘贴。</li></ol><p>[参考链接]<a href="https://ruby-china.org/topics/4266" target="_blank" rel="noopener">https://ruby-china.org/topics/4266</a></p><p>[参考链接]<a href="https://juejin.im/post/5aed4b0651882567127868df#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5aed4b0651882567127868df#heading-14</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vim-模式区分&quot;&gt;&lt;a href=&quot;#Vim-模式区分&quot; class=&quot;headerlink&quot; title=&quot;Vim 模式区分&quot;&gt;&lt;/a&gt;Vim 模式区分&lt;/h3&gt;&lt;h5 id=&quot;普通模式-Normal-mode&quot;&gt;&lt;a href=&quot;#普通模式-Normal-mode&quot; class=&quot;headerlink&quot; title=&quot;普通模式 (Normal mode)&quot;&gt;&lt;/a&gt;普通模式 (Normal mode)&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;插入模式&quot;&gt;&lt;a href=&quot;#插入模式&quot; class=&quot;headerlink&quot; title=&quot;插入模式&quot;&gt;&lt;/a&gt;插入模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;可视模式&quot;&gt;&lt;a href=&quot;#可视模式&quot; class=&quot;headerlink&quot; title=&quot;可视模式&quot;&gt;&lt;/a&gt;可视模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;替换模式&quot;&gt;&lt;a href=&quot;#替换模式&quot; class=&quot;headerlink&quot; title=&quot;替换模式&quot;&gt;&lt;/a&gt;替换模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;命令行模式&quot;&gt;&lt;a href=&quot;#命令行模式&quot; class=&quot;headerlink&quot; title=&quot;命令行模式&quot;&gt;&lt;/a&gt;命令行模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>使用VIM打开文件报错</title>
    <link href="http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8VIM%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/21/使用VIM打开文件报错/</id>
    <published>2020-07-21T11:57:10.000Z</published>
    <updated>2020-08-18T01:01:00.021Z</updated>
    
    <content type="html"><![CDATA[<p>下载完vim的主题之后打开文件报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /Users/luxiaofeng/.vim/colors/molokai.vim</span><br><span class="line">Error detected while processing /Users/luxiaofeng/.vim/colors/molokai.vim:</span><br><span class="line">line   10:</span><br><span class="line">E411: highlight group not found: clear^M</span><br><span class="line">line   11:</span><br><span class="line">E15: Invalid expression: version &gt; 580^M</span><br><span class="line">line  275:</span><br><span class="line">E171: Missing :endif</span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开那个文件后：</span><br><span class="line">:set ff=unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载完vim的主题之后打开文件报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="linux、vim" scheme="http://yoursite.com/tags/linux%E3%80%81vim/"/>
    
  </entry>
  
  <entry>
    <title>vim安装插件之后的各种报错</title>
    <link href="http://yoursite.com/2020/07/20/vim%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/20/vim安装插件之后的各种报错/</id>
    <published>2020-07-20T11:57:10.000Z</published>
    <updated>2020-07-28T09:13:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件nerdtree"><a href="#安装插件nerdtree" class="headerlink" title="安装插件nerdtree"></a>安装插件nerdtree</h2><p>启动MacVim报错<code>Error detected while processing function &lt;SNR&gt;2_lod_cmd</code>或者<code>Error detected while processing function &lt;SNR&gt;3_lod_cmd</code></p><p>原因是在<code>.vimrc</code>中配置的插件为<code>Plug &#39;scrooloose/nerdtree&#39;, { &#39;on&#39;: &#39;NERDTreeToggle&#39; }</code>. 改为 <code>Plug &#39;scrooloose/nerdtree&#39;</code>之后报错消失；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装插件nerdtree&quot;&gt;&lt;a href=&quot;#安装插件nerdtree&quot; class=&quot;headerlink&quot; title=&quot;安装插件nerdtree&quot;&gt;&lt;/a&gt;安装插件nerdtree&lt;/h2&gt;&lt;p&gt;启动MacVim报错&lt;code&gt;Error detected
      
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim插件安装</title>
    <link href="http://yoursite.com/2020/07/19/Vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/07/19/Vim插件安装/</id>
    <published>2020-07-19T11:57:10.000Z</published>
    <updated>2020-08-05T01:36:27.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装vim-plug插件"><a href="#安装vim-plug插件" class="headerlink" title="安装vim-plug插件"></a>安装vim-plug插件</h2><ul><li><p>首先下载插件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:junegunn/vim-plug.git</span><br></pre></td></tr></table></figure></li><li><p>下载 plug.vim(<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a>) 并将其放在 “自动加载” 目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；</a></p></li><li><p>在<code>~/.vimrc</code>中添加一个 vim-plug 部分</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&apos;data&apos;) . &apos;/plugged&apos;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &apos;plugin&apos;</span><br><span class="line">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class="line"></span><br><span class="line">&quot; Make sure you use single quotes</span><br><span class="line"></span><br><span class="line">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br><span class="line">Plug &apos;junegunn/vim-easy-align&apos;</span><br><span class="line"></span><br><span class="line">&quot; Any valid git URL is allowed</span><br><span class="line">Plug &apos;https://github.com/junegunn/vim-github-dashboard.git&apos;</span><br><span class="line"></span><br><span class="line">&quot; Multiple Plug commands can be written in a single line using | separators</span><br><span class="line">Plug &apos;SirVer/ultisnips&apos; | Plug &apos;honza/vim-snippets&apos;</span><br><span class="line"></span><br><span class="line">&quot; On-demand loading</span><br><span class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;:  &apos;NERDTreeToggle&apos; &#125;</span><br><span class="line">Plug &apos;tpope/vim-fireplace&apos;, &#123; &apos;for&apos;: &apos;clojure&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a non-master branch</span><br><span class="line">Plug &apos;rdnetto/YCM-Generator&apos;, &#123; &apos;branch&apos;: &apos;stable&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br><span class="line">Plug &apos;fatih/vim-go&apos;, &#123; &apos;tag&apos;: &apos;*&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin options</span><br><span class="line">Plug &apos;nsf/gocode&apos;, &#123; &apos;tag&apos;: &apos;v.20150303&apos;, &apos;rtp&apos;: &apos;vim&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br><span class="line">Plug &apos;junegunn/fzf&apos;, &#123; &apos;dir&apos;: &apos;~/.fzf&apos;, &apos;do&apos;: &apos;./install --all&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Unmanaged plugin (manually installed and updated)</span><br><span class="line">Plug &apos;~/my-prototype-plugin&apos;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>重新加载.vimrc 并<code>:PlugInstall</code>安装插件,执行完成之后，使用vim打开文件有报错的话，一般是因为Windows下的换行符和Linux下的换行符不一样导致的，那个文件报错就使用vim打开那个文件，使用命令:set ff=unix修改换行符；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装vim-plug插件&quot;&gt;&lt;a href=&quot;#安装vim-plug插件&quot; class=&quot;headerlink&quot; title=&quot;安装vim-plug插件&quot;&gt;&lt;/a&gt;安装vim-plug插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载插件 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:junegunn/vim-plug.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载 plug.vim(&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/a&gt;) 并将其放在 “自动加载” 目录中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;~/.vimrc&lt;/code&gt;中添加一个 vim-plug 部分&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
</feed>
