<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-19T03:20:18.840Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="http://yoursite.com/2019/12/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/19/滑动窗口问题/</id>
    <published>2019-12-19T11:57:10.000Z</published>
    <updated>2019-12-19T03:20:18.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode239-滑动窗口最大值"><a href="#LeetCode239-滑动窗口最大值" class="headerlink" title="LeetCode239. 滑动窗口最大值"></a>LeetCode<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h4><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p></blockquote><ul><li>题目解析<br>利用一个 双端队列，在队列中存储元素在数组中的位置， 并且维持队列的严格递减，，也就说维持队首元素是 <strong>最大的</strong>，当遍历到一个新元素时，如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。</li></ul><p>Deque 继承自 Queue（队列）(详情见下方参考链接)，它的直接实现有 ArrayDeque、LinkedList 等。</p><p><img src="/2019/12/19/滑动窗口问题/aaa.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">    //测试用例里面有nums = [], k = 0，所以只好加上这个判断</span><br><span class="line">    if (nums == null || nums.length &lt; k || k == 0) return new int[0];</span><br><span class="line">    //最大值组成的数组大小为numsnums.length-k+1;</span><br><span class="line">    int[] res = new int[nums.length - k + 1];</span><br><span class="line">    //双端队列</span><br><span class="line">    ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        //在尾部添加元素，并保证左边元素都比尾部大</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.getLast()] &lt; nums[i]) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(i);</span><br><span class="line">        //在头部移除元素</span><br><span class="line">        if (deque.getFirst() == i - k) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果</span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            res[i - k + 1] = nums[deque.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://blog.jrwang.me/2016/java-collections-deque-arraydeque/" target="_blank" rel="noopener">https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</a><br>[参考链接]<a href="https://www.cnblogs.com/lxyit/p/9080590.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxyit/p/9080590.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode239-滑动窗口最大值&quot;&gt;&lt;a href=&quot;#LeetCode239-滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode239. 滑动窗口最大值&quot;&gt;&lt;/a&gt;LeetCode&lt;a href=&quot;https://lee
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>刷LeetCode常用函数</title>
    <link href="http://yoursite.com/2019/12/18/%E5%88%B7LeetCode%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/18/刷LeetCode常用函数/</id>
    <published>2019-12-18T11:57:10.000Z</published>
    <updated>2019-12-18T01:48:00.819Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">float[] height = new float[20]；</span><br><span class="line">java.util.Arrays.fill( height, 175.5f );</span><br><span class="line">表示用 float 型的值 175.5f 初始化数组 height [20] ，即用此值填充所有数组项。</span><br><span class="line"></span><br><span class="line">Arrays.fill（）函数</span><br><span class="line"></span><br><span class="line">用法 1：接受 2 个参数</span><br><span class="line">Arrays.fill（ a1, value ）;</span><br><span class="line">注：a1 是一个数组变量，value 是一个 a1 中元素数据类型的值，作用：填充 a1 数组中的每个元素都是 value</span><br><span class="line">例如：</span><br><span class="line">boolean[] a1 = new boolean[5];</span><br><span class="line">Arrays.fill( a1,true );</span><br><span class="line">结果 a1 [] = &#123;true,true,true,true,true&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用法 2：接受 4 个参数</span><br><span class="line">例如：</span><br><span class="line">String[] a9 = new String[6];</span><br><span class="line">Arrays.fill(a9, &quot;Hello&quot;);</span><br><span class="line">Arrays.fill(a9, 3, 5,&quot;World&quot;);</span><br><span class="line">结果是 a9 [] = &#123;Hello,Hello,Hello,World,World,Hello&#125;;</span><br><span class="line">第一个参数指操作的数组，第二个和第三个指在该数组的某个区域插入第四个参数，第二个参数指起始元素下标（包含该下标），第三个参数指结束下标（不包含该下标），注意：java 的数组下标从 0 开始</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java常用方法" scheme="http://yoursite.com/tags/Java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树叶子节点数</title>
    <link href="http://yoursite.com/2019/12/17/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/17/完全二叉树叶子节点数/</id>
    <published>2019-12-17T11:57:10.000Z</published>
    <updated>2019-12-18T01:31:24.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例题：假如⼀个完全⼆叉树中有 743 个节点，则该⼆叉树中的叶子节点个数为？</span><br><span class="line"></span><br><span class="line">假设完全二叉树中，度为 0 的叶子结点为 n0，度为 1 的结点为 n1，度为 2 的结点为 n2，总结点数为 n。</span><br><span class="line">则 n=n0+n1+n2;</span><br><span class="line">并且有 n-1=2n2+n1;</span><br><span class="line">如果总结点数为奇数，则 n1 为 0，为偶数，则 n1 为 1；</span><br><span class="line">带入式子求得 n0：371</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之接雨水</title>
    <link href="http://yoursite.com/2019/12/16/LeetCode%E4%B9%8B%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://yoursite.com/2019/12/16/LeetCode之接雨水/</id>
    <published>2019-12-16T11:57:10.000Z</published>
    <updated>2019-12-16T07:02:20.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><a id="more"></a><p><img src="/2019/12/16/LeetCode之接雨水/aaa.jpg" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>黑色的看成墙，蓝色的看成水，宽度一样，给定一个数组，每个数代表从左到右墙的高度，求出能装多少单位的水。也就是图中蓝色正方形的个数。</p><h3 id="解法一：按列求"><a href="#解法一：按列求" class="headerlink" title="解法一：按列求"></a>解法一：按列求</h3><p>求每一列的水，我们只需要关注当前列，以及左边最高的墙，右边最高的墙就够了。装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以分为三种情况。</p><ul><li>较矮的墙的高度大于当前列的墙的高度</li></ul><p><img src="/2019/12/16/LeetCode之接雨水/bbb.jpg" alt><br>把正在求的列左边最高的墙和右边最高的墙确定后，然后为了方便理解，我们把无关的墙去掉。<br><img src="/2019/12/16/LeetCode之接雨水/ccc.jpg" alt></p><p>这样就很清楚了，现在想象一下，往两边最高的墙之间注水。正在求的列会有多少水？很明显，较矮的一边，也就是左边的墙的高度，减去当前列的高度就可以了，也就是 2 - 1 = 1，可以存一个单位的水。</p><ul><li>较矮的墙的高度小于当前列的墙的高度<br><img src="/2019/12/16/LeetCode之接雨水/ddd.jpg" alt></li></ul><p>同样的，我们把其他无关的列去掉。<br><img src="/2019/12/16/LeetCode之接雨水/eee.jpg" alt></p><p>想象下，往两边最高的墙之间注水。正在求的列会有多少水？</p><p>正在求的列不会有水，因为它大于了两边较矮的墙。</p><ul><li>较矮的墙的高度等于当前列的墙的高度。</li></ul><p>和上一种情况是一样的，不会有水。<br><img src="/2019/12/16/LeetCode之接雨水/fff.jpg" alt><br>明白了这三种情况，程序就很好写了，遍历每一列，然后分别求出这一列两边最高的墙。找出较矮的一端，和当前列的高度比较，结果就是上边的三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int max_left = 0;</span><br><span class="line">        //找出左边最高</span><br><span class="line">        for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (height[j] &gt; max_left) &#123;</span><br><span class="line">                max_left = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max_right = 0;</span><br><span class="line">        //找出右边最高</span><br><span class="line">        for (int j = i + 1; j &lt; height.length; j++) &#123;</span><br><span class="line">            if (height[j] &gt; max_right) &#123;</span><br><span class="line">                max_right = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出两端较小的</span><br><span class="line">        int min = Math.min(max_left, max_right);</span><br><span class="line">        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： [公式]，遍历每一列需要 [公式] ，找出左边最高和右边最高的墙加起来刚好又是一个 [公式] ，所以是 [公式] 。</p><p>​空间复杂度：O (1）。</p><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的）</p><p>对于 max_left 我们其实可以这样求。</p><p>max_left [i] = Max(max_left [i-1],height[i-1])。i前边的墙(即i-1)的左边的最高高度和它前边的墙(即i-1)的高度选一个较大的，就是当前列左边最高的墙了。对于 max_right 我们可以这样求。max_right[i] = Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int[] max_left = new int[height.length];</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int min = Math.min(max_left[i], max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。</p><p>空间复杂度：O (n)，用来保存每一列左边最高的墙和右边最高的墙。</p><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>动态规划中，我们常常可以对空间复杂度进行进一步的优化。</p><p>例如这道题中，可以看到，max_left [ i ] 和 max_right [ i ] 数组中的元素我们其实只用一次，然后就再也不会用到了。所以我们可以不用数组，只用一个元素就行了。我们先改造下 max_left。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left = Math.max(max_left, height[i - 1]);</span><br><span class="line">        int min = Math.min(max_left, max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们成功将 max_left 数组去掉了。但是会发现我们不能同时把 max_right 的数组去掉，因为最后的 for 循环是从左到右遍历的，而 max_right 的更新是从右向左的。</p><p>所以这里要用到两个指针，left 和 right，从两个方向去遍历。</p><p>那么什么时候从左到右，什么时候从右到左呢？根据下边的代码的更新规则，我们可以知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_left = Math.max(max_left, height[i - 1]);</span><br></pre></td></tr></table></figure><p>height [ left - 1] 是可能成为 max_left 的变量，同理，height [ right + 1 ] 是可能成为 right_max 的变量。</p><p>只要保证 height [ left - 1 ] &lt; height [ right + 1 ] ，那么 max_left 就一定小于 max_right。</p><p>因为 max_left 是由 height [ left - 1] 更新过来的，而 height [ left - 1 ] 是小于 height [ right + 1] 的，而 height [ right + 1 ] 会更新 max_right，所以间接的得出 max_left 一定小于 max_right。</p><p>反之，我们就从右到左更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int max_right = 0;</span><br><span class="line">    int left = 1;</span><br><span class="line">    int right = height.length - 2; // 加右指针进去</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        //从左到右更</span><br><span class="line">        if (height[left - 1] &lt; height[right + 1]) &#123;</span><br><span class="line">            max_left = Math.max(max_left, height[left - 1]);</span><br><span class="line">            int min = max_left;</span><br><span class="line">            if (min &gt; height[left]) &#123;</span><br><span class="line">                sum = sum + (min - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        //从右到左更</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            max_right = Math.max(max_right, height[right + 1]);</span><br><span class="line">            int min = max_right;</span><br><span class="line">            if (min &gt; height[right]) &#123;</span><br><span class="line">                sum = sum + (min - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。<br>空间复杂度：O (1)。</p><p>​### 解法四：栈</p><p><img src="/2019/12/16/LeetCode之接雨水/ggg.jpg" alt></p><p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p><p>我们用栈保存每堵墙。</p><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>总体的原则就是，<br>1.当前高度小于等于栈顶高度，入栈，指针后移。<br>2.当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p><p>我们看具体的例子。</p><ul><li><p>首先将 height [ 0 ] 入栈。然后 current 指向的高度大于栈顶高度，所以把栈顶 height [ 0 ] 出栈，然后栈空了，再把 height [ 1 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/hhh.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶高度，height [ 2 ] 入栈，current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/jjj.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，栈顶 height [ 2 ] 出栈。计算 height [ 3 ] 和新的栈顶之间的水。计算完之后继续判断 current 和新的栈顶的关系。<br><img src="/2019/12/16/LeetCode之接雨水/kkk.jpg" alt></p></li><li><p>current 指向的高度大于栈顶高度，栈顶 height [ 1 ] 出栈，栈空。所以把 height [ 3 ] 入栈。currtent 后移。<br><img src="/2019/12/16/LeetCode之接雨水/lll.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 3 ] 的高度，height [ 4 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/zzz.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 4 ] 的高度，height [ 5 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/xxx.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶 height [ 5 ] 的高度，将栈顶 height [ 5 ] 出栈，然后计算 current 指向的墙和新栈顶 height [ 4 ] 之间的水。计算完之后继续判断 current 的指向和新栈顶的关系。此时 height [ 6 ] 不大于栈顶 height [ 4 ] ，所以将 height [ 6 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/vvv.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，将栈顶 height [ 6 ] 出栈。计算和新的栈顶 height [ 4 ] 组成两个边界中的水。然后判断 current 和新的栈顶 height [ 4 ] 的关系，依旧是大于，所以把 height [ 4 ] 出栈。计算 current 和 新的栈顶 height [ 3 ] 之间的水。然后判断 current 和新的栈顶 height [ 3 ] 的关系，依旧是大于，所以把 height [ 3 ] 出栈，栈空。将 current 指向的 height [ 7 ] 入栈。current 后移。<br>其实不停的出栈，可以看做是在找与 7 匹配的墙，也就是 3 。</p></li></ul><p><img src="/2019/12/16/LeetCode之接雨水/nnn.jpg" alt><br>而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离。可以看下代码继续理解下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int trap6(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    int current = 0;</span><br><span class="line">    while (current &lt; height.length) &#123;</span><br><span class="line">        //如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span><br><span class="line">        while (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            int h = height[stack.peek()]; //取出要出栈的元素</span><br><span class="line">            stack.pop(); //出栈</span><br><span class="line">            if (stack.empty()) &#123; // 栈空就出去</span><br><span class="line">                break; </span><br><span class="line">            &#125;</span><br><span class="line">            int distance = current - stack.peek() - 1; //两堵墙之前的距离。</span><br><span class="line">            int min = Math.min(height[stack.peek()], height[current]);</span><br><span class="line">            sum = sum + distance * (min - h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current); //当前指向的墙入栈</span><br><span class="line">        current++; //指针后移</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：虽然 while 循环里套了一个 while 循环，但是考虑到每个元素最多访问两次，入栈一次和出栈一次，所以时间复杂度是 [n] 。</p><p>空间复杂度： [n] 。栈的空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈、双指针、动态规划" scheme="http://yoursite.com/categories/%E6%A0%88%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2019/12/14/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/12/14/三次握手和四次挥手/</id>
    <published>2019-12-14T11:57:10.000Z</published>
    <updated>2019-12-16T02:46:28.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。</p><a id="more"></a><h3 id="TCP-服务模型"><a href="#TCP-服务模型" class="headerlink" title="TCP 服务模型"></a>TCP 服务模型</h3><p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p><p>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</p><p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而 IP 不提供重复消除或者保证次序正确的功能。另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>客户端和服务端通信前要进行连接，“3 次握手” 的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的 “响应” 是由于第一次的 “请求” 触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表面上看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的 “指令” 是上层应用层给出的，我只是一个 “搬运工”，我无法了解 “上层的意志”。</p><ul><li>TCP 的三次握手改成两次握手可以吗？</li></ul><p>不可以，一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><p>在谢希仁著《计算机网络》第四版中讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲 “三次握手” 的目的是为了解决 “网络中存在延迟的重复分组” 的问题。这两种不用的表述其实阐明的是同一个问题。<br>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”。主要目的防止 server 端一直等待，浪费资源。</p><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53374516</a><br>[参考链接]<a href="https://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="noopener">https://blog.csdn.net/xifeijian/article/details/12777187</a><br>[参考链接]<a href="https://ioscaff.com/articles/252" target="_blank" rel="noopener">https://ioscaff.com/articles/252</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h3&gt;&lt;p&gt;TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。&lt;/p&gt;
&lt;p&gt;TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。&lt;/p&gt;
&lt;p&gt;TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tcp协议" scheme="http://yoursite.com/categories/tcp%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>学习两个月算法之后的总结</title>
    <link href="http://yoursite.com/2019/12/14/%E5%AD%A6%E4%B9%A0%E4%B8%A4%E4%B8%AA%E6%9C%88%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/14/学习两个月算法之后的总结/</id>
    <published>2019-12-14T11:57:10.000Z</published>
    <updated>2019-12-15T16:52:49.129Z</updated>
    
    <content type="html"><![CDATA[<ul><li>克服焦虑，不再心急<br>首先要承认自己这两个月学算法学的有点焦虑，所有视频只过了一遍；焦虑是由于自己处理不好学习算法和项目的时间转换，也是有点心急，但是后来一想算法是个持久战，不能心急，慢慢的；越是心急越是陷入了死循环；</li><li>馒头要一口一口吃<br>尽管学的有点焦虑，也还是学到了很多东西，画递归图虽然有点傻，但是也不失为理解递归的好方法，馒头总要一口一口吃；我愿再花上两个月的时间跨过算法这道坎；</li><li>观念转变<br>通过两个月的时间学习算法，发现很多题都是有模板，也就是按照一定的套路就可以做出来，这个思想的转变很重要，使得不再恐惧算法；</li><li>承认自己不是天才<br>承认自己不是天才这点非常重要，有时候我们就是太自信了，学什么都是按照自己想象的有效的方法进行学习（本来就是高手的除外），自己的方法无效，何不去试试别人有效的方法呢，它山之石可以攻玉；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;克服焦虑，不再心急&lt;br&gt;首先要承认自己这两个月学算法学的有点焦虑，所有视频只过了一遍；焦虑是由于自己处理不好学习算法和项目的时间转换，也是有点心急，但是后来一想算法是个持久战，不能心急，慢慢的；越是心急越是陷入了死循环；&lt;/li&gt;
&lt;li&gt;馒头要一口一口吃&lt;b
      
    
    </summary>
    
    
      <category term="算法总结" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法总结" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2019/12/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2019/12/13/动态规划/</id>
    <published>2019-12-13T11:57:10.000Z</published>
    <updated>2019-12-13T08:16:46.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划的三大步骤"><a href="#动态规划的三大步骤" class="headerlink" title="动态规划的三大步骤"></a>动态规划的三大步骤</h2><blockquote><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p></blockquote><a id="more"></a><ul><li><p>第一步骤</p><blockquote><blockquote><p>定义数组元素的含义，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp [] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp [i] 是代表什么意思？</p></blockquote></blockquote></li><li><p>第二步骤</p><blockquote><blockquote><p>找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp [n] 时，是可以利用 dp [n-1]，dp [n-2]…..dp [1]，来推出 dp [n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说</p></blockquote></blockquote></li><li><p>第三步骤</p><blockquote><blockquote><p>找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，我们可以通过 dp [n-1] 和 dp [n-2] 来计算 dp [n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp [3] = dp [2] + dp [1]。而 dp [2] 和 dp [1] 是不能再分解的了，所以我们必须要能够直接获得 dp [2] 和 dp [1] 的值，而这，就是所谓的初始值。</p></blockquote></blockquote></li></ul><p><strong>有了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp [n] 的值了，而 dp [n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。</strong></p><h2 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h2><h3 id="案例一-简单的一维-DP"><a href="#案例一-简单的一维-DP" class="headerlink" title="案例一: 简单的一维 DP"></a>案例一: 简单的一维 DP</h3><blockquote><p>问题描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote><ul><li><p>定义数组元素的含义</p><blockquote><blockquote><p>按我上面的步骤说的，首先我们来定义 dp [i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp [i] 的含义为：跳上一个 i 级的台阶总共有 dp [i] 种跳法。这样，如果我们能够算出 dp [n]，不就是我们要求的答案吗？所以第一步定义完成。</p></blockquote></blockquote></li><li><p>找出数组元素间的关系式</p><blockquote><blockquote><p>我们的目的是要求 dp [n]，动态规划的题，如你们经常听说的那样，就是把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。也就是说，dp [n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp [n] 一定会和 dp [n-1], dp [n-2]…. 存在某种关系的。我们要找出他们的关系。</p></blockquote></blockquote></li></ul><p>那么问题来了，怎么找？<br>这个怎么找，是最核心最难的一个，我们必须回到问题本身来了，来寻找他们的关系式，dp [n] 究竟会等于什么呢？<br>对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</p><p><strong><em>一种是从第 n-1 级跳上来</em></strong><br><strong><em>一种是从第 n-2 级跳上来</em></strong><br>由于我们是要算所有可能的跳法的，所以有 dp [n] = dp [n-1] + dp [n-2]。</p><ul><li>找出初始条件<blockquote><blockquote><p>当 n = 1 时，dp [1] = dp [0] + dp [-1]，而我们是数组是不允许下标为负数的，所以对于 dp [1]，我们必须要直接给出它的数值，相当于初始值，显然，dp [1] = 1。一样，dp [0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：</p></blockquote></blockquote></li></ul><p>dp [0] = 0. dp [1] = 1. 即 n &lt;= 1 时，dp [n] = n.</p><p>三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f( int n )&#123;</span><br><span class="line">    if(n &lt;= 1)&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 先创建一个数组来保存历史数据</span><br><span class="line">    int[] dp = new int[n+1];</span><br><span class="line">    // 给出初始值</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    // 通过关系式来计算出 dp[n]</span><br><span class="line">    for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把最终结果返回</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再说初始化</li></ul><p>大家先想以下，你觉得，上面的代码有没有问题？<br>答是有问题的，还是错的，错在对初始值的寻找不够严谨，这也是我故意这样弄的，意在告诉你们，关于初始值的严谨性。例如对于上面的题，当 n = 2 时，dp [2] = dp [1] + dp [0] = 1。这显然是错误的，你可以模拟一下，应该是 dp [2] = 2。</p><p><strong><em>也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp [2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。</em></strong></p><h3 id="案例二-二维数组的-DP"><a href="#案例二-二维数组的-DP" class="headerlink" title="案例二: 二维数组的 DP"></a>案例二: 二维数组的 DP</h3><p><strong><em>我做了几十道 DP 的算法题，可以说，80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。</em></strong>这里的我指的是别人，不是指的本我</p><blockquote><p>问题描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。问总共有多少条不同的路径？<br><img src="/2019/12/13/动态规划/aaa.png" alt></p></blockquote><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp [i] [j] 的含义为：当机器人从左上角走到 (i, j) 这个位置时，一共有 dp [i] [j] 种路径。那么，dp [m-1] [n-1] 就是我们要的答案了。</p><blockquote><blockquote><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp [m-1] [n-1] 就是我们要找的答案。</p></blockquote></blockquote><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><blockquote><blockquote><p>一种是从 (i-1, j) 这个位置走一步到达<br>一种是从 (i, j - 1) 这个位置走一步到达</p></blockquote></blockquote><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp [i] [j] = dp [i-1] [j] + dp [i] [j-1]。</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n-1] 和所有的 dp [0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><blockquote><blockquote><p>dp [0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走<br>dp [0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquePaths(int m, int n) &#123;</span><br><span class="line">    if (m &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n]; // </span><br><span class="line">    // 初始化</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">      dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 推导出 dp[m-1][n-1]</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三、二维数组-DP"><a href="#案例三、二维数组-DP" class="headerlink" title="案例三、二维数组 DP"></a>案例三、二维数组 DP</h3><blockquote><p>问题描述：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">输入:</span><br><span class="line">arr = [</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>我还是要按照步骤来写，让那些不大懂的加深理解。有人可能觉得，这些题太简单了吧，别慌，小白先入门，这些属于 medium 级别的，后面在给几道 hard 级别的。</p><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp [i] [j] 的含义为：当机器人从左上角走到 (i, j) 这个位置时，最下的路径和是 dp [i] [j]。那么，dp [m-1] [n-1] 就是我们要的答案了。</p><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp [m-1] [n-1] 就是我们要走的答案。</p><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><blockquote><blockquote><p>一种是从 (i-1, j) 这个位置走一步到达</p></blockquote></blockquote><blockquote><blockquote><p>一种是从 (i, j - 1) 这个位置走一步到达</p></blockquote></blockquote><p>不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，那么我们要从这两种方式中，选择一种，使得 dp [i] [j] 的值是最小的，显然有</p><p>dp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];// arr[i][j] 表示网格中的值</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n-1] 和所有的 dp [0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><blockquote><p>dp [0] [j] = arr [0] [j] + dp [0] [j-1]; // 相当于最上面一行，机器人只能一直往左走<br>dp [i] [0] = arr [i] [0] + dp [i] [0]; // 相当于最左面一列，机器人只能一直往下走案例三、二维数组 DP</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquePaths(int[][] arr) &#123;</span><br><span class="line">    int m = arr.length;</span><br><span class="line">    int n = arr[0].length;</span><br><span class="line">    if (m &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n]; // </span><br><span class="line">    // 初始化</span><br><span class="line">    dp[0][0] = arr[0][0];</span><br><span class="line">    // 初始化最左边的列</span><br><span class="line">    for(int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][0] = dp[i-1][0] + arr[i][0];</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化最上边的行</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">      dp[0][i] = dp[0][i-1] + arr[0][i];</span><br><span class="line">    &#125;</span><br><span class="line">        // 推导出 dp[m-1][n-1]</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-4：编辑距离"><a href="#案例-4：编辑距离" class="headerlink" title="案例 4：编辑距离"></a>案例 4：编辑距离</h3><p>这次给的这道题比上面的难一些，在 leetcdoe 的定位是 hard 级别。</p><blockquote><p>问题描述:给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line">插入一个字符 删除一个字符 替换一个字符</span><br><span class="line">示例：</span><br><span class="line">输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p>按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且 90% 是采用二维数组。</p><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp [i] [j] 的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp [i] [j]。</p><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>接下来我们就要找 dp [i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp [i] [j] 和 dp [i-1] [j]、dp [i] [j-1]、dp [i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，从规模小的，通过一些操作，推导出规模大的。对于这道题，我们可以对 word1 进行三种操作</p><blockquote><blockquote><p>插入一个字符 删除一个字符 替换一个字符</p></blockquote></blockquote><p>由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：</p><p>一、如果我们 word1 [i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp [i] [j] = dp [i-1] [j-1]。（别忘了 dp [i] [j] 的含义哈）。</p><p>二、如果我们 word1 [i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：<br>（1）如果把字符 word1 [i] 替换成与 word2 [j] 相等，则有 dp [i] [j] = dp [i-1] [j-1] + 1;</p><p>（2）如果在字符串 word1 末尾插入一个与 word2 [j] 相等的字符，则有 dp [i] [j] = dp [i] [j-1] + 1;</p><p>（3）如果把字符 word1 [i] 删除，则有 dp [i] [j] = dp [i-1] [j] + 1;</p><p>那么我们应该选择一种操作，使得 dp [i] [j] 的值最小，显然有</p><p>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</p><p>于是，我们的关系式就推出来了，</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n] 和所有的 dp [0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">    int n1 = word1.length();</span><br><span class="line">    int n2 = word2.length();</span><br><span class="line">    int[][] dp = new int[n1 + 1][n2 + 1];</span><br><span class="line">    // dp[0][0...n2]的初始值</span><br><span class="line">    for (int j = 1; j &lt;= n2; j++) </span><br><span class="line">        dp[0][j] = dp[0][j - 1] + 1;</span><br><span class="line">    // dp[0...n1][0] 的初始值</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) </span><br><span class="line">        dp[i][0] = dp[i - 1][0] + 1;</span><br><span class="line">        // 通过公式推出 dp[n1][n2]</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n2; j++) &#123;</span><br><span class="line">            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span><br><span class="line">            if (word1.charAt(i - 1) == word2.charAt(j - 1))&#123;</span><br><span class="line">                p[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n1][n2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划的三大步骤&quot;&gt;&lt;a href=&quot;#动态规划的三大步骤&quot; class=&quot;headerlink&quot; title=&quot;动态规划的三大步骤&quot;&gt;&lt;/a&gt;动态规划的三大步骤&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤，&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="递归、栈" scheme="http://yoursite.com/categories/%E9%80%92%E5%BD%92%E3%80%81%E6%A0%88/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归详解</title>
    <link href="http://yoursite.com/2019/12/13/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/13/递归详解/</id>
    <published>2019-12-13T11:57:10.000Z</published>
    <updated>2019-12-14T13:47:54.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p></blockquote></blockquote><a id="more"></a><blockquote><blockquote><p>说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>题目给出的算法结构为：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>首先题目要求返回的类型为 List&lt;List<integer>&gt;，那么我们就新建一个 List&lt;List<integer>&gt; 作为全局变量，最后将其返回。</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line"></span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>再看看返回的结构，List&lt;List<integer>&gt;。因此我们需要写一个包含 List<integer> 的辅助函数，加上一些判断条件，此时结构变成了：</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>重点就是如何进行递归。递归的第一步，当然是写递归的终止条件啦，没有终止条件的递归会进入死循环。那么有 哪些终止条件呢？由于条件中说了都是正整数。。因此，如果 target&lt;0, 当然是要终止了，如果 target==0，说明此时找到了一组数的和为 target，将其加进去。此时代码结构变成了这样。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>我们是要求组成 target 的组合。因此需要一个循环来进行遍历。每遍历一次，将此数加入 list，然后进行下一轮递归。代码结构如下。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process( candidates, target - candidates[i], list);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/递归详解/fff.jpg" alt><br>似乎初具规模，测试一把结果如下：<br><img src="/2019/12/13/递归详解/aaa.jpg" alt></p><blockquote><blockquote><p>结果差距有点大，为何会出现如此大的反差。而且发现一个规律，后面的一个组合会包含前面一个组合的所有的数字，而且这些数加起来和 target 也不相等啊。原因出在哪呢？java 中除了几个基本类型，其他的类型可以算作引用传递。这就是导致 list 数字一直变多的原因。因此，在每次递归完成，我们要进行一次回溯。把最新加的那个数删除。此时代码结构变成这样。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process( candidates, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再测一下，结果如下：<br><img src="/2019/12/13/递归详解/bbb.jpg" alt></p><blockquote><blockquote><p>还是不对。这次加起来都等于 7 了，和上次结果相比算是一个很大的进步了。分析下测试结果。不难能看出，本次结果的主要问题包含了重复的组合。为什么会有重复的组合呢？因为每次递归我们都是从 0 开始，所有数字都遍历一遍。所以会出现重复的组合。改进一下，只需加一个 start 变量即可。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(0, candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int start, int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        //递归的终止条件</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process(i, candidates, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后再测一下。<br><img src="/2019/12/13/递归详解/ccc.jpg" alt></p><blockquote><blockquote><p>代码通过，但是效率并不高。本题有效果更好的动态规划的解法。本文主要展示递归回溯，就不做具体介绍了。是不是有点感觉了，那么再来一题。</p></blockquote></blockquote><blockquote><blockquote><p>题目描述:给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目给出的算法结构为</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>按照前面的套路，首先建一个 ArrayList&lt;List<integer>&gt; res 作为全局变量。顺带建一个含有 List<integer>list 的辅助函数。</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">此时结构变成如下所示。</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>对于辅助递归函数。第一步当然是列出终止条件，避免进入死循环。由于题目要求是所有 k 个数的组合。那么很容易知道递归的终止条件为 list.size() == k。因此，代码结构可变为如下所示。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>接下来要进入重头戏了，递归回溯的整个过程。整个递归过程不就是一直将数字加入 list 么。因此可以用一个循环。</p></blockquote></blockquote><p>在循环中主要做三件事</p><p>1.加此轮的数据加入 list。</p><p>2.递归进行下一步调用。</p><p>3.删除此轮加入的数据进行回溯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">此时代码结构如下：</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n ; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            generateCombinations(n,k,i+1,list);</span><br><span class="line">            list.remove(list.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>代码大致结构以及形成，测试一下，结果如下。</p></blockquote></blockquote><p>通过是通过了，但是真的慢啊。<br><img src="/2019/12/13/递归详解/ddd.jpg" alt></p><p>分析一下原因所在。假设 n = 100, k= 90, i = 15，按照上面的代码，我们还需要继续循环 85 次。但是想一下，即使后面的循环每次都加一个数据，最后也才 85 个数据。</p><p>不能形成一组解。也就是说这些循环都是在做无用功，因此引出一个很重要的知识点。 剪枝循环的终止条件不应该是 i&lt;=n, 应该是 i-1 +(k-list.size()) &lt;= n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">因此代码如下:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n-(k-list.size())+1 ; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            generateCombinations(n,k,i+1,list);</span><br><span class="line">            list.remove(list.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果如下。<br><img src="/2019/12/13/递归详解/eee.jpg" alt></p><blockquote><blockquote><p>当一个问题可以被不断分解为一个个更加简单的问题的时候，并且在最终会有一个明确的终点的时候，这个时候便是考虑运用递归的时候了。举一个栗子 ： 非常经典的斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… 在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F (n-1)+F (n-2)（n&gt;=2，n∈N*）。</p></blockquote></blockquote><p>//这里我们用两种递归方法来解决，一种是最初的简单递归，二是对简单递归的优化</p><p>int fib(int n){//求出数列第n项的数值</p><pre><code>if(n==1||n==2){    return 1;//回溯的条件}else {    return fib(n-1)+fib(n-2);//向下递进}</code></pre><p>}</p><blockquote><blockquote><p>这里我们看 fib(5) = fib(4)+fib(3) fib(4) = fib(3)+fib(2) fib(3) = fib(2)+fib(1)<br>这里有很多的计算是重复的，所以这也是递归的缺点之一,在这里我们可以看到递归的思路，第n项为前两项的和，那么我们便可以不断地向前推进直到已知项,这里还有一种对于上述递归解法的优化方法<br>我们看前几项分别为1 1 2 3 5<br>fiber(1,1,5) = fiber(1,2,4) = fiber(2,3,3)<br>解释上述表达式 前两项分别为1 1的第五项与前两项分别为 1 2的第四项与前两项分别为 2 3 的第3项相等 所以我们运用这种思路来避免重复的计算来降低计算的复杂度;</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fiber(1,1,5) = fiber(1,2,4) = fiber(2,3,3)</span><br><span class="line"></span><br><span class="line">1, 1, 2, 3, 5</span><br><span class="line">1, 2, 3, 5</span><br><span class="line">2, 3, 5</span><br><span class="line"></span><br><span class="line">int fiber(int first,int second,int num)&#123;</span><br><span class="line">if(n&gt;0)&#123;</span><br><span class="line">if(num==1||num==2)</span><br><span class="line">return 1;</span><br><span class="line">else if(num==3)</span><br><span class="line">return first+second;</span><br><span class="line">else</span><br><span class="line">return fiber(second,first+second,--num);</span><br><span class="line">&#125;else</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>将斐波那契数列改为非递归方式实现：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">  if (n == 2) &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int ret = 0;</span><br><span class="line">  int pre = 2;</span><br><span class="line">  int prepre = 1;</span><br><span class="line">  for (int i = 3; i &lt; n; i++) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/34841160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34841160</a><br>[参考链接]<a href="https://zhuanlan.zhihu.com/p/92782083" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92782083</a><br>[参考链接]<a href="https://zhuanlan.zhihu.com/p/88760014" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88760014</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="递归、栈" scheme="http://yoursite.com/categories/%E9%80%92%E5%BD%92%E3%80%81%E6%A0%88/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Jackson注解</title>
    <link href="http://yoursite.com/2019/12/12/Jackson%E4%B8%AD%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/12/Jackson中注解使用/</id>
    <published>2019-12-12T11:57:10.000Z</published>
    <updated>2019-12-12T08:26:03.715Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使Jackson 序列化和反序列化字段不一致</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;aa&quot;)</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @JsonProperty(&quot;bb&quot;)</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>办法就是 set 和 get 方法上 JsonProperty 分别指定反序列化和序列化的字段名称假如 name 的值为 test 这样一来就可以以 “{“bb”:”test”}” 来反序列化，然后序列化的输出是 “{“aa”:”test”}”</p></blockquote></blockquote><ul><li>作用在属性上，序列化输出时，使用别名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如下：输出 json 串时，用的是 loginname 别名。</span><br><span class="line">@JsonProperty(&quot;loginname&quot;)</span><br><span class="line">private String loginName;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使Jackson 序列化和反序列化字段不一致&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="序列化与反序列化" scheme="http://yoursite.com/categories/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
      <category term="序列化与反序列化" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>定时任务实现</title>
    <link href="http://yoursite.com/2019/12/12/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/12/定时任务实现/</id>
    <published>2019-12-12T11:57:10.000Z</published>
    <updated>2019-12-13T02:24:05.253Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通过 Timer 来实现<blockquote><blockquote><p>自定义一个任务，继承于 TimerTask，重写 run 方法;利用 java.util.Timer 实现任务调度</p></blockquote></blockquote></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedule &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line">        long delay = 2000;</span><br><span class="line">        long interval = 1000;</span><br><span class="line"></span><br><span class="line">        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次</span><br><span class="line">        timer.schedule(new JobTask(), delay, interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JobTask extends TimerTask &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Test: &quot; + Calendar.getInstance().getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。</p><p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。<br>例如我们指定每隔 1000 毫秒执行一次任务，但是可能某个任务执行花了 5000 毫秒，因此导致后续的任务并不能按时启动执行。</p><ul><li>通过 ScheduledExecutorService 来实现</li></ul><blockquote><blockquote><p>鉴于 Timer 的上述缺陷，Java 5 推出了基于线程池设计的 ScheduledExecutorService。<br>其设计思想是，每一个被调度的任务都会 由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。<br>需要注意的是，只有当任务的执行时间到来时，ScheduledExecutorService 才会真正启动一个线程，其余时间 ScheduledExecutorService 都是在轮询任务的状态。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedule &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);</span><br><span class="line">        long delay = 2;</span><br><span class="line">        long interval = 1;</span><br><span class="line"></span><br><span class="line">        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次</span><br><span class="line">        service.scheduleAtFixedRate(</span><br><span class="line">                new JobTask(), delay,</span><br><span class="line">                interval, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JobTask implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Test: &quot; + Calendar.getInstance().getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;通过 Timer 来实现&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义一个任务，继承于 TimerTask，重写 run 方法;利用 java.util.Timer 实现任务调度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor学习</title>
    <link href="http://yoursite.com/2019/12/09/supervisor%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/09/supervisor学习/</id>
    <published>2019-12-09T11:57:10.000Z</published>
    <updated>2019-12-19T02:51:07.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ul><li>下载相应版本进行源码安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">tar -zxvf supervisor-3.1.3.tar.gz</span><br><span class="line">cd supervisor-3.1.3</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p><img src="/2019/12/09/supervisor学习/aaa.jpg" alt></p><ul><li>生成配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /opt/supervisor-3.1.3/supervisord.conf</span><br><span class="line">###为了不将所有新增配置信息全写在一个配置文件里，这里新建一个文件夹，每个程序(需要使用supervisor管理的程序)设置一个配置文件，相互隔离</span><br><span class="line">mkdir /opt/supervisor-3.1.3/supervisord.d/</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/12/09/supervisor学习/bbb.jpg" alt><br><img src="/2019/12/09/supervisor学习/ccc.jpg" alt></p><ul><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">### 修改配置文件</span><br><span class="line">vim supervisord.conf</span><br><span class="line"></span><br><span class="line">### 加入以下配置信息</span><br><span class="line">[include]</span><br><span class="line">files = /opt/supervisor-3.1.3/supervisord.d/*.conf</span><br><span class="line"></span><br><span class="line">### 在supervisord.conf中设置通过web可以查看管理的进程，加入以下代码（默认即有，取消注释即可）    </span><br><span class="line">[inet_http_server] </span><br><span class="line">port=9001</span><br><span class="line">username=user      </span><br><span class="line">password=123</span><br><span class="line"></span><br><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/opt/beh/supervisor/log/supervisord.log  ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</span><br><span class="line">logfile_backups=10          ; (num of main logfile rotation backups;default 10)</span><br><span class="line">loglevel=info               ; (log level;default info; others: debug,warn,trace)</span><br><span class="line">pidfile=supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">nodaemon=false              ; (start in foreground if true;default false)</span><br><span class="line">minfds=1024                 ; (min. avail startup file descriptors;default 1024)</span><br><span class="line">minprocs=200                ; (min. avail process descriptors;default 200)</span><br><span class="line">;supervisor启动用户设置</span><br><span class="line">user=chrism                 ; (default is current user, required if root)</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">;serverurl=unix://./supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line">serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket</span><br></pre></td></tr></table></figure></li><li><p>移动配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/supervisorctl  /opt/supervisor-3.1.3</span><br><span class="line">mv /usr/bin/supervisord  /opt/supervisor-3.1.3</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/12/09/supervisor学习/ddd.jpg" alt></p><ul><li>启动服务端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /opt/supervisor-3.1.3/supervisord.conf</span><br></pre></td></tr></table></figure></li></ul><p>[参考文章]<a href="https://www.cnblogs.com/mhq-martin/p/8649621.html" target="_blank" rel="noopener">https://www.cnblogs.com/mhq-martin/p/8649621.html</a></p><p>[参考文章]<a href="https://www.jianshu.com/p/f8735b039c67" target="_blank" rel="noopener">https://www.jianshu.com/p/f8735b039c67</a></p><p>[参考文章]<a href="https://www.jianshu.com/p/bf2b3f4dec73" target="_blank" rel="noopener">https://www.jianshu.com/p/bf2b3f4dec73</a></p><p>[参考文章]<a href="https://juejin.im/post/5d80da83e51d45620c1c5471" target="_blank" rel="noopener">https://juejin.im/post/5d80da83e51d45620c1c5471</a></p><p>[参考文章]<a href="https://www.huweihuang.com/article/linux/supervisor-usage/" target="_blank" rel="noopener">https://www.huweihuang.com/article/linux/supervisor-usage/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;源码安装&quot;&gt;&lt;a href=&quot;#源码安装&quot; class=&quot;headerlink&quot; title=&quot;源码安装&quot;&gt;&lt;/a&gt;源码安装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载相应版本进行源码安装&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /opt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf supervisor-3.1.3.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd supervisor-3.1.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo python setup.py install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>GitHub搜索小技巧</title>
    <link href="http://yoursite.com/2019/12/03/GitHub%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/12/03/GitHub搜索小技巧/</id>
    <published>2019-12-03T11:57:10.000Z</published>
    <updated>2019-12-17T01:30:30.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h3><p>传统的搜索就是直接使用关键词，但是 GitHub 的搜索功能远远不止如此，还可以：</p><a id="more"></a><h4 id="名称包含"><a href="#名称包含" class="headerlink" title="名称包含"></a>名称包含</h4><ul><li><p>xxx in:name 项目名包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/aaa.png" alt></p></li><li><p>xxx in:description 项目描述包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/bbb.png" alt></p></li><li><p>xxx in:readme 项目的 README 文件中包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/ccc.png" alt></p></li></ul><h4 id="仓库统计范围"><a href="#仓库统计范围" class="headerlink" title="仓库统计范围"></a>仓库统计范围</h4><p>比如：</p><ul><li><p>Django stars:&gt;=2048<br>要查找 Stars 数不小于 2048 的 Django 项目<br><img src="/2019/12/03/GitHub搜索小技巧/ddd.png" alt></p></li><li><p>Django forks:&gt;2048<br>Forks 大于等于 2048<br><img src="/2019/12/03/GitHub搜索小技巧/eee.png" alt></p></li><li><p>Django forks:100..200 stars:80..100<br>查找 Forks 在 100 到 200 之间 且 Star 数在 80 到 100 之间的 Django 项目<br><img src="/2019/12/03/GitHub搜索小技巧/fff.png" alt></p></li></ul><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/79434481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79434481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;搜索技巧&quot;&gt;&lt;a href=&quot;#搜索技巧&quot; class=&quot;headerlink&quot; title=&quot;搜索技巧&quot;&gt;&lt;/a&gt;搜索技巧&lt;/h3&gt;&lt;p&gt;传统的搜索就是直接使用关键词，但是 GitHub 的搜索功能远远不止如此，还可以：&lt;/p&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="http://yoursite.com/categories/GitHub/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>bdmg部署</title>
    <link href="http://yoursite.com/2019/12/02/bdmg%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/12/02/bdmg部署/</id>
    <published>2019-12-02T09:28:24.000Z</published>
    <updated>2019-12-09T08:20:02.273Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>从git上下载bdmg代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://git@code.bonc.com.cn:10022/bdev/bdm.git</span><br></pre></td></tr></table></figure></li><li><p>下载下来注释掉App.java中部分代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//if(isAuthorized())&#123;</span><br><span class="line">SpringApplication.run(App.class, args);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>在application-bdmg.yml中添加EPM的配置以及修改bdds的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">epm:</span><br><span class="line">    path: /epm/**</span><br><span class="line">    stripPrefix: 1</span><br><span class="line">    uri: http://172.16.13.148:8800  // epm部署所在节点</span><br><span class="line"></span><br><span class="line">bdds:</span><br><span class="line">    path: /bdds/**</span><br><span class="line">    stripPrefix: 1</span><br><span class="line">    uri: http://172.16.13.147:19910  //bdds部署所在节点</span><br></pre></td></tr></table></figure></li><li><p>在BdmgProperties.java文件中添加如下代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//epm配置</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.path&#125;&quot;)</span><br><span class="line">private String epmGateWayPath;</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.stripPrefix&#125;&quot;)</span><br><span class="line">private String epmGateWayStripPrefix;</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.uri&#125;&quot;)</span><br><span class="line">private String epmGateWayStripUri;</span><br></pre></td></tr></table></figure><ul><li>在GatewayRouteConfiguration.java文件中添加如下代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> .route(&quot;epm_route&quot;, r -&gt; r.path(bdmgProperties.getEpmGateWayPath())</span><br><span class="line">                        .filters(f -&gt; &#123;</span><br><span class="line">                            f.stripPrefix(Integer.valueOf(bdmgProperties.getEpmGateWayStripPrefix()));</span><br><span class="line">                            return f;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .uri(bdmgProperties.getEpmGateWayStripUri()))</span><br><span class="line"></span><br><span class="line">.route(&quot;bdds_route&quot;, r -&gt; r.path(bdmgProperties.getBddsGateWayPath())</span><br><span class="line">                        .filters(f -&gt; &#123;</span><br><span class="line">//                            f.filter(new GatewayPreFilter(bdmgProperties));</span><br><span class="line">                            f.stripPrefix(Integer.valueOf(bdmgProperties.getBddsGateWayStripPrefix()));</span><br><span class="line">                            return f;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .uri(bdmgProperties.getBddsGateWayStripUri()))</span><br></pre></td></tr></table></figure><ul><li><p>打包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>启动命令</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /home/bdc/beh-director/share/jdk/jdk1.8.0_131/bin/java -jar bdmg-1.3.0.jar &gt;bdmg.log &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;从git上下载bdmg代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone ssh://git@code.bonc.com.cn:10022/bdev/bdm.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载下来注释掉App.java中部分代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//		if(isAuthorized())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			SpringApplication.run(App.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="项目日记" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="项目笔记" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/11/03/%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/03/总结/</id>
    <published>2019-11-03T10:41:22.067Z</published>
    <updated>2019-11-17T04:38:00.766Z</updated>
    
    <content type="html"><![CDATA[<p>我们清楚，二分查找是实现有序数组查找的高效算法：<br>那么，咱们可以基于二分查找算法，需要考虑一个问题，即若 list [midpoint] != item, 如何缩小查找范围呢？这可以分为两种情形讨论：</p><p>情形 1： 二分查找中，对于数组 [4, 5, 7, 8, 9, 1, 2, 3]，list [low] &lt; list [midpoint] ，说明 low 至 midpoint 这一段是升序的，在这种情况下，若 item &lt; list [low] 且 item &gt; list [midpoint]，那么说明要查找的元素并非在此段，此种情况下，需要在 midpoint+1 到 high 这一段来查找；其余情况，说明 item 就在此段，那么需要在 low 至 midpoint-1 这一段查找即可。</p><p>情形 2： 二分查找中，对于数组 [7, 8, 9, 1, 2, 3, 4, 5]，list [low] &gt; list [midpoint] ，说明 midpoint 至 high 这一段是升序的，在这种情况下，若 item &lt; list [low] 且 item &gt; list [midpoint]，那么说明要查找的元素就在此段，此种情况下，需要在 midpoint+1 到 high 这一段来查找；其余情况，说明 item 不在此段，那么需要在 low 至 midpoint-1 这一段查找即可。</p><p>一、广度优先搜索和深度优先搜索<br>1、广度优先搜索（breadth-first-search）是一种 “地毯式” 层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，<br>依次往外搜索，属于盲目搜索。<br>2、﻿深度优先搜索（depth-first-search）沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，<br>搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，<br>则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br>3、时间复杂度和空间复杂度<br>﻿广度优先的时间复杂度是 O (V+E), 空间复杂度 O (V+E)，V 表示顶点的个数，E 表示边的个数。<br>﻿深度优先搜索算法的时间复杂度是 O (E)，E 表示边的个数，空间复杂度是 O (V)，V 是顶点个数。</p><p>二、贪心算法<br>1、定义：贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。 也就是说，不从整体最优上加以考虑，<br>他所做出的是在某种意义上的局部最优解。<br>2、使用贪心算法的情况：<br>1）针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制的情况下，期望值最大。<br>2）每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。<br>3）大部分情况下，举几个例子验证一下就可以了。严格的证明贪心算法的正确性是非常复杂的，需要涉及较多的数学推理。<br>而且，从实践角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。<br>实际上，用贪心算法解决问题的思路，并不总能给出最优解。</p><p>三、二分查找<br>1、什么是二分查找？<br>二分查找是针对一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一般，<br>直到找到要查找的元素，或者区间缩小为 0。<br>2、实现二分查找注意事项：<br>1）循环退出的条件是：low &lt;= high，不是 low &lt; high。<br>2）mid 的取值，使用 mid=low+(high-low)/2，而不是 mid=(low+high)/2，因为如果 low 和 high 比较大的话，求和可能会发生 int 类型的值超出最大范围。<br>3）low 和 high 的更新：low = mid +1，high = mid + 1，若直接写成 low = mid，high = mid 就肯能发生死循环。<br>3、使用条件<br>1）二分查找依赖的是顺序表结构，即数组。<br>2）二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的过程中。<br>3）数据量太小不适合二分查找，与直接遍历数组相比效率不明显。但是有一个例外，就是数据之间的比较操作非常耗时，<br>比如数组中存储的都是长度超过 300 的字符串，那这还是尽量减少比较 操作使用二分查找。<br>4）数据量太大也不适合二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。</p><p>二分查找<br>使用时机</p><p>单调性<br>有上下界<br>可 index 索引</p><p>每一步都选择当前最优解，以至全局结果是最优解</p><p>使用时机</p><p>子问题最优解，得到全局最优解<br>贪心、回溯、动态规划的区别</p><p>贪心：局部最优解<br>回溯：回退<br>动态规划：最优判断 + 回退</p><p>DFS 模板<br>Stack<treenode> nodes = new Stack&lt;&gt;();<br>Stack<integer> value = new Stack&lt;&gt;();<br>        nodes.push(root);<br>        value.push(1);<br>        int max=0;<br>        while(!nodes.isEmpty()) {<br>            TreeNode node = nodes.pop();<br>            int val= value.pop();<br>            if(node==null)<br>                continue;<br>            if(max&lt;val)<br>                max=val;<br>            nodes.push(node.left);<br>            value.push(val+1);<br>            nodes.push(node.right);<br>            value.push(val+1);<br>        }</integer></treenode></p><pre><code>return max;</code></pre><p>BFS 模板<br>class Solution {<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root) {<br>        List&lt;List<integer>&gt; result = new ArrayList&lt;&gt;();<br>        process(result, root, 0);<br>        return result;<br>    }</integer></integer></p><pre><code>private void process(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root, int depth) {    if (root == null) {        return;    }    List&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();    if (result.size() - 1 &lt; depth) {        tempList.add(root.val);        result.add(tempList);    } else {        tempList = result.get(depth);        tempList.add(root.val);    }    process(result, root.left, depth + 1);    process(result, root.right, depth + 1);}</code></pre><p>}<br>Binary Search 模板<br>public int binarySearch(int[] arr, int key) {<br>    int low = 0;<br>    int high = arr.length - 1;<br>    int mid = 0;</p><pre><code>if (key &lt; arr[low] || key &gt; arr[high] || low &gt; high)    return -1;while (low &lt;= high){    mid = (low + high) / 2;    if (arr[mid] &gt; key)        high = mid - 1;    else if (arr[mid] &lt; key)        low = mid + 1;    else        return mid;}return -1;</code></pre><p>}</p><p>与普通的二分查找相似，该算法唯一的区别是在对每个节点判断时还要判断首尾结点的大小，从而决定查找区域收缩方向：</p><p> while (left &lt;= right) {<br>      int mid = (left + right) / 2;<br>      if (nums[mid] &gt; nums[pivot + 1])<br>        return mid + 1;<br>      else {<br>        if (nums[mid] &lt; nums[left])<br>          right = mid - 1;<br>        else<br>          left = mid + 1;<br>      }<br>    }</p><pre><code>深度优先</code></pre><p>深度优先的思想类似于走迷宫，遇到死胡同时就走另一条路。它的代码模板为：</p><p>boolean Dfs(V){<br>  if(V为终点)<br>      return true;<br>  if(V为旧点)<br>      return false;<br>  将V标记为旧点<br>  对和V相邻的每个节点U:<br>  if(Dfs(U)==true)<br>          return true;<br>  return fasle;<br>}<br>广度优先<br>广度优先是一种 “地毯式” 搜索思想，即层层推进的策略，其内部可以考虑使用队列来实现。它的代码模板为:</p><p>void BFS(Node s){<br>    queue<int> q;<br>    q.push(s);<br>    while(!q.empty()){<br>        取出队首元素top;<br>        访问队首元素top;<br>        将队首元素出队;<br>        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;<br>    }<br>}</int></p><p>这个题我们可以从后往前分析，首先判断倒数第二个元素能否到达最后一个元素，如果可以，我们将不再考虑最后一个元素，<br>因为根据刚才的分析如果可以到达倒数第二个，那么也可以到达最后一个元素。</p><p>然后依次往前递推，如果都能跳到的话，我们最后应该分析的就是第一个元素能否跳到第二个元素上。</p><p>这个比较符合动态规划的思想，我们先用动态规划解下这道题。</p><p>class Solution {<br>    public boolean canJump(int[] nums) {</p><pre><code>    if (nums == null) {        return false;    }    boolean[] dp = new boolean[nums.length];    dp[0] = true;    for (int i = 1; i &lt; nums.length; i++) {        for (int j = 0; j &lt; i; j++) {            // 如果之前的j节点可达，并且从此节点可以到跳到i            if (dp[j] &amp;&amp; nums[j] + j &gt;= i) {                dp[i] = true;                break;            }        }    }    return dp[nums.length - 1];}</code></pre><p>}</p><p>分析上面的代码，可以看出使用动态规划的时间复杂度是 O (n^2)，空间复杂度是 O (n)。</p><p>下面我们使用贪心的思路看下这个问题，我们记录一个的坐标代表当前可达的最后节点，这个坐标初始等于 nums.length-1，<br>然后我们每判断完是否可达，都向前移动这个坐标，直到遍历结束。</p><p>如果这个坐标等于 0，那么认为可达，否则不可达。</p><p>class Solution {<br>    public boolean canJump(int[] nums) {</p><pre><code>    if (nums == null) {        return false;    }    int lastPosition = nums.length - 1;    for (int i = nums.length - 1; i &gt;= 0; i--) {        // 逐步向前递推        if (nums[i] + i &gt;= lastPosition) {            lastPosition = i;        }    }    return lastPosition == 0;    int lastPos = nums.length - 1;    for (int i = nums.length - 1; i &gt;= 0; i--) {        if (i + nums[i] &gt;= lastPos) {            lastPos = i;        }    }    return lastPos == 0;}</code></pre><p>}</p><p>这段代码的时间复杂度是 O (n)，空间复杂度是 O (1)，可以看出比动态规划解法有了明显的性能提升。</p><p>关于复杂度<br>1.1 时间复杂度为 O (n)<br>1.2 空间负责度为 O (1)<br>我的解题思路<br>2.1 定义一个整数存储起点<br>2.2 倒序遍历数组，有两种情况<br>2.2.1 当前索引加上索引上的值大于缓存值，这表示在当前索引上有可能到达终点，移动缓存值<br>2.2.2 当前索引加上索引上的值小于缓存值，表示无法从当前点到达终点，跳出循环<br>2.3 对比 2.1 定义的整数是否等于 0，如果等于 0，表示在索引 0 上有可能到达终点</p><p>跳跃游戏2<br>主要思路就是 cur_max_idx 记录当前位置能跳到的最远位置，然后 i 从 0 遍历到 cur_max_idx + 1, 过程中使用 pre_max_idx 记录能到达的最远位置的最大值，然后直接跳跃到 pre_max_idx 位置，然后重复上述过程。</p><p>class Solution {</p><pre><code>public int jump(vector&lt;int&gt;&amp; nums) {    int n = nums.size();    if(n &lt; 2){        return 0;    }    int pre_max_idx = nums[0];    int cur_max_idx = nums[0];    int jump_min = 1;    for(int i = 0; i &lt; n; i++){        if(i &gt; cur_max_idx){            jump_min++;            cur_max_idx = pre_max_idx;        }        if(pre_max_idx &lt; nums[i] + i){            pre_max_idx = nums[i] + i;        }    }    return jump_min;}</code></pre><p>}</p><p>跳跃游戏 II</p><pre><code>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例:输入: [2,3,1,1,4]输出: 2解释：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jump-game-ii</code></pre><p>思路分析：基于「贪心算法」，每次选择所能跳跃最远的点作为下一跳跃点</p><p>跳跃距离 = 当前坐标 + 所能跳跃最大值</p><p>public int jump(int[] nums) {<br>        int index = 0, count =0; // 记录当前索引以及跳跃次数<br>        while (index+nums[index] &lt; nums.length-1) { // 若当前已在终点或下一次能够到达终点则结束跳跃<br>            int max = 1; // 默认下一跳跃点为最大点<br>            for (int i = 2; i &lt;= nums[index]; i++) {<br>                if (nums[index + i]+ i&gt;= nums[index+max]+max) { // 选取最大跳跃<br>                    max = i;<br>                }<br>            }<br>            index+=max; // 跳跃<br>            count++; // 计数<br>        }<br>        return index==nums.length-1?count:count+1; // 若下一次跳跃才能达到终点，则次数+1<br>    }</p><p>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1</p><p>输入: coins = [2], amount = 3<br>输出: -1</p><pre><code>public int coinChange(int[] coins, int amount) {    int count = 0;    for(int i = coins.length - 1; i &gt;= 0 ; i++){        if(coins &gt; amount){            continue;        }        count += amount / coins;        if(amount % coins == 0){            return count;        }    }    return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们清楚，二分查找是实现有序数组查找的高效算法：&lt;br&gt;那么，咱们可以基于二分查找算法，需要考虑一个问题，即若 list [midpoint] != item, 如何缩小查找范围呢？这可以分为两种情形讨论：&lt;/p&gt;
&lt;p&gt;情形 1： 二分查找中，对于数组 [4, 5, 7,
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/20/LeetCode%E7%AE%97%E6%B3%95%E4%B9%8B/"/>
    <id>http://yoursite.com/2019/10/20/LeetCode算法之/</id>
    <published>2019-10-20T14:58:04.160Z</published>
    <updated>2019-10-27T10:22:59.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习总结："><a href="#学习总结：" class="headerlink" title="学习总结："></a>学习总结：</h3><ul><li>熟悉五毒大法，第一遍刷LeetCode题不能死磕一道题，要从总体进行把握，之后再在细节上面打磨；</li><li>数组方面学习了双指针思想，老师讲了一道使用双指针解决数组问题的算法之后，我们又刷了几道双指针方面的算法，对双指针这种思想有个熟悉感；</li><li>链表方面其实没有什么特别的技巧，链表就是对指针的操作，仔细做了一道链表反转的题，对链表算法有了重新认识；</li><li>栈和队列方面，老师讲了一道栈的应用，技巧性还是很强的，对于栈这种结构有了重新认识。队列在多线程里面应用的还是挺多的，需要熟练掌握队列的应用；</li></ul><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ul><li>这周的时间安排不是很合理，下周要更合理的安排时间进行学习；</li></ul><p> public void merge(int[] nums1, int m, int[] nums2, int n) {</p><pre><code>   if (n == 0){        return;    }    if(m == 0){        for(int i = 0; i &lt; n ; i++){            nums1[i] = nums2[i];        }        return;    }    int k = 0;    for (int i = m - 1, j = n - 1; i &gt;= 0 || j &gt;= 0;){        if (nums1[i] &lt;= nums2[j]){            nums1[i + j + 1] = nums2[j];            j--;            if(j == -1){                break;            }        }else {            nums1[i + j + 1] = nums1[i];            i--;            if(i == -1){                k = j;                System.arraycopy(nums2, 0, nums1, 0, k + 1);                break;            }        }    }    // System.arraycopy(nums2, 0, nums1, 0, k + 1);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习总结：&quot;&gt;&lt;a href=&quot;#学习总结：&quot; class=&quot;headerlink&quot; title=&quot;学习总结：&quot;&gt;&lt;/a&gt;学习总结：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;熟悉五毒大法，第一遍刷LeetCode题不能死磕一道题，要从总体进行把握，之后再在细节上面打磨；&lt;/li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何在互联网上虚度人生</title>
    <link href="http://yoursite.com/2019/10/08/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%E8%99%9A%E5%BA%A6%E4%BA%BA%E7%94%9F/"/>
    <id>http://yoursite.com/2019/10/08/如何在互联网上虚度人生/</id>
    <published>2019-10-08T10:28:24.000Z</published>
    <updated>2019-10-09T09:59:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>详情请阅读全文</p><a id="more"></a><p>这篇大部分是看别人的博客抄的，原博客说看完大概需要4分钟，我大概用了十几分钟，看来我阅读能力也不行了（一定是玩物丧志玩的）</p><p>今天你上网了吗？在网上又花了多少个小时呢，玩了多久的游戏，看到了多久的网剧或者综艺（我小时候特别喜欢看电视剧，长大之后我其实没怎么看过电视剧，当然也看得不少，唉，说话总是前后矛盾）？亦或是刷了多久的抖音短视频（我刷B站，很少看抖音）以及朋友圈（同理朋友圈也很少）？</p><p>不管你是在手机还是电脑上，我相信你总有办法在网上虚度人，短则一天，长则一年，反正在互联网上消磨的时光永远不会嫌多。因为，在互联网上待的时间总是快乐的，同时也是短暂的。</p><p>如果你还没有想好如何在互联网上虚度一生，那么我想给你提出这么几个建议，让你更好的在互联网上浪费你的时间。</p><p>1、打游戏</p><p>英雄联盟（不会），DOTA2（不会），炉石传说（不会），绝地求生（不会），这些你都有对吗。这么多的游戏客户端放在桌面，相信你一个都不想放过。（这么一看我好像没有虚度光阴，接着往下看）</p><p>我相信你很快就能过完一个晚上甚至一天。我以前玩游戏的时候总是觉得时间过得很快，科学告诉我们，游戏会给人们带来兴奋的快感（要相信科学），以及不断的求胜欲望，促使你不断地想要赢得下一场游戏，相信有了兴奋感的催化作用，你一定能在游戏上花上更多时间。</p><p>不喜欢玩端游，那还有手游呢，王者荣耀（最近刚学会），和平精英（玩的很溜了都），自走棋（不会玩）全都撸一遍，上个黄金不是事啊。</p><p>你不知不觉，周末就结束了，明天又要上班了。</p><p>2、没事刷短视频</p><p>如果你的手机上还没有抖音、微视、快手三剑客（三剑客不玩，偶尔刷抖音），那么我建议你赶紧下载吧，比起游戏，刷短视频可能更加简单，你可以这件事情上体会到百分之百的快乐，因为你不会输掉游戏，也不需要打怪升级，你只需要轻轻往下一划，就可以看到下一个有趣的视频了。</p><p>你可以在抖音上看阿猫阿狗，看跳舞的小姐姐、小哥哥（我不怎么玩抖音就是因为里面的男的居然比我帅&lt;我信他个鬼&gt;，你肯定心里骂我是个臭不要脸的，哈哈哈，主要是我没女朋友&lt;为什么没女朋友，因为我的征途是星辰大海&gt;，越说越不要脸了，哈哈哈哈哈，其实是长得太磕碜）或者是一些滑稽搞笑的视频。</p><p>这样一来，你的周末又可以在愉快的刷刷刷中度过啦。</p><p>3、第三点，追剧追热点</p><p>什么？这周末你居然没有看综艺，你竟然没有追当下最火的那个电视剧，你 out 了！还不赶紧打开电视打开手机看看最近新出的这个新剧，而且这个谁谁谁不是最近刚出道不久的当红小鲜肉呢，可不要错过了（电视剧不怎么追&lt;主要是没有什么好看的电视剧，之前追过《将夜》&gt;，综艺现在几乎不看&lt;之前每期都看天天向上，改版之后不看了&gt;）。</p><p>什么？马伊琍和文章离婚了，赶紧看看微博热搜，把前 100 条都看一遍，这个评论太神了，那个评论简直搞笑好吗。要不再刷一下其他黑料，好在朋友圈里再吐槽一下。（微博不怎么看，主要下载之后不会玩，而且我看的时候喷子是真的多，真的多，真的多&lt;可能是我玩的姿势不对&gt;）</p><p>看完了微博，下一站去哪里呢？对了，当然是去知乎了（知乎偶尔玩）。看看第一个问题，你如何看待文章和马伊琍离婚？文章在微博上发的内容又是有什么含义呢？知乎大 V 吐槽就是犀利啊，刷完前十条还不过瘾，再把后面十条看一遍吧。</p><p>知乎也看完了，下一站去哪里呢？看看今天头条又给我推送了什么好玩的东西呢？震惊，某某公众号居然劝粉丝在网上虚度人生；BAT 等互联网公司将大范围裁员，你可能就是下一个牺牲者。</p><p>哎，又变得焦虑起来了，赶紧看看到底是怎么回事儿啦。咦，后面推荐的这三条内容好像有意思呢，我再看看，今日头条的推荐算法还是懂我呀。</p><p>本来只想看今天的头条发生了什么，我怎么一下子刷了这么多的文章呀？</p><p>如果以上技能你都已经掌握了，那么恭喜你，你可以非常轻松地虚度人生了，只要保持这几种习惯，坚持个十年八八年的，相信你就会在碌碌无为中虚度光阴，成为我们所向往的油腻中年人了。</p><p>上面说的已经够多了，但是我再推荐点<br>点开你的手机下载APP今日头条，可以开始刷头条了（这个是真的虚度光阴，我之前意识到之后，果断卸载了），还有一个不得不说的是B站（哔哩哔哩）我玩这个不是看什么二次元或者鬼畜的，我一开始看这个是因为学习视频，你掰着脚趾头都不会想到这个里面的学习视频很多，而且清晰度很不错，这点比百度云好。后来学着学着就漫无目的的刷起来其他的了。</p><p>说了这么多，你该懂我的意思了吧？</p><p>[做梦也没想到写一篇虚度人生的博客还需要参考]<a href="https://www.cnblogs.com/xll1025/p/11334816.html" target="_blank" rel="noopener">https://www.cnblogs.com/xll1025/p/11334816.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详情请阅读全文&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="虚度人生" scheme="http://yoursite.com/tags/%E8%99%9A%E5%BA%A6%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之多线程间通信</title>
    <link href="http://yoursite.com/2019/09/30/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/30/Java并发之多线程间通信/</id>
    <published>2019-09-30T10:28:24.000Z</published>
    <updated>2019-10-16T02:07:52.870Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中线程通信协作的最常见的两种方式：<br>一.syncrhoized 加锁的线程的 Object 类的 wait ()/notify ()/notifyAll ()<br>二.ReentrantLock 类加锁的线程的 Condition 类的 await()/signal()/signalAll()</p><a id="more"></a><h2 id="一-syncrhoized"><a href="#一-syncrhoized" class="headerlink" title="一.syncrhoized"></a>一.syncrhoized</h2><details>  <summary>△object类中方法说明△<此处需要点击></此处需要点击></summary>  <pre><code>    /**    *Wakes up a single thread that is waiting on this object's    *monitor. If any threads are waiting on this object, one of them    *is chosen to be awakened. The choice is arbitrary and occurs at    *the discretion of the implementation. A thread waits on an object's    *monitor by calling one of the wait methods    */   public final native void notify();<p>   /**<br>    *Wakes up all threads that are waiting on this object’s monitor. A<br>    *thread waits on an object’s monitor by calling one of the<br>    *wait methods.<br>    */<br>   public final native void notifyAll();</p><p>   /**<br>    *Causes the current thread to wait until either another thread invokes the<br>    *{@link java.lang.Object#notify()} method or the<br>    *{@link java.lang.Object#notifyAll()} method for this object, or a<br>    *specified amount of time has elapsed.<br>    *The current thread must own this object’s monitor.<br>    */<br>   public final native void wait(long timeout) throws InterruptedException;</p><p>  </p></code></pre><p></p></details><p>从这三个方法的文字描述可以知道以下几点信息：<br>1）wait ()、notify () 和 notifyAll () 方法是本地方法，并且为 final 方法，无法被重写。<br>2）调用某个对象的 wait () 方法能让当前线程阻塞，并且当前线程必须拥有此对象的 monitor（即锁）<br>3）调用某个对象的 notify () 方法能够唤醒一个正在等待这个对象的 monitor 的线程，如果有多个线程都在等待这个对象的 monitor，则只能唤醒其中一个线程；<br>4）调用 notifyAll () 方法能够唤醒所有正在等待这个对象的 monitor 的线程；<br>为何这三个不是 Thread 类声明中的方法，而是 Object 类中声明的方法（当然由于 Thread 类继承了 Object 类，所以 Thread 也可以调用者三个方法）？其实这个问题很简单，由于每个对象都拥有 monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。<br>上面已经提到，如果调用某个对象的 wait () 方法，当前线程必须拥有这个对象的 monitor（即锁），因此调用 wait () 方法必须在同步块或者同步方法中进行（synchronized 块或者 synchronized 方法）。如果当前线程没有这个对象的锁就调用 wait（）方法，则会抛出 IllegalMonitorStateException.<br>调用某个对象的 wait () 方法，相当于让当前线程交出（释放）此对象的 monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread 类中的 sleep 方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；　　<br>notify () 方法能够唤醒一个正在等待该对象的 monitor 的线程，当有多个线程都在等待该对象的 monitor 的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。 同样地，调用某个对象的 notify () 方法，当前线程也必须拥有这个对象的 monitor，因此调用 notify () 方法必须在同步块或者同步方法中进行（synchronized 块或者 synchronized 方法）。</p><p>nofityAll () 方法能够唤醒所有正在等待该对象的 monitor 的线程，这一点与 notify () 方法是不同的。</p><p>这里要注意一点：notify () 和 notifyAll () 方法只是唤醒等待该对象的 monitor 的线程，并不决定哪个线程能够获取到 monitor。</p><p>举个简单的例子：假如有三个线程 Thread1、Thread2 和 Thread3 都在等待对象 objectA 的 monitor，此时 Thread4 拥有对象 objectA 的 monitor，当在 Thread4 中调用 objectA.notify () 方法之后，Thread1、Thread2 和 Thread3 只有一个能被唤醒。注意，被唤醒不等于立刻就获取了 objectA 的 monitor。假若在 Thread4 中调用 objectA.notifyAll () 方法，则 Thread1、Thread2 和 Thread3 三个线程都会被唤醒，至于哪个线程接下来能够获取到 objectA 的 monitor 就具体依赖于操作系统的调度了。</p><p>上面尤其要注意一点，一个线程被唤醒不代表立即获取了对象的 monitor，只有等调用完 notify () 或者 notifyAll () 并退出 synchronized 块，释放对象锁后，其余线程才可获得锁执行。</p><ul><li>sleep/yield/join</li></ul><p>这一组是 Thread 类的方法</p><ul><li>sleep<br>让当前线程暂停指定时间，只是让出 CPU 的使用权，并不释放锁</li><li>yield<br>Thread.yield () 方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）<br>yield () 让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用 yield () 的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证 yield () 达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。​​​官方在其注释中也有相关的说明；<br>结论：大多数情况下，yield () 将导致线程从运行状态转到可运行状态，但有可能没有效果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* A hint to the scheduler that the current thread is willing to yield</span><br><span class="line">* its current use of a processor. The scheduler is free to ignore this</span><br><span class="line">* hint.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="line">* between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="line">* should be combined with detailed profiling and benchmarking to</span><br><span class="line">* ensure that it actually has the desired effect.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="line">* for debugging or testing purposes, where it may help to reproduce</span><br><span class="line">* bugs due to race conditions. It may also be useful when designing</span><br><span class="line">* concurrency control constructs such as the ones in the</span><br><span class="line">* &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class="line">*/​​</span><br><span class="line">        ​​​​</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">+ join</span><br><span class="line">等待调用 join 方法的线程执行结束，才执行后面的代码</span><br><span class="line">其调用一定要在 start 方法之后（看源码可知）​</span><br><span class="line">使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法​</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line">wait()会立刻释放synchronized（obj）中的obj锁，以便其他线程可以执行obj.notify(),但是notify()不会立刻立刻释放sycronized（obj）中的obj锁，必须要等notify()所在线程执行完synchronized（obj）块中的所有代码才会释放这把锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ wait()和sleep()区别</span><br><span class="line">1. wait 会释放锁资源而 sleep 不会释放锁资源.</span><br><span class="line">2. wait 只能在同步方法和同步块中使用，而 sleep 任何地方都可以.</span><br><span class="line">3. wait () 无参数需要唤醒，线程状态 WAITING；wait (1000L); 到时间自己醒过来或者到时间之前被其他线程唤醒，状态和 sleep 都是 TIME_WAITING</span><br><span class="line">4. wait 是 object 顶级父类的方法，sleep 则是 Thread 的方法</span><br><span class="line">5. 调用 wait 方法需要先获得锁，而调用 sleep 方法是不需要的。</span><br><span class="line">6. 调用 wait （没有指定wait时间）方法的线程需要用 notify 来唤醒，而 sleep 必须设置超时值。v</span><br><span class="line">+ ***两者相同点：都会抛出异常，都会让渡 CPU 执行时间，等待再次调度！***</span><br><span class="line"></span><br><span class="line">wait方法有三个重载方法，并且都会调用wait(long timeout)这个方法，wait()等价于wait(0)，0代表永不超时；</span><br><span class="line">Object的wait(long timeout)方法会导致当前线程进入阻塞，直到有其他线程调用了notify或者notifyall方法才能将其唤醒，或者是阻塞时间到达了timeout而自动唤醒；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wait () 方法与 sleep () 方法的不同之处在于，wait () 方法会释放对象的 “锁标志”。当调用某一对象的 wait () 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify () 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll () 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</span><br><span class="line">sleep () 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 sleep () 方法不会释放 “锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二.lock</span><br><span class="line"></span><br><span class="line">+ Condition 的特性:</span><br><span class="line"></span><br><span class="line">任何一个 java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法，比如 wait (),wait (long timeout),wait (long timeout, int nanos) 与 notify (),notifyAll () 几个方法实现等待 / 通知机制，同样的， 在 java Lock 体系下依然会有同样的方法实现等待 / 通知机制。从整体上来看 Object 的 wait 和 notify/notify 是与对象监视器配合完成线程间的等待 / 通知机制，而 Condition 与 Lock 配合完成等待通知机制，前者是 java 底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。</span><br><span class="line"></span><br><span class="line">&gt; 功能特性上的不同：</span><br><span class="line"></span><br><span class="line">1.Condition 能够支持不响应中断，而通过使用 Object 方式不支持；</span><br><span class="line">2.Condition 能够支持多个等待队列（new 多个 Condition 对象），而 Object 方式只能支持一个；</span><br><span class="line">3.Condition 能够支持超时时间的设置，而 Object 不支持</span><br><span class="line"></span><br><span class="line">&gt;针对 Object 的 wait 方法</span><br><span class="line"></span><br><span class="line">1.void await () throws InterruptedException: 当前线程进入等待状态，如果其他线程调用 condition 的 signal 或者 signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常；</span><br><span class="line">2.long awaitNanos (long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；</span><br><span class="line">3.boolean await (long time, TimeUnit unit) throws InterruptedException：同第二种，支持自定义时间单位</span><br><span class="line">4.boolean awaitUntil (Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间</span><br><span class="line"></span><br><span class="line">&gt;针对 Object 的 notify/notifyAll 方法</span><br><span class="line"></span><br><span class="line">1.void signal ()：唤醒一个等待在 condition 上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到 Lock 则可以从等待方法中返回。</span><br><span class="line">2.void signalAll ()：与 1 的区别在于能够唤醒所有等待在 condition 上的线程</span><br><span class="line"></span><br><span class="line">### Condition 实现原理分析</span><br><span class="line"></span><br><span class="line">#### 等待队列</span><br><span class="line">创建一个 condition 对象是通过 lock.newCondition(), 而这个方法实际上是会 new 出一个 ConditionObject 对象，该类是 AQS 的一个内部类。condition 是要和 lock 配合使用的也就是 condition 和 Lock 是绑定在一起的，而 lock 的实现原理又依赖于 AQS，自然而然 ConditionObject 作为 AQS 的一个内部类无可厚非。我们知道在锁机制的实现上，AQS 内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，condition 内部也是使用同样的方式，内部维护了一个 等待队列，所有调用 condition.await 方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到 ConditionObject 中有两个成员变量：</span><br></pre></td></tr></table></figure><p>/** First node of condition queue. <em>/<br>private transient Node firstWaiter;<br>/*</em> Last node of condition queue. */<br>private transient Node lastWaiter;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### await 实现原理</span><br><span class="line">当调用 condition.await () 方法后会使得当前获取 lock 的线程进入到等待队列，如果该线程能够从 await () 方法返回的话一定是该线程获取了与 condition 相关联的 lock。接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。await () 方法源码为：</span><br></pre></td></tr></table></figure><p>public final void await() throws InterruptedException {<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>    // 1. 将当前线程包装成Node，尾插入到等待队列中<br>    Node node = addConditionWaiter();<br>    // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点<br>    int savedState = fullyRelease(node);<br>    int interruptMode = 0;<br>    while (!isOnSyncQueue(node)) {<br>        // 3. 当前线程进入到等待状态<br>        LockSupport.park(this);<br>        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>            break;<br>    }<br>    // 4. 自旋等待获取到同步状态（即获取到lock）<br>    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    if (node.nextWaiter != null) // clean up if cancelled<br>        unlinkCancelledWaiters();<br>    // 5. 处理被中断的情况<br>    if (interruptMode != 0)<br>        reportInterruptAfterWait(interruptMode);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码的主要逻辑请看注释，我们都知道当当前线程调用 condition.await () 方法后，会使得当前线程释放 lock 然后加入到等待队列中，直至被 signal/signalAll 后会使得当前线程从等待队列中移至到同步队列中去，直到获得了 lock 后才会从 await 方法返回，或者在等待时被中断会做中断处理。那么关于这个实现过程我们会有这样几个问题：1. 是怎样将当前线程添加到等待队列中去的？2. 释放锁的过程？3. 怎样才能从 await 方法退出？而这段代码的逻辑就是告诉我们这三个问题的答案。具体请看注释，在第 1 步中调用 addConditionWaiter 将当前线程添加到等待队列中，该方法源码为：</span><br></pre></td></tr></table></figure><p>private Node addConditionWaiter() {<br>    Node t = lastWaiter;<br>    // If lastWaiter is cancelled, clean out.<br>    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    }<br>    //将当前线程包装成Node<br>    Node node = new Node(Thread.currentThread(), Node.CONDITION);<br>    if (t == null)<br>        firstWaiter = node;<br>    else<br>        //尾插入<br>        t.nextWaiter = node;<br>    //更新lastWaiter<br>    lastWaiter = node;<br>    return node;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码就很容易理解了，将当前节点包装成 Node，如果等待队列的 firstWaiter 为 null 的话（等待队列为空队列），则将 firstWaiter 指向当前的 Node, 否则，更新 lastWaiter (尾节点) 即可。就是通过尾插入的方式将当前线程封装的 Node 插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习 AQS 时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待对列之后，会使当前线程释放 lock，由 fullyRelease 方法实现，fullyRelease 源码为：</span><br></pre></td></tr></table></figure><p>final int fullyRelease(Node node) {<br>    boolean failed = true;<br>    try {<br>        int savedState = getState();<br>        if (release(savedState)) {<br>            //成功释放同步状态<br>            failed = false;<br>            return savedState;<br>        } else {<br>            //不成功释放同步状态抛出异常<br>            throw new IllegalMonitorStateException();<br>        }<br>    } finally {<br>        if (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这段代码就很容易理解了，调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从 await 方法退出？现在回过头再来看 await 方法有这样一段逻辑：</span><br></pre></td></tr></table></figure><p>while (!isOnSyncQueue(node)) {<br>    // 3. 当前线程进入到等待状态<br>    LockSupport.park(this);<br>    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>        break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">很显然，当线程第一次调用 condition.await () 方法时，会进入到这个 while () 循环中，然后通过 LockSupport.park (this) 方法使得当前线程进入等待状态，那么要想退出这个 await 方法第一个前提条件自然而然的是要先退出这个 while 循环，出口就只剩下两个地方：1. 逻辑走到 break 退出 while 循环；2. while 循环中的逻辑判断为 false。再看代码出现第 1 种情况的条件是当前等待的线程被中断后代码会走到 break 退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的 condition 的 signal 或者 signalAll 方法），while 中逻辑判断为 false 后结束 while 循环。总结下，就是 当前线程被中断或者调用 condition.signal/condition.signalAll 方法当前节点移动到了同步队列后 ，这是当前线程退出 await 方法的前提条件。当退出 while 循环后就会调用 acquireQueued(node, savedState)，这个方法在介绍 AQS 的底层实现时说过了，若感兴趣的话可以去看这篇文章，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到 lock）。这样也说明了退出 await 方法必须是已经获得了 condition 引用（关联）的 lock。到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对 await 方法的理解加深。await 方法示意图如下图：</span><br><span class="line">![](Java并发之多线程间通信/aaa.png)</span><br><span class="line">如图，调用 condition.await 方法的线程必须是已经获得了 lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的 Node 尾插入到等待队列中。</span><br><span class="line"></span><br><span class="line">+ 超时机制的支持</span><br><span class="line"></span><br><span class="line">condition 还额外支持了超时机制，使用者可调用方法 awaitNanos,awaitUtil。这两个方法的实现原理，基本上与 AQS 中的 tryAcquire 方法如出一辙.</span><br><span class="line"></span><br><span class="line">+ 不响应中断的支持</span><br><span class="line"></span><br><span class="line">要想不响应中断可以调用 condition.awaitUninterruptibly () 方法，该方法的源码为：</span><br></pre></td></tr></table></figure><p>public final void awaitUninterruptibly() {<br>    Node node = addConditionWaiter();<br>    int savedState = fullyRelease(node);<br>    boolean interrupted = false;<br>    while (!isOnSyncQueue(node)) {<br>        LockSupport.park(this);<br>        if (Thread.interrupted())<br>            interrupted = true;<br>    }<br>    if (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这段方法与上面的 await 方法基本一致，只不过减少了对中断的处理，并省略了 reportInterruptAfterWait 方法抛被中断的异常。</span><br><span class="line"></span><br><span class="line">#### signal/signalAll 实现原理</span><br><span class="line">调用 condition 的 signal 或者 signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得 lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal 方法源码为：</span><br></pre></td></tr></table></figure><p>public final void signal() {<br>    //1. 先检测当前线程是否已经获取lock<br>    if (!isHeldExclusively())<br>        throw new IllegalMonitorStateException();<br>    //2. 获取等待队列中第一个节点，之后的操作都是针对这个节点<br>    Node first = firstWaiter;<br>    if (first != null)<br>        doSignal(first);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal 方法首先会检测当前线程是否已经获取 lock，如果没有获取 lock 会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的 doSignal 方法也是基于该节点。下面我们来看看 doSignal 方法做了些什么事情，doSignal 方法源码为：</span><br></pre></td></tr></table></figure><p>private void doSignal(Node first) {<br>    do {<br>        if ( (firstWaiter = first.nextWaiter) == null)<br>            lastWaiter = null;<br>        //1. 将头结点从等待队列中移除<br>        first.nextWaiter = null;<br>        //2. while中transferForSignal方法对头结点做真正的处理<br>    } while (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != null);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体逻辑请看注释，真正对头节点做处理的逻辑在 transferForSignal 放，该方法源码为：</span><br></pre></td></tr></table></figure><p>final boolean transferForSignal(Node node) {<br>    /*<br>     * If cannot change waitStatus, the node has been cancelled.<br>     */<br>    //1. 更新状态为0<br>    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))<br>        return false;</p><pre><code>/* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). *///2.将该节点移入到同步队列中去Node p = enq(node);int ws = p.waitStatus;if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))    LockSupport.unpark(node.thread);return true;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键逻辑请看注释，这段代码主要做了两件事情 1. 将头结点的状态更改为 CONDITION；2. 调用 enq 方法，将该节点尾插入到同步队列中，关于 enq 方法请看 AQS 的底层实现这篇文章。现在我们可以得出结论：调用 condition 的 signal 的前提条件是当前线程已经获取了 lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从 await 方法中的 LockSupport.park (this) 方法中返回，从而才有机会使得调用 await 方法的线程成功退出。signal 执行示意图如下图：</span><br><span class="line">![](Java并发之多线程间通信/bbb.png)</span><br><span class="line">sigllAll 与 sigal 方法的区别体现在 doSignalAll 方法上，前面我们已经知道 doSignal 方法只会对等待队列的头节点进行操作，，而 doSignalAll 的源码为：</span><br></pre></td></tr></table></figure><p>private void doSignalAll(Node first) {<br>    lastWaiter = firstWaiter = null;<br>    do {<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = null;<br>        transferForSignal(first);<br>        first = next;<br>    } while (first != null);<br>}</p><pre><code>该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即 “通知” 当前调用 condition.await ()方法的每一个线程。[参考链接]https://www.cnblogs.com/tiancai/p/9371655.html[参考链接]https://www.artima.com/insidejvm/ed2/threadsynch.html[参考链接]https://time.geekbang.org/column/article/85241[参考链接]https://www.cnblogs.com/xdyixia/p/9386133.html[参考链接]https://www.cnblogs.com/Wanted-Tao/p/6378942.html[参考链接]https://juejin.im/post/5aeea5e951882506a36c67f0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中线程通信协作的最常见的两种方式：&lt;br&gt;一.syncrhoized 加锁的线程的 Object 类的 wait ()/notify ()/notifyAll ()&lt;br&gt;二.ReentrantLock 类加锁的线程的 Condition 类的 await()/signal()/signalAll()&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程通信" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之内存模型和happens-before规则</title>
    <link href="http://yoursite.com/2019/09/29/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/09/29/java多线程之内存模型和happens-before规则/</id>
    <published>2019-09-29T10:28:24.000Z</published>
    <updated>2019-09-30T06:50:19.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。</p><a id="more"></a><p>JMM 是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的。</p><p>JMM 是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。</p><p>Java 内存模型把 Java 虚拟机内部划分为线程栈和堆。</p><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>每一个运行在 Java 虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p><p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆上包含在 Java 程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p><p>一个本地变量可能是原始类型，在这种情况下，它总是在线程栈上。 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。 静态成员变量跟随着类定义一起也存放在堆上。 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="/2019/09/29/java多线程之内存模型和happens-before规则/1556440274529751.jpg" alt></p><h3 id="多线程可见性"><a href="#多线程可见性" class="headerlink" title="多线程可见性"></a>多线程可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其它线程能够适时得知这个修改。在单线程环境中，如果在程序前面修改了某个变量的值，后面的程序一定会读取到那个变量的新值。这看起来很自然，然而当变量的写操作和读操作在不同的线程中时，情况却并非如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *《Java并发编程实战》27页程序清单3-1</span><br><span class="line"> */</span><br><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready; </span><br><span class="line">    private static int number;</span><br><span class="line">    </span><br><span class="line">    private static class ReaderThread extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ReaderThread().start(); //启动一个线程</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，主线程和读线程都访问共享变量 ready 和 number。程序看起来会输出 42（输出42是正常思维，就是number和ready被复制之后没一会就将值更新到了主内存，更新到主内存之后，等其他线程到主内存中读取值的时候就可以看到修改后的值），但事实上很可能会输出 0，或者根本无法终止。这是因为上面的程序缺少线程间变量可见性的保证，所以在主线程中写入的变量值，可能无法被读线程感知到。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作 Happens-Before 书写在后面的代码操作。这时因为 Java 语言规范要求 JVM 在单个线程内部要维护类似严格串行的语义，如果多个操作之间有<strong><em>先后依赖关系</em></strong>，则不允许对这些操作进行重排序。</p><h3 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h3><p>对锁 M 解锁之前的所有操作 Happens-Before 对锁 M 加锁之后的所有操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class HappensBeforeLock &#123;</span><br><span class="line">    private int value = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，setValue 和 getValue 两个方法共享同一个监视器锁。假设 setValue 方法在线程 A 中执行，getValue 方法在线程 B 中执行。setValue 方法会先对 value 变量赋值，然后释放锁。getValue 方法会先获取到同一个锁后，再读取 value 的值。所以根据锁定原则，线程 A 中对 value 变量的修改，可以被线程 B 感知到。<br>如果这个两个方法上没有 synchronized 声明，则在线程 A 中执行 setValue 方法对 value 赋值后，线程 B 中 getValue 方法返回的 value 值并不能保证是最新值。<br>本条锁定规则对显示锁 (ReentrantLock) 和内置锁 (synchronized) 在加锁和解锁等操作上有着相同的内存语义。<br>对于锁定原则，可以像下面这样去理解：同一时刻只能有一个线程执行锁中的操作，所以锁中的操作被重排序外界是不关心的，只要最终结果能被外界感知到就好。除了重排序，剩下影响变量可见性的就是 CPU 缓存了。在锁被释放时，A 线程会把释放锁之前所有的操作结果同步到主内存中，而在获取锁时，B 线程会使自己 CPU 的缓存失效，重新从主内存中读取变量的值。这样，A 线程中的操作结果就会被 B 线程感知到了。</p><h3 id="传递性规则"><a href="#传递性规则" class="headerlink" title="传递性规则"></a>传递性规则</h3><p>如果操作 A Happens-Before B，B Happens-Before C，那么可以得出操作 A Happens-Before C。</p><h3 id="volatile-变量规则"><a href="#volatile-变量规则" class="headerlink" title="volatile 变量规则"></a>volatile 变量规则</h3><blockquote><p>对一个 volatile 变量的写操作及这个写操作之前的所有操作 Happens-Before 对这个变量的读操作及这个读操作之后的所有操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line">char[] configText; //线程间共享变量，用于保存配置信息</span><br><span class="line">// 此变量必须定义为volatile</span><br><span class="line">volatile boolean initialized = false;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程A中执行</span><br><span class="line">// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程B中执行</span><br><span class="line">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span><br><span class="line">while (!initialized) &#123;    </span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">//使用线程A中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>上面这段代码，读取配置文件的操作和使用配置信息的操作分别在两个不同的线程 A、B 中执行，两个线程通过共享变量 configOptions 传递配置信息，并通过共享变量 initialized 作为初始化是否完成的通知。initialized 变量被声明为 volatile 类型的，根据 volatile 变量规则，volatile 变量的写入操作 Happens-Before 对这个变量的读操作，所以在线程 A 中将变量 initialized 设为 true，线程 B 中是可以感知到这个修改操作的。<br>但是更牛逼的是，volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作对其它线程的可见性。考虑这样一种情况，如果 volatile 变量仅能保证自己的变量可见性，那么当线程 B 感知到 initialized 已经变成 true 然后执行 doSomethingWithConfig 操作时，可能无法获取到 configOptions 最新值而导致操作结果错误。所以 volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作 Happens-Before 书写在 volatile 变量读操作之后的那些操作。<br>可以这样理解 volatile 变量的写入和读取操作流程：<br>首先，volatile 变量的操作会禁止与其它普通变量的操作进行重排序，例如上面代码中会禁止 initialized = true 与它上面的两行代码进行重排序 (但是它上面的代码之间是可以重排序的)，否则会导致程序结果错误。volatile 变量的写操作就像是一条基准线，到达这条线之后，不管之前的代码有没有重排序，反正到达这条线之后，前面的操作都已完成并生成好结果。<br>然后，在 volatile 变量写操作发生后，A 线程会把 volatile 变量本身和书写在它之前的那些操作的执行结果一起同步到主内存中。<br>最后，当 B 线程读取 volatile 变量时，B 线程会使自己的 CPU 缓存失效，重新从主内存读取所需变量的值，这样无论是 volatile 本身，还是书写在 volatile 变量写操作之前的那些操作结果，都能让 B 线程感知到，也就是上面程序中的 initialized 和 configOptions 变量的最新值都可以让线程 B 感知到。<br>原子变量与 volatile 变量在读操作和写操作上有着相同的语义。</p><h3 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h3><p>Thread 对象的 start 方法及书写在 start 方法前面的代码操作 Happens-Before 此线程的每一个动作。<br>start 方法和新线程中的动作一定是在两个不同的线程中执行。线程启动规则可以这样去理解：调用 start 方法时，会将 start 方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在 start 方法调用之前的所有操作结果对于新创建的线程都是可见的。</p><h3 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h3><p>线程中的任何操作都 Happens-Before 其它线程检测到该线程已经结束。这个说法有些抽象，下面举例子对其进行说明。<br>假设两个线程 s、t。在线程 s 中调用 t.join () 方法。则线程 s 会被挂起，等待 t 线程运行结束才能恢复执行。当 t.join () 成功返回时，s 线程就知道 t 线程已经结束了。所以根据本条原则，在 t 线程中对共享变量的修改，对 s 线程都是可见的。类似的还有 Thread.isAlive 方法也可以检测到一个线程是否结束。<br>可以猜测，当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程 A 对共享变量的修改，对于其它检测了 A 线程是否结束的线程是可见的。</p><h3 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h3><p>一个线程在另一个线程上调用 interrupt,Happens-Before 被中断线程检测到 interrupt 被调用。<br>假设两个线程 A 和 B，A 先做了一些操作 operationA，然后调用 B 线程的 interrupt 方法。当 B 线程感知到自己的中断标识被设置时 (通过抛出 InterruptedException，或调用 interrupted 和 isInterrupted),operationA 中的操作结果对 B 都是可见的。</p><p>[参考链接]<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011458941</a><br>[参考链接]<a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="noopener">http://ifeve.com/java-memory-model-6/</a><br>[参考链接]<a href="http://ifeve.com/memory-model/" target="_blank" rel="noopener">http://ifeve.com/memory-model/</a><br>[参考链接]<a href="http://ifeve.com/from-singleton-happens-before/" target="_blank" rel="noopener">http://ifeve.com/from-singleton-happens-before/</a><br>[参考链接]<a href="http://blog.itpub.net/69917606/viewspace-2642808/" target="_blank" rel="noopener">http://blog.itpub.net/69917606/viewspace-2642808/</a><br>[参考链接]<a href="https://www.jianshu.com/p/4455e4234d5c" target="_blank" rel="noopener">https://www.jianshu.com/p/4455e4234d5c</a><br>[参考链接]<a href="https://www.jianshu.com/p/15106e9c4bf3" target="_blank" rel="noopener">https://www.jianshu.com/p/15106e9c4bf3</a><br>参考书籍《Java并发编程艺术》第三章，《Java并发编程实战》第三章，第十六章，《深入理解Java内存模型》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h3&gt;&lt;p&gt;JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-内存模型、happens-before规则" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81happens-before%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之CAS</title>
    <link href="http://yoursite.com/2019/09/28/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCAS/"/>
    <id>http://yoursite.com/2019/09/28/java多线程之CAS/</id>
    <published>2019-09-28T10:28:24.000Z</published>
    <updated>2019-10-09T02:47:51.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS概念"><a href="#CAS概念" class="headerlink" title="CAS概念"></a>CAS概念</h3><p>CAS 是英文单词 CompareAndSwap 的缩写，中文意思是：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。<br>CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就什么都不做。整个比较并替换的操作是一个原子操作。<br>CAS 有效地说明了 “我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”<br><strong>在多线程的情况下，当多个线程同时使用 CAS 操作一个变量时，只有一个会成功并更新值，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试。正是基于这样的原理，CAS 即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。可见 CAS 其实是一个乐观锁。</strong></p><a id="more"></a><h3 id="CAS算法在Java中的作用"><a href="#CAS算法在Java中的作用" class="headerlink" title="CAS算法在Java中的作用"></a>CAS算法在Java中的作用</h3><p>在 JDK 5 之前 Java 语言是靠 synchronized 关键字保证同步的，这会导致有锁。<br>锁机制存在以下问题：<br>1.在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>2.一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>3.如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile 是不错的机制，但是 volatile 不能保证原子性。因此对于同步最终还是要回到锁机制上来。<br>独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>学过synchronized关键字之后，我们可以保证i++操作是原子操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increase()&#123;</span><br><span class="line">    race++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种自增操作每次都会加锁，性能可能会稍微差点。<br>比较好一点的方案是使用Java并发包原子操作类（Atomic开头），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static AtomicInteger race = new AtomicInteger(0);</span><br><span class="line">public static void increase()&#123;</span><br><span class="line">    //race++; 非原子操作，取值，加1，写值</span><br><span class="line">    race.getAndIncrement()//原子操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndIncrement 方法调用 getAndAddInt 方法，最后调用的是 compareAndSwapInt 方法，即本文的主角 CAS，接下来我们开始介绍 CAS（终于开始说CAS了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the previous value</span><br><span class="line"> */</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndAddInt 方法解析：拿到内存位置的最新值 v，使用 CAS 尝试修将内存位置的值修改为目标值 v+delta，如果修改失败，则获取该内存位置的新值 v，然后继续尝试，直至修改成功。</p><h3 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h3><p>简单讲一下这个类。Java 无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个类 Unsafe，它提供了硬件级别的原子操作。<br>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。<br>从第一行的描述可以了解到 Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native long staticFieldOffset(Field paramField);</span><br></pre></td></tr></table></figure><p>这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。</p><h3 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h3><ul><li>CAS 虽然很高效的解决原子操作，但是 CAS 仍然存在三大问题：</li></ul><p>1.ABA 问题。因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B-3A。</p><p>从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>2.循环时间长开销大。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）, 使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</p><p>3.只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i＝2,j=a，合并一下 ij=2a，然后用 CAS 来操作 ij。从 Java1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p><h3 id="什么是-ABA-问题？ABA-问题怎么解决？"><a href="#什么是-ABA-问题？ABA-问题怎么解决？" class="headerlink" title="什么是 ABA 问题？ABA 问题怎么解决？"></a>什么是 ABA 问题？ABA 问题怎么解决？</h3><p>如果在这段期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA” 问题。Java 并发包为了解决这个问题，提供了一个带有标记的原子引用类 “AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。因此，在使用 CAS 前要考虑清楚 “ABA” 问题是否会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><p>[参考链接]<a href="https://blog.csdn.net/weixin_37598682/article/details/81285176" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37598682/article/details/81285176</a><br>[参考链接]<a href="https://blog.csdn.net/v123411739/article/details/79561458" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458</a><br>[参考链接]<a href="https://blog.csdn.net/fuzhongmin05/article/details/91400317" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/91400317</a><br>[参考链接]<a href="https://blog.csdn.net/zhoutaopower/article/details/86598839" target="_blank" rel="noopener">https://blog.csdn.net/zhoutaopower/article/details/86598839</a><br>[参考链接]<a href="https://www.jianshu.com/p/f0d6e7103d9b" target="_blank" rel="noopener">https://www.jianshu.com/p/f0d6e7103d9b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CAS概念&quot;&gt;&lt;a href=&quot;#CAS概念&quot; class=&quot;headerlink&quot; title=&quot;CAS概念&quot;&gt;&lt;/a&gt;CAS概念&lt;/h3&gt;&lt;p&gt;CAS 是英文单词 CompareAndSwap 的缩写，中文意思是：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。&lt;br&gt;CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就什么都不做。整个比较并替换的操作是一个原子操作。&lt;br&gt;CAS 有效地说明了 “我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”&lt;br&gt;&lt;strong&gt;在多线程的情况下，当多个线程同时使用 CAS 操作一个变量时，只有一个会成功并更新值，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试。正是基于这样的原理，CAS 即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。可见 CAS 其实是一个乐观锁。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-CAS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之AQS</title>
    <link href="http://yoursite.com/2019/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/09/27/Java多线程之AQS/</id>
    <published>2019-09-27T10:28:24.000Z</published>
    <updated>2019-10-09T09:05:50.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS概念"><a href="#AQS概念" class="headerlink" title="AQS概念"></a>AQS概念</h3><p>AQS是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。</p><a id="more"></a><h3 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h3><p>先来看看 AQS (即AbstractQueuedSynchronizer )有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="line">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，之后分析过程中所说的 queue，也就是<strong><em>阻塞队列不包含 head</em></strong><br><img src="/2019/09/27/Java多线程之AQS/aqs.png" alt></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class Node &#123;</span><br><span class="line">    // 标识节点当前在共享模式下</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标识节点当前在独占模式下</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // ======== 下面的几个int常量是给waitStatus用的 ===========</span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    // 代表此线程取消了争抢这个锁</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    // 不分析，略过吧</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    // =====================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br><span class="line">    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br><span class="line">    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    // 前驱节点的引用</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    // 后继节点的引用</span><br><span class="line">    volatile Node next;</span><br><span class="line">    // 这个就是线程本尊</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已（而已只是说说，其实真难&lt;我觉得&gt;）</p><p>我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。<br><img src="/2019/09/27/Java多线程之AQS/aqs-1.png" alt></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ReentrantLock reentrantLock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line">      // 争锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br><span class="line">    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br><span class="line">    // 否则，acquireQueued方法会将线程压到队列中</span><br><span class="line">    public final void acquire(int arg) &#123; // 此时 arg == 1</span><br><span class="line">        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">        // 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br><span class="line">        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br><span class="line">    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        // state == 0 此时此刻没有线程持有锁</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br><span class="line">            // 看看有没有别人在队列中等了半天了</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br><span class="line">                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br><span class="line">                // 因为刚刚还没人的，我判断过了</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br><span class="line">        // 这里不存在并发问题</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br><span class="line">        // 回到上面一个外层调用方法继续看:</span><br><span class="line">        // if (!tryAcquire(arg) </span><br><span class="line">        //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">        //     selfInterrupt();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br><span class="line">      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br><span class="line">    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates and enqueues node for current thread and given mode.</span><br><span class="line">     *</span><br><span class="line">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line">     * @return the new node</span><br><span class="line">     */</span><br><span class="line">    // 此方法的作用是把线程包装成node，同时进入到队列中</span><br><span class="line">    // 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br><span class="line">        if (pred != null) &#123; </span><br><span class="line">            // 将当前的队尾节点，设置为自己的前驱 </span><br><span class="line">            node.prev = pred; </span><br><span class="line">            // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br><span class="line">                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br><span class="line">                pred.next = node;</span><br><span class="line">                // 线程入队了，可以返回了</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仔细看看上面的代码，如果会到这里，</span><br><span class="line">        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br><span class="line">        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line">     * @param node the node to insert</span><br><span class="line">     * @return node&apos;s predecessor</span><br><span class="line">     */</span><br><span class="line">    // 采用自旋的方式入队</span><br><span class="line">    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br><span class="line">    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br><span class="line">    private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 之前说过，队列为空也会进来这里</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                // 初始化head节点</span><br><span class="line">                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br><span class="line">                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br><span class="line"></span><br><span class="line">                    // 这个时候有了head，但是tail还是null，设置一下，</span><br><span class="line">                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br><span class="line">                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br><span class="line">                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下面几行，和上一个方法 addWaiter 是一样的，</span><br><span class="line">                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 现在，又回到这段代码了</span><br><span class="line">    // if (!tryAcquire(arg) </span><br><span class="line">    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">    //     selfInterrupt();</span><br><span class="line"></span><br><span class="line">    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br><span class="line">    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br><span class="line">    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br><span class="line">    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br><span class="line">                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br><span class="line">                // 所以当前节点可以去试抢一下锁</span><br><span class="line">                // 这里我们说一下，为什么可以去试试：</span><br><span class="line">                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br><span class="line">                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br><span class="line">                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br><span class="line">                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br><span class="line">                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 什么时候 failed 会为 true???</span><br><span class="line">            // tryAcquire() 方法抛异常的情况</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Checks and updates status for a node that failed to acquire.</span><br><span class="line">     * Returns true if thread should block. This is the main signal</span><br><span class="line">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="line">     *</span><br><span class="line">     * @param pred node&apos;s predecessor holding status</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @return &#123;@code true&#125; if thread should block</span><br><span class="line">     */</span><br><span class="line">    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br><span class="line">    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br><span class="line">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br><span class="line">        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br><span class="line">        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br><span class="line">        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br><span class="line">        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            // 仔细想想，如果进入到这个分支意味着什么</span><br><span class="line">            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br><span class="line">            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br><span class="line">            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br><span class="line">            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个方法返回 false，那么会再走一次 for 循序，</span><br><span class="line">        //     然后再次进来此方法，此时会从第一个分支返回 true</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br><span class="line">    // 这个方法结束根据返回值我们简单分析下：</span><br><span class="line">    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br><span class="line">    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br><span class="line">    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br><span class="line"></span><br><span class="line">    // 跳回到前面是这个方法</span><br><span class="line">    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    //                parkAndCheckInterrupt())</span><br><span class="line">    //                interrupted = true;</span><br><span class="line"></span><br><span class="line">    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br><span class="line">    // 那么需要执行parkAndCheckInterrupt():</span><br><span class="line"></span><br><span class="line">    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br><span class="line">    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br><span class="line">    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br><span class="line"></span><br><span class="line">   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br><span class="line"></span><br><span class="line">    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br><span class="line">    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h3><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 往后看吧</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到ReentrantLock看tryRelease方法</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放锁</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wakes up node&apos;s successor, if one exists.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">// 唤醒后继节点</span><br><span class="line">// 从上面调用处知道，参数node是head头结点</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br><span class="line">    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 刚刚线程被挂起在这里了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><p>1.锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state 进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock () 和 unlock () 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。<br>2.线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park (thread) 来挂起线程，用 unpark 来唤醒线程。<br>3.阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于 CLH 的介绍，写得简单明了。</p><h3 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h3><p>下面属于回顾环节，用简单的示例来说一遍。</p><p>首先，第一个线程调用 reentrantLock.lock ()，翻到最前面可以发现，tryAcquire (1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock () 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock () 之前，线程 2 调用了 lock (), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node ()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0<br><img src="/2019/09/27/Java多线程之AQS/aqs-2.png" alt><br>然后线程 2 入队：<br><img src="/2019/09/27/Java多线程之AQS/aqs-3.png" alt><br>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的 waitStatus 设置为 -1。<br>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；<br>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。<br><img src="/2019/09/27/Java多线程之AQS/aqs-4.png" alt><br>这里可以简单说下 waitStatus 中 SIGNAL (-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus 代表后继节点的状态” 这种思路去看一遍源码。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="line"> */</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：公平锁和非公平锁只有两处不同：</p></blockquote><p>1.非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>2.非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。<br>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p>[主要参考&lt;说句不要脸的话就是我抄人家的，不过人家写的是真好，其他博客也值得一看&gt;]<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a><br>[参考链接]<a href="https://www.cnblogs.com/xll1025/p/11335107.html" target="_blank" rel="noopener">https://www.cnblogs.com/xll1025/p/11335107.html</a><br>[参考链接-模板模式]<a href="https://www.jianshu.com/p/f44c6380f52b" target="_blank" rel="noopener">https://www.jianshu.com/p/f44c6380f52b</a><br>[参考链接-模板模式]<a href="https://www.cnblogs.com/qq-361807535/p/6854191.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq-361807535/p/6854191.html</a><br>[写这个链接主要是因为写的还不错]<a href="https://www.codercto.com/a/41447.html" target="_blank" rel="noopener">https://www.codercto.com/a/41447.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AQS概念&quot;&gt;&lt;a href=&quot;#AQS概念&quot; class=&quot;headerlink&quot; title=&quot;AQS概念&quot;&gt;&lt;/a&gt;AQS概念&lt;/h3&gt;&lt;p&gt;AQS是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-AQS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
    
  </entry>
  
</feed>
