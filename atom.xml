<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-25T01:52:09.873Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员英语</title>
    <link href="http://yoursite.com/2020/05/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/"/>
    <id>http://yoursite.com/2020/05/24/程序员英语/</id>
    <published>2020-05-24T11:57:10.000Z</published>
    <updated>2020-05-25T01:52:09.873Z</updated>
    
    <content type="html"><![CDATA[<p>contents<br>prevVolume<br>Sub<br>Invalid<br>calculate<br>Failed<br>claas<br>Prefix<br>Index<br>good<br>lite<br>export<br>Volume<br>WithDetailsException<br>Fair<br>Add<br>compiled<br>Configuration<br>This<br>Fair<br>suitable<br>illegal<br>License<br>focus<br>Traceback<br>Organization<br>org.apache.hadoop.hbase.DoNotRetryIOException:<br>omitted<br>cheat<br>find<br>constraint<br>reign<br>Duplicated<br>previous<br>swap<br>SpiritSoft<br>cause<br>Cronos<br>fetchMetadata:<br>prev<br>merge<br>This<br>element<br>Lists<br>fixes<br>Storage<br>Error<br>Nov<br>Service<br>early<br>Error<br>Required<br>priority<br>Provided<br>smart<br>theme<br>Returns<br>The<br>chat<br>quick<br>ObjectStore#listVolumesByUser<br>java.sql.SQLException:<br>park<br>his<br>attaching<br>Design<br>trim<br>操作<br>While<br>租户<br>omitted<br>relative<br>Jul<br>staff<br>Caused<br>hold<br>Removed<br>drill<br>reentrantlock<br>omitted<br>delimited<br>Goal<br>exhausted<br>all<br>Currently<br>Unnecessary<br>If<br>already<br>Exclusive<br>dry<br>Service<br>Copyright<br>fulfil<br>Implementation<br>spawn<br>String<br>Notifications<br>Categories<br>Array<br>Offload<br>ANTLR<br>folders<br>All<br>conflict<br>defer<br>good<br>tenement<br>hints<br>Volumes<br>interceptor<br>foundation<br>timeout<br>drainTo<br>Untracked<br>Incompatible<br>ExhaustedWithDetailsException<br>Base<br>call<br>async<br>Copyright<br>CodisLabs<br>quota<br>absent<br>merchant<br>retries<br>folded<br>Maximum<br>federation<br>annotation<br>through<br>Duplicated<br>Leaving<br>error:<br>Carlier<br>label<br>visited<br>joker<br>accessed<br>IllegalAccess<br>TREEIFY<br>volumes<br>Full<br>logic<br>line<br>coursera<br>dequeue<br>calculateSize<br>Please<br>Descripto<br>getTenantId()<br>When<br>entered<br>Duplicated<br>SpiritSoft<br>Returns<br>ant<br>unnecessary<br>RetriesExhaustedWithDetailsException<br>remainder<br>leetcode-cn<br>claas<br>Pochmann<br>Copyright<br>invalisd<br>操作中不包含上传下载<br>Coursera<br>Lists<br>leetcode-cn<br>Melancholy<br>serviceType<br>abnormally<br>Maximum<br>Annotationsare<br>redundant<br>Oracle<br>Required<br>Quota<br>Error<br>Configuration<br>Size<br>public<br>explicit<br>Size<br>aym<br>Race<br>Annotations<br>Invalid<br>section<br>Timestamp<br>percentage<br>String<br>Red<br>Copyright<br>visible<br>transfer<br>Data<br>Medium<br>It<br>decompression<br>one<br>fix<br>untracked<br>proxy<br>delay<br>Currently<br>Framework<br>IntelliJ<br>Returns<br>large<br>tracking<br>Xiaoyu<br>Returns<br>sign<br>authored<br>Fair<br>drill<br>metadata<br>aNode:<br>starting<br>Only<br>prevVolume<br>terminator<br>one<br>volumePrefix<br>enqueue<br>repository<br>GLOBALS<br>review<br>inclusive<br>goal<br>Incompatible<br>columns<br>distribution<br>Volume<br>Creates<br>leaf<br>expect<br>call<br>Page<br>Authorize<br>call<br>Inc<br>recovery<br>Returns<br>omitted<br>Gets<br>object<br>accessible<br>Shutdown<br>truncated<br>IllegalAccessError<br>replicated<br>discuss<br>BaseContextHandler<br>This<br>enumeration<br>set<br>passing<br>chunkSize<br>multiple<br>undeclared<br>genericwildcard<br>remix<br>recursive<br>relaunch<br>avail<br>SafeModePrecheck<br>With<br>Deprecated<br>IllegalAcc<br>Gets<br>fatal:<br>automatic<br>Subcommand<br>iterable<br>Lombok<br>Block<br>gener<br>unindent<br>Run<br>renderer<br>found<br>desired<br>Sets<br>Allows<br>creation<br>Searched<br>initiate<br>Demons<br>ozone<br>generic<br>fully<br>Removedundeclared<br>jcenter<br>ceiver<br>set<br>survive<br>unpacking<br>system<br>memoized<br>Receiving<br>Ozone<br>recon<br>bucket<br>right<br>correctly<br>company<br>memoizedIsInitialized<br>qualified<br>collaborator<br>supplier<br>nodeAddress=172.16.13.168:1234<br>trash<br>background<br>oriented<br>treeify<br>commit<br>reflect<br>above<br>Deprecated<br>semaphore<br>as<br>futrue<br>mismatch<br>freon<br>modification<br>use<br>Branch<br>freon<br>actionable<br>multiple<br>ListKeysRequest<br>Block<br>Description<br>Protobuf<br>set<br>anonymous<br>threshold<br>FileEncryptionInfo<br>cleaner<br>Developer<br>chunk<br>checksum<br>track<br>lookup<br>lifecucle<br>attachments<br>failures<br>Pruning<br>Audit<br>post<br>generated<br>bycode<br>Ozone<br>movie<br>rights<br>prototype<br>remove<br>took<br>original<br>declared<br>suggested<br>The<br>fully<br>completed<br>Details<br>NativeCodeLoader:60<br>generify<br>BigDecimal<br>Gets<br>qualified<br>encryption<br>repeated<br>Decom<br>leaving<br>@Command<br>description<br>resolving<br>usage<br>Collaborator<br>criteria<br>usage<br>Module<br>Disable<br>leaving<br>enabled<br>receiving<br>Constructor<br>fully<br>EncryptionInfo<br>completed<br>Scheduled<br>Replication<br>contribute<br>IllegalAc<br>invalid<br>Gets<br>designed<br>deltas<br>original<br>group<br>gank<br>replicated<br>charge<br>programming<br>maven{<br>specification<br>UnsatisfiedDependencyException<br>set<br>library<br>freon<br>snapshots<br>auto<br>author<br>recover<br>wheel<br>Removed<br>delta<br>leaving<br>expiry<br>conditions<br>Checkavailsum<br>rights<br>intern<br>closer<br>List<br>demons<br>Gets<br>xceiver<br>Found<br>location<br>fatal<br>Unchecked<br>Process<br>CurrentlyIn<br>invocation<br>exact<br>untreeify<br>Central<br>What<br>wildcard<br>ContextHandler<br>revea<br>decompiled<br>algorithm<br>cloud<br>Blank<br>renew<br>erase<br>Datagram<br>bind<br>reserved<br>spawned<br>parsing<br>pars<br>cannot<br>multipart<br>peer<br>Broken<br>truncation<br>Pending<br>Caught<br>With<br>vantage<br>cheap<br>mon<br>detection<br>status<br>disabled<br>disables<br>automatically<br>succeed<br>alert<br>redirect<br>grep<br>recursive<br>firefly<br>price<br>straightforward<br>args<br>components<br>ware<br>default<br>rollback<br>switch<br>timestamp<br>info<br>ultima<br>ultimately<br>destination<br>source<br>uploads<br>download<br>overflow<br>stack<br>isBlank<br>revert<br>equal<br>Instruction<br>mutable<br>depiction<br>write<br>down<br>incorrectly<br>Key<br>stars<br>matched<br>caution<br>occupied<br>service<br>client<br>Balancer<br>parcel<br>clouder<br>cloudier<br>context<br>case<br>rawtypes<br>were<br>Multiple<br>tail<br>RpcLite<br>typedef<br>plan<br>fail<br>FEMALE<br>MALE<br>HEAD<br>director<br>assignment<br>acquire<br>multiple<br>STOPPING<br>convert<br>combined<br>aggregation<br>Invalid<br>triggers<br>instance<br>fired<br>checkin<br>cron<br>quartz<br>wrong<br>fragment<br>way<br>inverted<br>enablement<br>Disallow<br>customize<br>lapping<br>Over<br>luckin<br>Trigger<br>base<br>Exhausted<br>Retries<br>metric<br>magic<br>mid<br>SIMPLE<br>previous<br>show<br>show<br>Aggregate<br>all<br>match<br>remind<br>occurred<br>diagrams<br>global<br>instantiate<br>preserve<br>EAGER<br>serial<br>gateway<br>Invocation<br>warn<br>invokeAll<br>discretion<br>flink<br>compute<br>Stream<br>availability<br>Frame<br>exactly-once<br>stract<br>Graph<br>primitive<br>performance<br>concern<br>rank<br>null<br>dereference<br>dead<br>internationalization<br>dodgy<br>bread<br>timezone<br>wding<br>instantf<br>tags<br>unbenannt<br>startseite<br>archiv<br>farewell<br>Manifest<br>Memtable<br>compile<br>warehourse<br>warehours<br>snappy<br>auth<br>stealing<br>fork<br>Schedual<br>call<br>abort<br>Vertex<br>Dispatcher<br>clusters<br>cluster<br>useless<br>Vulnerability<br>processors<br>such<br>assertion<br>sigar<br>Chat<br>Stats<br>Wrapper<br>compare<br>applet<br>Visible<br>Dashboard<br>billion<br>script<br>invite<br>MultiLine<br>majors<br>typo<br>retail<br>press<br>device<br>booting<br>booting<br>associated<br>Fetched<br>drop<br>recommend<br>during<br>injection<br>Sniper<br>hive<br>entire<br>whether<br>made<br>certain<br>calls<br>Readable<br>comments<br>validate<br>ordinal<br>reviation<br>EXECUTE<br>Place<br>Handle<br>Async<br>excluded<br>alias<br>countermand<br>inexecution<br>undo<br>Launching<br>Tracking<br>explain<br>expires<br>clause<br>blockers<br>enclosing<br>each<br>raises<br>tricky<br>Correctly<br>Scheduled<br>Duration<br>AtomicInteger<br>Reentrant<br>blocking<br>instanceof<br>commons<br>practice<br>Correctness<br>Cumulative<br>incremental<br>Coffees<br>Label<br>digits<br>decimal<br>catalog<br>concrete<br>aspect<br>Mirror<br>jan<br>Confidential<br>Prepared<br>credentials<br>collection<br>collection<br>terminated<br>extended<br>DUPLICATION<br>Dependency<br>instantiation<br>nested<br>through<br>expressed<br>Unsatisfied<br>privileges<br>orign<br>tenant<br>waterfall<br>split<br>Capacity<br>Statement<br>extract<br>hundred<br>Noncompliant<br>Forbidden<br>beaver<br>embedded<br>decr<br>TotalPage<br>paging<br>oldkey<br>ren<br>invalid<br>relly<br>flush<br>Sorted<br>subject<br>depth<br>EXPOT<br>thrift<br>explore<br>Appender<br>authorizer<br>prefixLength<br>normalize<br>existence<br>Completion<br>current<br>register<br>struct<br>Owner<br>Modifying<br>Valid<br>Transform<br>category<br>authority<br>Generator<br>Generic<br>processor<br>pick<br>already<br>Expiration<br>preserve<br>in-flight<br>capability<br>issue<br>Autowired<br>browser<br>unauthorized<br>raw<br>parameters<br>actual<br>defined<br>currently<br>requirement<br>argument<br>Oauth<br>Conflict<br>negative<br>heap<br>Common<br>rack<br>paradise<br>hook<br>future<br>coverage<br>the<br>trans<br>generator<br>missing<br>wrong<br>illegal<br>grant<br>comment<br>complete<br>keyboard<br>Minor<br>squid<br>smell<br>Critical<br>incl<br>nesting<br>rule<br>browse<br>search<br>serializer<br>Seek<br>Seeking<br>halt<br>require<br>interceptors<br>inherited<br>club<br>compaction<br>dispatch<br>reactor<br>Sequence<br>replay<br>patch<br>completion<br>forget<br>fire<br>fire<br>transport<br>dismiss<br>undeploy<br>external<br>faster<br>indicates<br>probably<br>Virtual<br>Constant<br>advanced<br>actors<br>abstract<br>repeat<br>revoked<br>progress<br>illegal<br>generation<br>coordination<br>cceeds<br>multi<br>coordinator<br>concat<br>greeting<br>Symbol<br>ident<br>provider<br>Permissions<br>Multicast<br>identifier<br>reassignment<br>Transformation<br>gmall<br>frontend<br>backend<br>notify<br>architecture<br>dubbo<br>submission<br>Distributed<br>most<br>related<br>features<br>performed<br>specific<br>exclude<br>facets<br>disable<br>remoting<br>Disposable<br>Phase<br>destroy<br>Lifecycle<br>yet<br>received<br>decompiler<br>lllegal<br>redial<br>dialed<br>subscriber<br>Foundry<br>Transactional<br>seq<br>Execution<br>exception<br>uncaught<br>Processor<br>Roaming<br>exactly<br>loop<br>samples<br>execution<br>Runner<br>Line<br>command<br>Enable<br>uppercamelcase<br>exchange<br>restTemplate<br>Bearer<br>Secret<br>Access<br>Platform<br>round-robin<br>retention<br>socket<br>sender<br>bound<br>trait<br>trade-off<br>initial<br>rebalancing<br>compacted<br>Usage<br>metrics<br>notification<br>identity<br>domain<br>domin<br>popedom<br>Module<br>token<br>EPHEMERAL<br>disconnect<br>Strict<br>Domain<br>Beeline<br>Efficiency<br>Bootstrap<br>Advanced<br>Mechanism<br>General<br>avro<br>radio<br>origin<br>index<br>run<br>drop<br>daemon<br>Damon<br>result<br>verify<br>constant<br>thyme<br>border<br>pencil<br>NEUTRAL<br>with<br>recall<br>lisence<br>assert<br>crash<br>condition<br>reverse<br>dialect<br>strategy<br>whitelabel<br>stretch<br>Extract<br>Target<br>artifact<br>provided<br>Repl<br>slots<br>assigned<br>epoch<br>notice<br>disconnected<br>afair<br>one<br>establish<br>clear<br>show<br>show<br>word<br>word<br>word<br>word<br>estalished<br>deflate<br>partial<br>Niubility<br>Mapper<br>aliases<br>guanxi<br>note<br>beat<br>Annotation<br>cover<br>seem<br>present<br>statemachine<br>sample<br>actuator<br>Template<br>Expect<br>perform<br>ignore<br>reference<br>under<br>suffix<br>Thymeleaf<br>scope<br>Generate<br>STACKTRACE<br>Communications<br>publish<br>reCall<br>Repository<br>Starters<br>print<br>talk<br>content<br>page<br>coming<br>additivity<br>metastore<br>pagination<br>NumberFormat<br>displayed<br>Number<br>edges<br>items<br>displaye<br>onclick<br>event<br>Compiling<br>undefined<br>Monitor<br>loader<br>SUSPEND<br>Alongside<br>Running<br>Scheduling<br>audit<br>rele<br>Structured<br>destory<br>Option<br>mangagement<br>mangage<br>dynamic<br>administer<br>storage<br>sto<br>processing<br>inside<br>routing<br>indeep<br>action<br>machine<br>installation<br>effective<br>periodically<br>way<br>durable<br>similar<br>capabilities<br>Introduction<br>Prior<br>releases<br>flat<br>serde<br>Released<br>connection<br>flight<br>full<br>replicas<br>insync<br>enable<br>election<br>unclean<br>random<br>compression<br>compress<br>datacommunication<br>communication<br>resolved<br>resol<br>resole<br>adver<br>tick<br>ensemble<br>legacy<br>Position<br>Bounds<br>riven<br>java<br>Unit<br>license<br>Reassignment<br>allowed<br>compiled<br>filtered<br>Detail<br>pairs<br>stable<br>Manual<br>idle<br>resume<br>pause<br>prompt<br>Sqoop<br>failover<br>Argument<br>Illegal<br>compact<br>major<br>mutex<br>volatitle<br>fight<br>interrupt<br>monitor<br>lifecycle<br>exit<br>Security<br>SecurityManager<br>allocates<br>handler<br>row<br>reject<br>take<br>que<br>blocked<br>limit<br>runnable<br>policy<br>task<br>protocol<br>configured<br>Ensure<br>AndEnsureOpen<br>acquireAndEnsureOpen<br>reflection<br>Eagle<br>cite<br>times<br>verdana<br>family<br>font-family<br>PowderBlue<br>center<br>align<br>height<br>width<br>href<br>tiy<br>Rectangle<br>Unnamed<br>Immutable<br>catch<br>Application<br>Bootstrap<br>controlFlag<br>required<br>Authorization<br>secret<br>loss<br>ephemeral<br>tracker<br>foreign<br>connected<br>state<br>Caused<br>See<br>Parameters<br>Specified<br>case<br>module<br>latency<br>fetch-throttle-time<br>sensor<br>Codinator<br>Assigned<br>Revoked<br>Interrupted<br>record<br>prefix<br>issues<br>iss<br>internal<br>Describe<br>DescribeCluster<br>duplicated<br>Utility<br>owned<br>non-owned<br>identified<br>yield<br>volatile<br>volati<br>volatite<br>Replica<br>controller<br>Listener<br>Rebalance<br>Atomic<br>wakeup<br>ConcurrentModification<br>Modification<br>Concurrent<br>inspection<br>Future<br>earliest<br>movingAvg<br>custemor<br>custe<br>maker<br>administering<br>adminis<br>admin<br>training<br>train<br>transaction<br>exactly<br>Deserializer<br>powered<br>powered<br>power<br>powerded<br>subscribe模式差异分析<br>subscribe<br>refer<br>construct<br>PLAINTEXT<br>Security<br>invalid<br>unique<br>Unreachable<br>TRACE<br>available<br>target<br>rollingfile<br>rolli<br>foreground<br>foregr<br>custom<br>remote<br>histories<br>unrelated<br>skip<br>Failures<br>period<br>lease<br>sit<br>instead<br>option<br>Executed<br>idempotence<br>symbol<br>regex<br>medium<br>Importance<br>deletion<br>France<br>precision<br>country<br>customer<br>customercountry<br>Columns<br>scala<br>meta<br>ITEM<br>DEVELOP<br>TRADE<br>applicable<br>WHOLE<br>temp<br>spark<br>Schames<br>timer<br>time<br>matches<br>expected<br>expecte<br>PARTITION<br>exiting<br>established<br>optional<br>MemStore<br>Store<br>platform<br>general<br>generalplatform<br>records<br>contains<br>invoke<br>poll<br>Deal<br>seek<br>parameter<br>usages<br>Field<br>modified<br>Definitions<br>Parse<br>Standard<br>Custom<br>checkpoint<br>secure<br>reduce<br>Guide<br>Reference<br>scheme<br>Received<br>topics<br>Due<br>queue<br>Proposed<br>Current<br>generate<br>region<br>qualifier<br>call<br>unable<br>Get<br>wonderfuk<br>locations<br>produce<br>Extracts<br>admins<br>For<br>The<br>MEMORY<br>BLOOMFILTER<br>ENABLED<br>could<br>Native<br>details<br>HRegionServer<br>backup<br>schema<br>Region<br>Pipeline<br>Transient<br>rejected<br>Push<br>bootstrap<br>remote<br>Building<br>remove<br>credential<br>dereferenced<br>can<br>implies<br>Redirected<br>Redirected<br>failed<br>featurel<br>develop<br>sonar<br>replace<br>Segment<br>hadoop<br>retrieve<br>store<br>separator<br>international<br>component<br>ignored<br>Elastic<br>wired<br>from<br>Loaded<br>via<br>recording<br>attempts<br>JsonIgnore<br>Sample<br>mounted<br>Poller<br>Periodic<br>PeriodicPoller<br>process<br>weather<br>increase<br>segment<br>SEMANTIC<br>SYNTAX<br>Patterns<br>mutate<br>grok<br>decode<br>match<br>plain<br>pipeline<br>Options<br>ensure<br>codec<br>position<br>Pretty<br>Escape<br>Escaping<br>disable<br>contributions<br>Corporation<br>concurrent<br>function<br>scan<br>common<br>Excute<br>Interval<br>cache<br>accessors<br>staged<br>Agent<br>snapshot<br>define<br>borrow<br>invalid<br>incorrect<br>inactive<br>Secondary<br>Column<br>salary<br>custom<br>dependency<br>resolve<br>collector<br>flow<br>Job<br>shuffle<br>Record<br>You<br>access<br>Minion<br>buffer<br>millis<br>intervalceiling<br>interval<br>pacemaker<br>pacemaker<br>deprecation<br>slow<br>contributors<br>wonderful<br>leadership<br>shard<br>increasing<br>consider<br>low<br>likely<br>process<br>descriptors<br>interests<br>Megacorp<br>sense<br>nstall<br>Permission<br>elastic<br>access<br>fetch<br>shape<br>Iterable<br>iterator<br>pervious<br>item<br>security<br>blobstore<br>implementation<br>ssl.secure.random.implementation<br>remark<br>sheet<br>reblance<br>mooc<br>Invalid<br>Automatic<br>receive<br>recommended<br>pool<br>Invalid<br>moment<br>Unable<br>stat<br>archive<br>sort<br>originState<br>broker<br>advertised<br>brokers<br>available<br>factor<br>replication<br>regular<br>advertise<br>essential<br>explanation<br>thnx<br>to<br>notty<br>difference<br>intersect<br>union<br>uniq<br>minify<br>wiki<br>native<br>ether<br>netmask<br>bcast<br>broadcast<br>fatal<br>field<br>Cell<br>Document<br>Information<br>Summary<br>developerworks<br>Exiting<br>Skipping<br>Fall<br>Security<br>too<br>Definition<br>ship<br>images<br>launch<br>Core<br>Full<br>Deployer<br>Extras<br>Embedded<br>latest<br>mirror<br>registry<br>Redirecting<br>batch<br>Handler<br>Unspecified<br>container<br>persist<br>Constraints<br>parse<br>feature<br>eature<br>offers<br>driver<br>specify<br>Function<br>UserWarning<br>staging<br>stag<br>Fetch<br>AttributeError<br>Installing<br>Press<br>Keep<br>pull<br>push<br>Microsoft<br>elements<br>upgrade<br>upgread<br>referer<br>request<br>alien<br>fleet<br>snip<br>bottom<br>rect<br>screen<br>blit<br>fill<br>exporrer<br>attribute<br>AttributeError<br>usage<br>InsecureRequestWarning<br>tickets<br>TypeError:<br>stations<br>perf<br>hsperf<br>future<br>SyntaxError:<br>based<br>executable<br>Ticket<br>libpng<br>libpng<br>libpng<br>display<br>caption<br>ValueError<br>Redirection<br>image<br>range<br>font<br>IOError<br>site<br>UnicodeEncodeError<br>SIGTERM<br>RECEIVED<br>proceed<br>comparison<br>permission<br>manual<br>syntax<br>conditiona<br>CASCADE<br>RESTRICT<br>alter<br>modify<br>TEMPORARY<br>Expressions<br>primary<br>distinct<br>enterprise<br>Component<br>release<br>assign<br>Call<br>sqrate<br>rate<br>summary<br>Data<br>near<br>BINARY<br>PRIVILEGES<br>Column<br>duplicate<br>dump<br>column<br>cursor<br>FOREIGN<br>REFERENCES<br>CONSTRAINT<br>PRIMARY<br>structure<br>formatter<br>cast<br>detected<br>bracket<br>statement<br>layout<br>neutral<br>rolling<br>level<br>expression<br>evaluator<br>deny<br>Mismatch<br>Match<br>append<br>pattern<br>encoder<br>Policy<br>triggering<br>triggeringPolicy<br>appender<br>configuration<br>Judge<br>transform<br>Unreachable<br>persistent<br>constrains<br>SERVLET<br>monit<br>stage<br>artifacts<br>encode<br>submit<br>except<br>report<br>operate<br>Operation<br>last<br>interva<br>Wipe<br>query<br>dumps<br>executor<br>Configuration<br>Reliability<br>Bolts<br>Spouts<br>Streams<br>topology<br>nimbus<br>supervisor<br>rebalance<br>deploy<br>Terminal<br>Operator<br>Container<br>External<br>Volume<br>Persistent<br>Element<br>Response<br>Queue<br>Strategy<br>Upgrade<br>Failure<br>deprecated<br>transactional<br>transactiona<br>template<br>Accept<br>Content<br>recent</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;contents&lt;br&gt;prevVolume&lt;br&gt;Sub&lt;br&gt;Invalid&lt;br&gt;calculate&lt;br&gt;Failed&lt;br&gt;claas&lt;br&gt;Prefix&lt;br&gt;Index&lt;br&gt;good&lt;br&gt;lite&lt;br&gt;export&lt;br&gt;Volume&lt;br&gt;WithDe
      
    
    </summary>
    
    
      <category term="程序员英语" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之职责链模式</title>
    <link href="http://yoursite.com/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/22/设计模式之职责链模式/</id>
    <published>2020-05-22T11:57:10.000Z</published>
    <updated>2020-05-21T07:45:00.844Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://yoursite.com/2020/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/21/设计模式之工厂模式/</id>
    <published>2020-05-21T11:57:10.000Z</published>
    <updated>2020-05-20T01:48:17.432Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="http://yoursite.com/2020/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/21/设计模式之组合模式/</id>
    <published>2020-05-21T11:57:10.000Z</published>
    <updated>2020-05-21T07:42:00.180Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://yoursite.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/20/设计模式之观察者模式/</id>
    <published>2020-05-20T11:57:10.000Z</published>
    <updated>2020-05-21T07:40:11.459Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="观察者模式" scheme="http://yoursite.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://yoursite.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/20/设计模式之适配器模式/</id>
    <published>2020-05-20T11:57:10.000Z</published>
    <updated>2020-05-21T07:39:51.401Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://yoursite.com/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/19/设计模式之单例模式/</id>
    <published>2020-05-19T11:57:10.000Z</published>
    <updated>2020-05-19T01:32:47.981Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谷歌protobuf详解</title>
    <link href="http://yoursite.com/2020/05/18/%E8%B0%B7%E6%AD%8Cprotobuf%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/18/谷歌protobuf详解/</id>
    <published>2020-05-18T11:57:10.000Z</published>
    <updated>2020-05-21T07:46:31.537Z</updated>
    
    <content type="html"><![CDATA[<p>Protobuf 实际是一套类似 Json 或者 XML 的数据传输格式和规范，用于不同应用或进程之间进行通信时使用。通信时所传递的信息是通过 Protobuf 定义的 message 数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。</p><p>相比较而言，Protobuf 有如下优点：</p><ul><li>足够简单</li><li>序列化后体积很小：消息大小只需要 XML 的 1/10 ~ 1/3</li><li>解析速度快：解析速度比 XML 快 20 ~ 100 倍</li><li>多语言支持</li><li>更好的兼容性，Protobuf 设计的一个原则就是要能够很好的支持向下或向上兼容</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Protobuf 实际是一套类似 Json 或者 XML 的数据传输格式和规范，用于不同应用或进程之间进行通信时使用。通信时所传递的信息是通过 Protobuf 定义的 message 数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。&lt;/p&gt;
&lt;p&gt;相比较而言，
      
    
    </summary>
    
    
      <category term="序列化数据、协议" scheme="http://yoursite.com/categories/%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>mac 使用 brew update 无反应，更新慢解决办法</title>
    <link href="http://yoursite.com/2020/05/15/mac%20%E4%BD%BF%E7%94%A8%20brew%20update%20%E6%97%A0%E5%8F%8D%E5%BA%94%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/15/mac 使用 brew update 无反应，更新慢解决办法/</id>
    <published>2020-05-15T11:57:10.000Z</published>
    <updated>2020-05-15T07:08:30.089Z</updated>
    
    <content type="html"><![CDATA[<p>每次 brew update 或 brew install xxx 都需要等很长时间；</p><h3 id="使用中科大的镜像替换默认源"><a href="#使用中科大的镜像替换默认源" class="headerlink" title="使用中科大的镜像替换默认源"></a>使用中科大的镜像替换默认源</h3><ul><li>第一步，替换 brew.git<h4 id="进入brew主目录"><a href="#进入brew主目录" class="headerlink" title="进入brew主目录"></a>进入brew主目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更换镜像"><a href="#更换镜像" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure><ul><li>第二步：替换 homebrew-core.git<h4 id="进入brew主目录-1"><a href="#进入brew主目录-1" class="headerlink" title="进入brew主目录"></a>进入brew主目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更换镜像-1"><a href="#更换镜像-1" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><ul><li>最后使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></li></ul><h3 id="几个镜像"><a href="#几个镜像" class="headerlink" title="几个镜像:"></a>几个镜像:</h3><ul><li><a href="https://git.coding.net/homebrew/homebrew.git" target="_blank" rel="noopener">https://git.coding.net/homebrew/homebrew.git</a> - Coding</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</a> - 清华</li><li><a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a> - 中科大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次 brew update 或 brew install xxx 都需要等很长时间；&lt;/p&gt;
&lt;h3 id=&quot;使用中科大的镜像替换默认源&quot;&gt;&lt;a href=&quot;#使用中科大的镜像替换默认源&quot; class=&quot;headerlink&quot; title=&quot;使用中科大的镜像替换默认源&quot;&gt;
      
    
    </summary>
    
    
      <category term="Mac、brew更新" scheme="http://yoursite.com/categories/Mac%E3%80%81brew%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>python3.8 不能使用 requests 问题</title>
    <link href="http://yoursite.com/2020/05/14/python3.7%20%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%20requests%20%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/14/python3.7 不能使用 requests 问题/</id>
    <published>2020-05-14T11:57:10.000Z</published>
    <updated>2020-05-15T07:14:23.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码会提示"><a href="#代码会提示" class="headerlink" title="代码会提示"></a>代码会提示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &apos;requests&apos;</span><br></pre></td></tr></table></figure><h4 id="问题：因为你的-python-还未安装-requests-库，需要通过-pip-安装。"><a href="#问题：因为你的-python-还未安装-requests-库，需要通过-pip-安装。" class="headerlink" title="问题：因为你的 python 还未安装 requests 库，需要通过 pip 安装。"></a>问题：因为你的 python 还未安装 requests 库，需要通过 pip 安装。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">luxiaofeng@yuezpdeMacBook-Pro~ pip3 install requests</span><br><span class="line">Collecting requests</span><br><span class="line">  Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85E8A760</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85E8A340</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EACDC0</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EACAC0</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EAC610</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Could not find a version that satisfies the requirement requests (from versions: )</span><br><span class="line">No matching distribution found for requests</span><br></pre></td></tr></table></figure><p>从执行的过程来看，请求一直处于超时。这是由于国内很多情况下，无法正常去下载国外服务器资源导致。</p><h4 id="解决方法：使用国内镜像，常用的有镜像有"><a href="#解决方法：使用国内镜像，常用的有镜像有" class="headerlink" title="解决方法：使用国内镜像，常用的有镜像有"></a>解决方法：使用国内镜像，常用的有镜像有</h4><ul><li>清华大学镜像：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>阿里云：<a href="https://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple/</a></li><li>中科大镜像：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>中科大镜像 2：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><h4 id="使用镜像的安装范式为："><a href="#使用镜像的安装范式为：" class="headerlink" title="使用镜像的安装范式为："></a>使用镜像的安装范式为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install xxxx -i http://… 或者 pip install  -i https://… xxxx。</span><br><span class="line"># 示例如下：</span><br><span class="line">pip install requests -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h4 id="注意：如果安装过程中提示需要升级-pip"><a href="#注意：如果安装过程中提示需要升级-pip" class="headerlink" title="注意：如果安装过程中提示需要升级 pip"></a>注意：如果安装过程中提示需要升级 pip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.</span><br><span class="line"># 解决命令</span><br><span class="line">python -m pip install --upgrade pip -i http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码会提示&quot;&gt;&lt;a href=&quot;#代码会提示&quot; class=&quot;headerlink&quot; title=&quot;代码会提示&quot;&gt;&lt;/a&gt;代码会提示&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
      <category term="python学习" scheme="http://yoursite.com/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="包安装" scheme="http://yoursite.com/tags/%E5%8C%85%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>PostConstruct注解</title>
    <link href="http://yoursite.com/2020/05/13/@PostConstruct%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/13/@PostConstruct注解/</id>
    <published>2020-05-13T11:57:10.000Z</published>
    <updated>2020-05-13T09:49:12.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PostConstruct-的-API-使用说明"><a href="#PostConstruct-的-API-使用说明" class="headerlink" title="@PostConstruct 的 API 使用说明"></a>@PostConstruct 的 API 使用说明</h3><blockquote><p>PostConstruct 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。应用 PostConstruct 注释的方法必须遵守以下所有标准：该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext 对象 ；该方法的返回类型必须为 void；该方法不得抛出已检查异常；应用 PostConstruct 的方法可以是 public、protected、package private 或 private；除了应用程序客户端之外，该方法不能是 static；该方法可以是 final；如果该方法抛出未检查异常，那么不得将类放入服务中，除非是能够处理异常并可从中恢复的 EJB。</p></blockquote><a id="more"></a><p><strong><em>总结为一下几点：</em></strong></p><ul><li>只有一个方法可以使用此注释进行注解；</li><li>被注解方法不得有任何参数；</li><li>被注解方法返回值为 void；</li><li>被注解方法不得抛出已检查异常；</li><li>被注解方法需是非静态方法；</li><li>此方法只会被执行一次；</li></ul><p>在具体 Bean 的实例化过程中，@PostConstruct 注释的方法，会在构造方法之后，init 方法之前进行调用。</p><ul><li><p>UserService 方法（提供缓存数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public List&lt;String&gt; getUser()&#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;张三&quot;);</span><br><span class="line">        list.add(&quot;李四&quot;);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BusinessService 方法，通过 @PostConstruct 调用 UserService：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.PostConstruct;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BusinessService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; list = null;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法执行之后，调用此方法</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;@PostConstruct方法被调用&quot;);</span><br><span class="line">        // 实例化类之前缓存获得用户信息</span><br><span class="line">        List&lt;String&gt; list = userService.getUser();</span><br><span class="line">        this.list = list;</span><br><span class="line">        if(list != null &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">            for(String user : list)&#123;</span><br><span class="line">                System.out.println(&quot;用户：&quot; + user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessService()&#123;</span><br><span class="line">        System.out.println(&quot;构造方法被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法被调用</span><br><span class="line">@PostConstruct方法被调用</span><br><span class="line">用户：张三</span><br><span class="line">用户：李四</span><br></pre></td></tr></table></figure></li></ul><p>[参考链接]<a href="https://blog.csdn.net/wo541075754/article/details/52174900" target="_blank" rel="noopener">https://blog.csdn.net/wo541075754/article/details/52174900</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PostConstruct-的-API-使用说明&quot;&gt;&lt;a href=&quot;#PostConstruct-的-API-使用说明&quot; class=&quot;headerlink&quot; title=&quot;@PostConstruct 的 API 使用说明&quot;&gt;&lt;/a&gt;@PostConstruct 的 API 使用说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;PostConstruct 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。应用 PostConstruct 注释的方法必须遵守以下所有标准：该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext 对象 ；该方法的返回类型必须为 void；该方法不得抛出已检查异常；应用 PostConstruct 的方法可以是 public、protected、package private 或 private；除了应用程序客户端之外，该方法不能是 static；该方法可以是 final；如果该方法抛出未检查异常，那么不得将类放入服务中，除非是能够处理异常并可从中恢复的 EJB。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java注解" scheme="http://yoursite.com/tags/Java%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="http://yoursite.com/2020/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/08/设计模式之代理模式/</id>
    <published>2020-05-08T11:57:10.000Z</published>
    <updated>2020-05-21T07:40:00.358Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性三</title>
    <link href="http://yoursite.com/2020/05/07/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%89/"/>
    <id>http://yoursite.com/2020/05/07/Java8新特性三/</id>
    <published>2020-05-07T11:57:10.000Z</published>
    <updated>2020-05-07T02:18:44.177Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性二</title>
    <link href="http://yoursite.com/2020/05/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/05/06/Java8新特性二/</id>
    <published>2020-05-06T11:57:10.000Z</published>
    <updated>2020-05-07T02:18:14.406Z</updated>
    
    <content type="html"><![CDATA[<p>Java8新特性之方法引用， </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8新特性之方法引用， &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性一</title>
    <link href="http://yoursite.com/2020/04/25/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80/"/>
    <id>http://yoursite.com/2020/04/25/Java8新特性一/</id>
    <published>2020-04-25T11:57:10.000Z</published>
    <updated>2020-05-06T08:44:42.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="为什么要使用-lambda-表达式"><a href="#为什么要使用-lambda-表达式" class="headerlink" title="为什么要使用 lambda 表达式"></a>为什么要使用 lambda 表达式</h4><p>我们直接举个例子来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest1 &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        //第一种</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;不使用Lambda表达式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        System.out.println(&quot;=======================&quot;);</span><br><span class="line">        //第二种</span><br><span class="line">        Runnable runnable1 = () -&gt; System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        runnable1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*不使用Lambda表达式</span><br><span class="line">=======================</span><br><span class="line">使用Lambda表达式*/</span><br></pre></td></tr></table></figure><p>之前我们新建一个线程使用 5 行代码，但是如果我们使用 lambda 表达式只需要 1 行代码即可，是不是很方便。</p><a id="more"></a><h4 id="lambda-表达式的使用"><a href="#lambda-表达式的使用" class="headerlink" title="lambda 表达式的使用"></a>lambda 表达式的使用</h4><ul><li>基本语法</li></ul><p>1.左边括号：lambda 的形参列表，就好比是我们定义一个接口，里面有一个抽象方法，这个抽象方法的形参列表。<br>2.箭头：lambda 的操作符，所以你看见这个箭头心中知道这是一个 lambda 表达式就可以了。<br>3.右边 lambda 体：就好比是我们实现了接口中的抽象方法。</p><ul><li><p>无参无返回值<br>这个是最简单的一种情况，就是刚刚我们所举的例子。为了不混淆我们再举一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//此时如果方法体比较复杂好几行代码，那么这个&#123;&#125;是不能省略的</span><br><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">            System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>有参数无返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(&quot;没有使用lambda:有参数，但是没有返回值&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Consumer&lt;String&gt; consumer1 = (String s)-&gt;&#123;</span><br><span class="line">        //此时只有一行输出代码，因此可以省去外部的&#123;&#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(&quot;使用lambda:有参数，但是没有返回值&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参数无返回值，数据类型可省略，称为类型推断<br>这种情况只能称之为上面的一种特例，只不过我们可以不传入类型，由编译器帮我们推断出来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer1 = (s)-&gt;&#123;</span><br><span class="line">      //此时只有一行输出代码，因此可以省去外部的&#123;&#125;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(&quot;使用lambda:有参数，但是没有返回值&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有多个参数，有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            System.out.println(&quot;o1:&quot;+o1);</span><br><span class="line">            return o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator.compare(1,2));</span><br><span class="line">    System.out.println(&quot;======================&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator2 = (o1,o2)-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;o1:&quot;+o1);</span><br><span class="line">        return o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator2.compare(1,2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们使用了一个比较器，当然了如果只有一条 return 语句的话，那样式就更简单了。箭头直接指向我们要返回的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator.compare(1,2));</span><br><span class="line">    System.out.println(&quot;======================&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator2 = (o1,o2)-&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator2.compare(1,2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda-表达式深入解析"><a href="#Lambda-表达式深入解析" class="headerlink" title="Lambda 表达式深入解析"></a>Lambda 表达式深入解析</h4><ul><li>什么是函数式接口</li></ul><p>比如我们的 Runnable 就是一个函数式接口，我们可以到源码中看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他主要有如下的特点：</p><blockquote><blockquote><p>含有 @FunctionalInterface 注解</p></blockquote></blockquote><blockquote><blockquote><p>只有一个抽象方法<br>也就是说只有函数式接口的变量或者是函数式接口，才能够赋值为 Lambda 表达式。当然了方法的类型可以任意。</p></blockquote></blockquote><ul><li>参数的小括号可以省略，当且仅当只有一个参数.</li><li>参数的数据类型可以省略，当且仅当 lambda表达式.</li><li>方法体的 return 和大括号可以省略，当且仅当只有一条语句.</li></ul><p>只包含一个抽象方法的接口, 称为函数式接口(除了隐含的Object对象的公共方法)；<br>函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和 Object 的 public方法一样 (必须满足即使 Object 的方法，又是 public 的接口，像 Object 的 clone () 接口就不是 public)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h3&gt;&lt;h4 id=&quot;为什么要使用-lambda-表达式&quot;&gt;&lt;a href=&quot;#为什么要使用-lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 lambda 表达式&quot;&gt;&lt;/a&gt;为什么要使用 lambda 表达式&lt;/h4&gt;&lt;p&gt;我们直接举个例子来看看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LambdaTest1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void test1() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //第一种&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runnable runnable = new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;不使用Lambda表达式&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runnable.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;=======================&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //第二种&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runnable runnable1 = () -&amp;gt; System.out.println(&amp;quot;使用Lambda表达式&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runnable1.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*不使用Lambda表达式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=======================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用Lambda表达式*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;之前我们新建一个线程使用 5 行代码，但是如果我们使用 lambda 表达式只需要 1 行代码即可，是不是很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>安装gradle</title>
    <link href="http://yoursite.com/2020/04/14/%E5%AE%89%E8%A3%85gradle/"/>
    <id>http://yoursite.com/2020/04/14/安装gradle/</id>
    <published>2020-04-14T11:57:10.000Z</published>
    <updated>2020-04-14T08:50:13.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gradle-安装（Mac）"><a href="#Gradle-安装（Mac）" class="headerlink" title="Gradle 安装（Mac）"></a>Gradle 安装（Mac）</h3><ul><li>下载 Gradle<br>先检查 java 环境，是否安装了 jdk 或者 jre 8 或者以上版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version &quot;1.8.0_121&quot;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>官网下载：<a href="https://gradle.org/releases" target="_blank" rel="noopener">https://gradle.org/releases</a><br>选择某一版本的 binary-only 进行下载，例如：<br><img src="/2020/04/14/安装gradle/aaa.png" alt><br>将下载的文件解压到某一目录下，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip gradle-5.2.1-bin.zip</span><br></pre></td></tr></table></figure><ul><li>配置环境变量<br>编辑 bash_profile 文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><p>加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#GRADLE</span><br><span class="line">GRADLE_HOME=/Users/luxiaofeng/gradle</span><br><span class="line">PATH=$PATH:$GRADLE_HOME/bin</span><br><span class="line">export GRADLE_HOME GRADLE_USER_HOME PATH</span><br></pre></td></tr></table></figure><p>执行下面命令使内容生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -v</span><br></pre></td></tr></table></figure><p>出现下面内容表示安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">luxiaofeng@yuezhipingdeMacBook-Pro  ~  gradle -v</span><br><span class="line"></span><br><span class="line">Welcome to Gradle 5.2.1!</span><br><span class="line"></span><br><span class="line">Here are the highlights of this release:</span><br><span class="line"> - Define sets of dependencies that work together with Java Platform plugin</span><br><span class="line"> - New C++ plugins with dependency management built-in</span><br><span class="line"> - New C++ project types for gradle init</span><br><span class="line"> - Service injection into plugins and project extensions</span><br><span class="line"></span><br><span class="line">For more details see https://docs.gradle.org/5.2.1/release-notes.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 5.2.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2019-02-08 19:00:10 UTC</span><br><span class="line">Revision:     f02764e074c32ee8851a4e1877dd1fea8ffb7183</span><br><span class="line"></span><br><span class="line">Kotlin DSL:   1.1.3</span><br><span class="line">Kotlin:       1.3.20</span><br><span class="line">Groovy:       2.5.4</span><br><span class="line">Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018</span><br><span class="line">JVM:          1.8.0_221 (Oracle Corporation 25.221-b11)</span><br><span class="line">OS:           Mac OS X 10.15.3 x86_64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gradle-安装（Mac）&quot;&gt;&lt;a href=&quot;#Gradle-安装（Mac）&quot; class=&quot;headerlink&quot; title=&quot;Gradle 安装（Mac）&quot;&gt;&lt;/a&gt;Gradle 安装（Mac）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载 Gradle&lt;br&gt;先检查 java 环境，是否安装了 jdk 或者 jre 8 或者以上版本：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java version &amp;quot;1.8.0_121&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="包管理工具" scheme="http://yoursite.com/categories/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="包管理工具" scheme="http://yoursite.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>java反射详解</title>
    <link href="http://yoursite.com/2020/03/28/java%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/28/java反射详解/</id>
    <published>2020-03-28T11:57:10.000Z</published>
    <updated>2020-04-09T05:54:32.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p>Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。<br>用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。</p><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>静态编译：在编译时确定类型，绑定对象，即通过。<br>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了 java 的灵活性，体现了多态的应用，用于降低类之间的藕合性。</p><a id="more"></a><p>优点<br>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在 J2EE 的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p><p>缺点<br>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p><h3 id="理解-Class-类和类类型"><a href="#理解-Class-类和类类型" class="headerlink" title="理解 Class 类和类类型"></a>理解 Class 类和类类型</h3><p>想要了解反射首先理解一下 Class 类，它是反射实现的基础。<br>所有的类是 java.lang.Class 类的实例对象，而 Class 是所有类的类（There is a class named Class）<br>对于普通的对象，我们一般都会这样创建和表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code code1 = new Code();</span><br></pre></td></tr></table></figure><p>上面说了，所有的类都是 Class 的对象，那么如何表示呢，可不可以通过如下方式呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = new Class();</span><br></pre></td></tr></table></figure><p>但是我们查看 Class 的源码时，是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private  Class(ClassLoader loader) &#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到构造器是私有的，只有 JVM 可以创建 Class 的对象，因此不可以像普通类一样 new 一个 Class 对象，虽然我们不能 new 一个 Class 对象，但是却可以通过已有的类得到一个 Class 对象，共有三种方式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Code.class;</span><br><span class="line">这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span><br><span class="line">Class c2 = code1.getClass();</span><br><span class="line">code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span><br><span class="line">Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);</span><br><span class="line">这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span><br></pre></td></tr></table></figure><p>这里，c1、c2、c3 都是 Class 的对象，他们是完全一样的，而且有个学名，叫做 Code 的类类型（class type）。<br>这里就让人奇怪了，前面不是说 Code 是 Class 的对象吗，而 c1、c2、c3 也是 Class 的对象，那么 Code 和 c1、c2、c3 不就一样了吗？为什么还叫 Code 什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</p><p>举个简单例子代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //第一种：Class c1 = Code.class;</span><br><span class="line">        Class class1=ReflectDemo.class;</span><br><span class="line">        System.out.println(class1.getName());</span><br><span class="line"></span><br><span class="line">        //第二种：Class c2 = code1.getClass();</span><br><span class="line">        ReflectDemo demo2= new ReflectDemo();</span><br><span class="line">        Class c2 = demo2.getClass();</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line"></span><br><span class="line">        //第三种：Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);</span><br><span class="line">        Class class3 = Class.forName(&quot;com.tengj.reflect.ReflectDemo&quot;);</span><br><span class="line">        System.out.println(class3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br></pre></td></tr></table></figure><h3 id="Java-反射相关操作"><a href="#Java-反射相关操作" class="headerlink" title="Java 反射相关操作"></a>Java 反射相关操作</h3><p>前面我们知道了怎么获取 Class，那么我们可以通过这个 Class 干什么呢？<br>总结如下：</p><ul><li>获取成员方法 Method</li><li>获取成员变量 Field</li><li>获取构造函数 Constructor</li></ul><h4 id="获取成员方法信息"><a href="#获取成员方法信息" class="headerlink" title="获取成员方法信息"></a>获取成员方法信息</h4><p>单独获取某一个方法是通过 Class 类的以下方法获得的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的</span><br></pre></td></tr></table></figure><p>两个参数分别是方法名和方法参数类的类类型列表。<br>例如类 A 有如下一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void fun(String name,int age) &#123;</span><br><span class="line">    System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在知道 A 有一个对象 a，那么就可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);  //先生成class</span><br><span class="line">Object o = c.newInstance();                           //newInstance可以初始化一个实例</span><br><span class="line">Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);//获取方法</span><br><span class="line">method.invoke(o, &quot;tengj&quot;, 10);                              //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String msg=&quot;hello wrold&quot;;</span><br><span class="line"> public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        System.out.println(&quot;fun&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun(String name,int age) &#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);</span><br><span class="line">            method.invoke(o, &quot;tengj&quot;, 10);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫tengj,今年10岁</span><br></pre></td></tr></table></figure><p>有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：<br>1.获取所有方法的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的</span><br><span class="line">或者：</span><br><span class="line">Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的</span><br></pre></td></tr></table></figure><p>2.然后循环这个数组就得到每个方法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Method method : methods)</span><br></pre></td></tr></table></figure><p>完整代码如下：<br>person 类跟上面一样，这里以及后面就不贴出来了，只贴关键代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            for(Method m:methods)&#123;</span><br><span class="line">                String  methodName= m.getName();</span><br><span class="line">                System.out.println(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">getAge</span><br></pre></td></tr></table></figure><p>这里如果把 c.getDeclaredMethods (); 改成 c.getMethods (); 执行结果如下，多了很多方法，以为把 Object 里面的方法也打印出来了，因为 Object 是所有类的父类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br></pre></td></tr></table></figure><h4 id="获取成员变量信息"><a href="#获取成员变量信息" class="headerlink" title="获取成员变量信息"></a>获取成员变量信息</h4><p>想一想成员变量中都包括什么：成员变量类型 + 成员变量名<br>类的成员变量也是一个对象，它是 java.lang.reflect.Field 的一个对象，所以我们通过 java.lang.reflect.Field 里面封装的方法来获取这些信息。</p><p>单独获取某个成员变量，通过 Class 类的以下方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量</span><br><span class="line">public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量</span><br></pre></td></tr></table></figure><p>参数是成员变量的名字。<br>例如一个类 A 有如下成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int n;</span><br></pre></td></tr></table></figure><p>如果 A 有一个对象 a，那么就可以这样得到其成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Field field = c.getDeclaredField(&quot;n&quot;);</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取成员变量</span><br><span class="line">            Field field = c.getDeclaredField(&quot;msg&quot;); //因为msg变量是private的，所以不能用getField方法</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。</span><br><span class="line">            Object msg = field.get(o);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello wrold</span><br></pre></td></tr></table></figure><p>同样，如果想要获取所有成员变量的信息，可以通过以下几步<br>1.获取所有成员变量的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>2.遍历变量数组，获得某个成员变量 field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Field field : fields)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            for(Field field :fields)&#123;</span><br><span class="line">                System.out.println(field.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">msg</span><br></pre></td></tr></table></figure><h4 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h4><p>最后再想一想构造函数中都包括什么：构造函数参数<br>同上，类的成构造函数也是一个对象，它是 java.lang.reflect.Constructor 的一个对象，所以我们通过 java.lang.reflect.Constructor 里面封装的方法来获取这些信息。</p><p>单独获取某个构造函数，通过 Class 类的以下方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) //  获得该类所有的构造器，不包括其父类的构造器</span><br><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类</span><br></pre></td></tr></table></figure><p>这个参数为构造函数参数类的类类型列表。<br>例如类 A 有如下一个构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public A(String a, int b) &#123;</span><br><span class="line">    // code body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = a.getDeclaredConstructor(String.class, int.class);</span><br></pre></td></tr></table></figure><p>来获取这个构造函数。</p><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取构造函数</span><br><span class="line">            Constructor constructor = c.getDeclaredConstructor(String.class);</span><br><span class="line">            constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。</span><br><span class="line">            constructor.newInstance(&quot;tengj&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tengj</span><br></pre></td></tr></table></figure><p>注意：Class 的 newInstance 方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：fromClass.getDeclaredConstructor (String.class).newInstance (“tengj”);</p><p>获取所有的构造函数，可以通过以下步骤实现：<br>1.获取该类的所有构造函数，放在一个数组中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure><p>2.遍历构造函数数组，获得某个构造函数 constructor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Constructor constructor : constructors)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">            Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">            for(Constructor constructor:constructors)&#123;</span><br><span class="line">                System.out.println(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public com.tengj.reflect.Person()</span><br><span class="line">public com.tengj.reflect.Person(java.lang.String)</span><br></pre></td></tr></table></figure><p>通过反射了解集合泛型的本质<br>首先下结论：</p><ul><li>Java 中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</li></ul><p>下面通过一个实例来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 集合泛型的本质</span><br><span class="line"> * @description</span><br><span class="line"> * @author Trigl</span><br><span class="line"> * @date 2016年4月2日上午2:54:11</span><br><span class="line"> */</span><br><span class="line">public class GenericEssence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list1 = new ArrayList(); // 没有泛型 </span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 有泛型</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span><br><span class="line">         * 这个时候如果list2添加int类型会报错</span><br><span class="line">         */</span><br><span class="line">        list2.add(&quot;hello&quot;);</span><br><span class="line">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span><br><span class="line">        System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 此时list2长度为1</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span><br><span class="line">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span><br><span class="line">         * 型的元素</span><br><span class="line">         */</span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); // 结果：true，说明类类型完全相同</span><br><span class="line"></span><br><span class="line">        // 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span><br><span class="line">        try &#123;</span><br><span class="line">            Method m = c2.getMethod(&quot;add&quot;, Object.class); // 通过方法反射得到add方法</span><br><span class="line">            m.invoke(list2, 20); // 给list2添加一个int型的，上面显示在编译器是会报错的</span><br><span class="line">            System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 结果：2，说明list2长度增加了，并没有泛型检查</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span><br><span class="line">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2的长度是：1</span><br><span class="line">true</span><br><span class="line">list2的长度是：2</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        //创建methodClass的实例</span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        //获取methodClass类的add方法</span><br><span class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">        //调用method对应的方法 =&gt; add(1,4)</span><br><span class="line">        Object result = method.invoke(obj,1,4);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class methodClass &#123;</span><br><span class="line">    public final int fuck = 3;</span><br><span class="line">    public int add(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sub(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h4><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个 Object Reference。下面我们看一看利用反射创建数组的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void testArray() throws ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">        Object array = Array.newInstance(cls,25);</span><br><span class="line">        //往数组里添加内容</span><br><span class="line">        Array.set(array,0,&quot;hello&quot;);</span><br><span class="line">        Array.set(array,1,&quot;Java&quot;);</span><br><span class="line">        Array.set(array,2,&quot;fuck&quot;);</span><br><span class="line">        Array.set(array,3,&quot;Scala&quot;);</span><br><span class="line">        Array.set(array,4,&quot;Clojure&quot;);</span><br><span class="line">        //获取某一项的内容</span><br><span class="line">        System.out.println(Array.get(array,3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 Array 类为 java.lang.reflect.Array 类。我们通过 Array.newInstance () 创建数组对象，它的原型是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object newInstance(Class&lt;?&gt; componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException &#123;</span><br><span class="line">        return newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 newArray 方法是一个 native 方法，它在 HotSpot JVM 里的具体实现我们后边再研究，这里先把源码贴出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static native Object newArray(Class&lt;?&gt; componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException;</span><br></pre></td></tr></table></figure><p>源码目录：openjdk\hotspot\src\share\vm\runtime\reflection.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</span><br><span class="line">  if (element_mirror == NULL) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  if (length &lt; 0) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</span><br><span class="line">  &#125;</span><br><span class="line">  if (java_lang_Class::is_primitive(element_mirror)) &#123;</span><br><span class="line">    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);</span><br><span class="line">    return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</span><br><span class="line">    if (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</span><br><span class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">    &#125;</span><br><span class="line">    return oopFactory::new_objArray(k, length, THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Array 类的 set 和 get 方法都为 native 方法，在 HotSpot JVM 里分别对应 Reflection::array_set 和 Reflection::array_get 方法，这里就不详细解析了。<br>[参考链接]<a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">http://tengj.top/2016/04/28/javareflect/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java反射机制&quot;&gt;&lt;a href=&quot;#Java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java反射机制&quot;&gt;&lt;/a&gt;Java反射机制&lt;/h3&gt;&lt;p&gt;Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。&lt;br&gt;用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。&lt;/p&gt;
&lt;h3 id=&quot;反射机制优缺点&quot;&gt;&lt;a href=&quot;#反射机制优缺点&quot; class=&quot;headerlink&quot; title=&quot;反射机制优缺点&quot;&gt;&lt;/a&gt;反射机制优缺点&lt;/h3&gt;&lt;p&gt;静态编译：在编译时确定类型，绑定对象，即通过。&lt;br&gt;动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了 java 的灵活性，体现了多态的应用，用于降低类之间的藕合性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、反射" scheme="http://yoursite.com/tags/Java%E3%80%81%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>注解详解</title>
    <link href="http://yoursite.com/2020/03/27/%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/27/注解详解/</id>
    <published>2020-03-27T11:57:10.000Z</published>
    <updated>2020-04-28T07:34:23.046Z</updated>
    
    <content type="html"><![CDATA[<p>{“ozone.om.address”:”hbase-2:9862”}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;{“ozone.om.address”:”hbase-2:9862”}&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、注解" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://yoursite.com/2020/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/21/设计模式之策略模式/</id>
    <published>2020-03-21T11:57:10.000Z</published>
    <updated>2020-05-21T07:46:20.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。<br>然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。</p><a id="more"></a><h2 id="二、基本的策略模式使用方法"><a href="#二、基本的策略模式使用方法" class="headerlink" title="二、基本的策略模式使用方法"></a>二、基本的策略模式使用方法</h2><p>我们直接来看例子：</p><h3 id="1-策略接口"><a href="#1-策略接口" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    void testStrategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备两个实现类"><a href="#2-准备两个实现类" class="headerlink" title="2. 准备两个实现类"></a>2. 准备两个实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 实现类A</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyA implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 实现类B</span><br><span class="line"> */</span><br><span class="line">public class StrategyB implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-策略执行-Context-类"><a href="#3-策略执行-Context-类" class="headerlink" title="3. 策略执行 Context 类"></a>3. 策略执行 Context 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 策略执行</span><br><span class="line"> */</span><br><span class="line">public class Context &#123;</span><br><span class="line">    </span><br><span class="line">    private Strategy stg;</span><br><span class="line">    </span><br><span class="line">    public void doAction() &#123;</span><br><span class="line">        this.stg.testStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    /*  Getter And Setter */</span><br><span class="line">    public Strategy getStg() &#123;</span><br><span class="line">        return stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStg(Strategy stg) &#123;</span><br><span class="line">        this.stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们准备一个 main 方法来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: StrategyTest</span><br><span class="line"> */</span><br><span class="line">public class StrategyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy stgB = new StrategyB();</span><br><span class="line">        Context context = new Context(stgB);</span><br><span class="line">        context.setStg(stgB);</span><br><span class="line">        context.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、与-Spring-想结合的策略模式"><a href="#三、与-Spring-想结合的策略模式" class="headerlink" title="三、与 Spring 想结合的策略模式"></a>三、与 Spring 想结合的策略模式</h2><p>我们主要利用 Spring 的核心 IOC 来实现它，还是使用上面的例子；<br>由于我们要在 Spring 的配置文件中来注入 Context 的实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;context&quot; class = &quot;top.catalinali.search.service.impl.Context&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;stg&quot; ref=&quot;stgB&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;stgA&quot; class = &quot;top.catalinali.search.service.impl.StrategyA&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;stgB&quot; class = &quot;top.catalinali.search.service.impl.StrategyB&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就可以通过只修改配置文件来更改 context 的实现类，从而达到策略模式的目的。</p><h2 id="四、通过-Spring-使用策略模式替换中间件的单机与集群配置"><a href="#四、通过-Spring-使用策略模式替换中间件的单机与集群配置" class="headerlink" title="四、通过 Spring 使用策略模式替换中间件的单机与集群配置"></a>四、通过 Spring 使用策略模式替换中间件的单机与集群配置</h2><p>在开发环境中，许多中间件使用的是单机配置。可到了生产我们就需要使用集群配置。这里我们就可以通过策略模式来快速改变中间件的配置，现在我们以 Redis 为例：</p><h3 id="1-策略接口-1"><a href="#1-策略接口-1" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><p>首先我们把 Redis 方法抽成一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface JedisClient &#123;</span><br><span class="line">    String set(String key, String value);</span><br><span class="line">    String get(String key);</span><br><span class="line">    Boolean exists(String key);</span><br><span class="line">    Long expire(String key, int seconds);</span><br><span class="line">    Long ttl(String key);</span><br><span class="line">    Long incr(String key);</span><br><span class="line">    Long hset(String key, String field, String value);</span><br><span class="line">    String hget(String key, String field);</span><br><span class="line">    Long hdel(String key, String... field);</span><br><span class="line">    Boolean hexists(String key, String field);</span><br><span class="line">    List&lt;String&gt; hvals(String key);</span><br><span class="line">    Long del(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单机和集群两个实现类"><a href="#2-单机和集群两个实现类" class="headerlink" title="2. 单机和集群两个实现类"></a>2. 单机和集群两个实现类</h3><p>这里我们准备单机和集群两个实现类：JedisClientPool 和 JedisClientCluster。实现上面的 JedisClient 接口，分别使用单机和集群的代码来实现这些方法。因为代码冗长就不在这里贴出来了。</p><h3 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h3><p>我们使用不同的环境只需要把不用的配置注释掉就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 连接redis单机版 --&gt;</span><br><span class="line">&lt;bean id=&quot;jedisClientPool&quot; class=&quot;top.catalinali.common.jedis.JedisClientPool&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisPool&quot; ref=&quot;jedisPool&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.72.121&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 连接redis集群 --&gt;</span><br><span class="line">&lt;!-- &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;cn.e3mall.common.jedis.JedisClientCluster&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisCluster&quot; ref=&quot;jedisCluster&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;nodes&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt; --&gt;</span><br></pre></td></tr></table></figure><p>这样在我们开发时只需要注释掉连接集群的配置，而在上线时注释掉单机的配置就好。</p><p>[转载]<a href="https://segmentfault.com/a/1190000012474002" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012474002</a><br>[参考链接]<a href="https://juejin.im/post/59facc30518825297a0e164c" target="_blank" rel="noopener">https://juejin.im/post/59facc30518825297a0e164c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是策略模式？&quot;&gt;&lt;a href=&quot;#一、什么是策略模式？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是策略模式？&quot;&gt;&lt;/a&gt;一、什么是策略模式？&lt;/h2&gt;&lt;p&gt;在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。&lt;br&gt;然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="策略模式" scheme="http://yoursite.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰器模式</title>
    <link href="http://yoursite.com/2020/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/20/设计模式之装饰器模式/</id>
    <published>2020-03-20T11:57:10.000Z</published>
    <updated>2020-05-22T03:41:30.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>装饰器模式: 在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p></blockquote><a id="more"></a><h3 id="装饰器模式组成"><a href="#装饰器模式组成" class="headerlink" title="装饰器模式组成"></a>装饰器模式组成</h3><ul><li>抽象组件角色 (Component): 定义可以动态添加任务的对象的接口</li><li>具体组件角色 (ConcreteComponent)：定义一个要被装饰器装饰的对象，即 Component 的具体实现</li><li>抽象装饰器 (Decorator): 维护对组件对象和其子类组件的引用</li><li>具体装饰器角色 (ConcreteDecorator)：向组件添加新的职责</li></ul><h4 id="抽象组件类和具体组件类"><a href="#抽象组件类和具体组件类" class="headerlink" title="抽象组件类和具体组件类"></a>抽象组件类和具体组件类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class Component &#123;</span><br><span class="line">    public abstract void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteComponent extends Component &#123;</span><br><span class="line">    public void operation()&#123;</span><br><span class="line">        System.out.println(&quot;ConcreteComponent say&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象装饰器类和具体装饰器类"><a href="#抽象装饰器类和具体装饰器类" class="headerlink" title="抽象装饰器类和具体装饰器类"></a>抽象装饰器类和具体装饰器类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">abstract class Decorator extends Component &#123;</span><br><span class="line">    protected Component component;</span><br><span class="line"></span><br><span class="line">    public Decorator(Component component) &#123;</span><br><span class="line">        this.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation()&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecoratorA extends Decorator &#123;</span><br><span class="line">    public ConcreteDecoratorA(Component component)&#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line">    private void operationFirst()&#123;</span><br><span class="line">        System.out.println(&quot;operationFirst say&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void operationLast()&#123;</span><br><span class="line">        System.out.println(&quot;operationLast say&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        operationFirst();</span><br><span class="line">        super.operation();</span><br><span class="line">        operationLast();</span><br><span class="line">    &#125;</span><br><span class="line">    //新功能</span><br><span class="line">    public void anotherOperation() &#123;</span><br><span class="line">        System.out.println(&quot;another operation&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client&#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        Component c1 = new ConcreteComponent ();   </span><br><span class="line">        Decorator decoratorA = new ConcreteDecoratorA(c1);   </span><br><span class="line">        decoratorA .operation();  </span><br><span class="line">        System.out.println(&quot;------------------------------------------------&quot;);</span><br><span class="line">        Decorator decoratorBandA = new ConcreteDecoratorA(decoratorA);</span><br><span class="line">        decoratorBandA.operation();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">operationFirst say</span><br><span class="line">ConcreteComponent say</span><br><span class="line">operationLast say</span><br><span class="line">------------------------------------------------</span><br><span class="line">operationFirst say</span><br><span class="line">operationFirst say</span><br><span class="line">ConcreteComponent say</span><br><span class="line">operationLast say</span><br><span class="line">operationLast say</span><br></pre></td></tr></table></figure><p>[转载]<a href="https://zhuanlan.zhihu.com/p/25003369" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25003369</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;装饰器模式: 在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="装饰器模式" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
