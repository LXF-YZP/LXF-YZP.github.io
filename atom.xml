<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-20T09:33:49.105Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>volatile</title>
    <link href="http://yoursite.com/2019/09/20/volatile/"/>
    <id>http://yoursite.com/2019/09/20/volatile/</id>
    <published>2019-09-20T09:28:24.000Z</published>
    <updated>2019-09-20T09:33:49.105Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/.com//3807435_1531452406842_12E1F2929DB1B27B02E4730D07717AB7.png" alt></p><ol><li>对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。</li><li>对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</li></ol><p>volatile 变量的内存可见性，是基于内存屏蔽实现的，内存屏蔽也就是一个 CPU 指令。在程序运行的时候，为了提高执行性能，编译器和处理器会对指令进行重排序，JVM 为了保证不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏蔽来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏蔽会告诉编译器和 CPU，不管什么指令都不能和这条内存屏蔽指令重排序。</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p><p>如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。</p><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/.com//3807435_1531452406842_12E1F2929DB1B27B02E4730D07717AB7.png&quot; alt&gt;&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-Trie树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-Trie树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:36:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-Trie树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-二叉树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:33:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-二叉树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-堆/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-堆" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-图/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:35:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-图" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-栈/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:29:10.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-栈" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-散列表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-散列表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:32:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-散列表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-跳表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-跳表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-跳表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-链表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-链表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:29:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-链表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-队列</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-队列/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:29:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-队列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-数组</title>
    <link href="http://yoursite.com/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/05/12/数据结构-数组/</id>
    <published>2019-05-12T11:57:10.000Z</published>
    <updated>2019-05-14T06:44:50.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-数组" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之数组求和</title>
    <link href="http://yoursite.com/2019/05/03/LeetCode%E4%B9%8B%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2019/05/03/LeetCode之数组求和/</id>
    <published>2019-05-03T15:34:34.000Z</published>
    <updated>2019-09-20T07:53:32.418Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定一个整数数组nums和一个目标值target,请你在改数组中找出和为目标值的那两个整数，返回他们的数组下标；</p><p>方法一：</p><pre><code>private static int[] arraySum(int[] nums, int target){    for(int i = 0; i &lt; nums.length; i++){        for (int j = i+1; j &lt; nums.length; j++){            if (nums[i] + nums[j] == target){                return new int[]{i, j};            }        }    }    return null;}public static void main(String[] args) {    int[] arr = new int[]{2, 12, 3, 6, 0, 10};    int target = 9;    int[] ints = arraySum(arr, target);    if (null != ints){        for (int anInt : ints) {            System.out.println(anInt);        }    }}</code></pre><p>方法二：</p><pre><code>public static void main(String[] args) {    int[] arr = new int[]{2, 12, 3, 6, 0, 10};    int target = 9;    int[] ints = arraySum(arr, target);    if (null != ints){        for (int anInt : ints) {            System.out.println(anInt);        }    }}private static int[] arraySum(int[] sums, int target){    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; sums.length; i++) {        if (map.containsKey(target - sums[i])){            return new int[]{map.get(target - sums[i]), i};        }        map.put(sums[i], i);    }    return null;}</code></pre><p>方法一比较暴力，使用的是双层循环，时间复杂度比较高；<br>方法二比较柔和一点，没有采用双循环的方法，复杂度比较低，推荐第一种方法；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：给定一个整数数组nums和一个目标值target,请你在改数组中找出和为目标值的那两个整数，返回他们的数组下标；&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static int[] arraySum(int[] nums, int targ
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构系列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/04/26/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/04/26/volatile关键字/</id>
    <published>2019-04-26T11:17:29.000Z</published>
    <updated>2019-09-20T09:21:27.918Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/.com//3807435_1531452406842_12E1F2929DB1B27B02E4730D07717AB7.png" alt></p><ol><li>对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。</li><li>对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</li></ol><p>volatile 变量的内存可见性，是基于内存屏蔽实现的，内存屏蔽也就是一个 CPU 指令。在程序运行的时候，为了提高执行性能，编译器和处理器会对指令进行重排序，JVM 为了保证不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏蔽来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏蔽会告诉编译器和 CPU，不管什么指令都不能和这条内存屏蔽指令重排序。</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p><p>如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。</p><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/.com//3807435_1531452406842_12E1F2929DB1B27B02E4730D07717AB7.png&quot; alt&gt;&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程volatile" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8Bvolatile/"/>
    
  </entry>
  
  <entry>
    <title>为何非要学数据结构和算法</title>
    <link href="http://yoursite.com/2019/04/22/%E4%B8%BA%E4%BD%95%E9%9D%9E%E8%A6%81%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/22/为何非要学数据结构和算法/</id>
    <published>2019-04-22T11:36:34.000Z</published>
    <updated>2019-09-20T07:54:07.710Z</updated>
    
    <content type="html"><![CDATA[<p>计算机专业里数据结构这门课在大学是必修课，很多程序员在毕业之后都忘得差不多了。总觉得数据结构与算法、操作系统、计算机网络是脱离实际工作的知识。在实际工作中即使你不懂数据结构和算法，照样也可以把代码敲得飞起。那么既然不懂这些也可以，为什么还要学数据结构和算法呢，大概是不想做一个CRUD boy吧!</p><p>只要对编程还有追求，就应该学一下数据结构，这样你就不在是只会写能用的代码了，而是高性能的代码。掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。在我看来数据结构和算法应该算得上是程序员的核心竞争力了，而且学习数据结构和算法可以改变你的思维方式。我大学老师曾经和我们说过程序员有两个是必须要会的，一是数据结构与算法，二是英语。你会其中一个，只能说你走的比较快而已，只有两个都会，你才能飞起来。当初不以为然，工作时间越长，发现老师说的非常对。接下来的一段时间我会持续更新数据结构与算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机专业里数据结构这门课在大学是必修课，很多程序员在毕业之后都忘得差不多了。总觉得数据结构与算法、操作系统、计算机网络是脱离实际工作的知识。在实际工作中即使你不懂数据结构和算法，照样也可以把代码敲得飞起。那么既然不懂这些也可以，为什么还要学数据结构和算法呢，大概是不想做一
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构系列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字总结</title>
    <link href="http://yoursite.com/2019/04/15/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/Synchronized关键字总结/</id>
    <published>2019-04-15T12:04:48.000Z</published>
    <updated>2019-09-20T07:53:24.228Z</updated>
    
    <content type="html"><![CDATA[<p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法，但是其他线程还是可以访问该实例对象的其他非 synchronized 方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1 (当前对象锁是 obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2 (当前对象锁是 obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了。</p><p>1.synchronized用在类中的非静态方法中，synchronized锁住的是对象this，只有调用同一个对象的方法才需要获取锁，并且同一个对象中所有加了synchronized关键字的非静态方法只能一次调用一个。</p><p>2.两个线程用同一个对象分别访问该对象的两个同步方法，会产生互斥。因为synchronized锁针对的是对象，当对象调用一个 synchronized 方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p><p>3.不同对象在两个线程中调用同一个同步方法，不会产生互斥。因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是 new 一个对象，那么就会出现两个空间，两把钥匙；</p><p>1.synchronized用在类中的静态方法中，synchronized锁住的是（类.class），改类中所有加了synchronized的静态方法，一次只能被调用一个。</p><p>2.用类直接在两个线程中调用两个不同的同步方法，会产生互斥。因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有 N 个房间，一把锁，因此房间（同步方法）之间一定是互斥的。<br>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p><p>3.用一个类的静态对象在两个线程中调用静态方法或非静态方法，会产生互斥。<br>解释：因为是一个对象调用，同上。</p><p>4.一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法，不会产生互斥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方
      
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程Synchronized" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8BSynchronized/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="http://yoursite.com/2019/04/15/java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/04/15/java集合/</id>
    <published>2019-04-15T10:38:34.000Z</published>
    <updated>2019-09-20T07:53:57.242Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合大致可以分为 Set、List、Queue 和 Map 四种体系，<br>其中 Set 代表无序、不可重复的集合；<br>List 代表有序、重复的集合；<br>而 Map 则代表具有映射关系的集合；<br>Java 5 又增加了 Queue 体系集合，代表一种队列集合实现。<br>Java 集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进” 该容器中。<br>从 Java 5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。<br>Java 集合和数组的区别：</p><ol><li><p>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。<br>同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。</p></li><li><p>数组元素即可以是基本类型的值，也可以是对象。<br>集合里只能保存对象（实际上只是保存对象的引用变量），<br>基本数据类型的变量要转换成对应的包装类才能放入集合类中。</p></li></ol><p>Java 集合类之间的继承关系:<br>Java 的集合类主要由两个接口派生而出：Collection 和 Map,<br>Collection 和 Map 是 Java 集合框架的根接口。</p><ul><li>Collection<pre><code>-Set    --SortedSet       ---TreeSet    --HashSet       ---LinkedHashSet    --EnumSet -Queue    --PriorityQueue    --Deque       ---ArraryDeque       ---LinkedList -List    --ArrayList       ---AttributeList    --Vector       ---Stack    ---LinkedList</code></pre></li></ul><p>图中，ArrayList,HashSet,LinkedList,TreeSet 是我们经常会有用到的已实现的集合类。<br>list是有序(插入顺序和输出顺序)有重，set无序无重；<br>1.list–&gt;ArrayList,linkedList,Vector介绍：<br>元素都是通过索引的方式访问的，元素都是object子对象；<br>底层实现<br>linkedList是链表，其他两个都是数组；<br>使用场景<br>ArrayList：查询频率高，线程不安全<br>LinkedList：增加删除频率高，线程不安全<br>vector：线程安全</p><p>2.set–&gt;HashSet,TreeSet,LinkedHashSet<br>HashSet是无序的，TreeSet有序遍历成员，LinkedHashSet按照插入顺序遍历，都不允许重复元素；<br>底层实现<br>HashSet是hash表<br>TreeSet是二叉树(红黑树)<br>LinkedHashSet是链表、散列表<br>使用场景<br>HashSet查询最快<br>TreeSet升序排序<br>LinkedHashSet按照插入顺序排序</p><ul><li>Map<pre><code> -SortedMap    --TreeMap -HashMap    --LinkedHashMap-HashTable    --Properties</code></pre></li></ul><p>Map 实现类用于保存具有映射关系的数据。Map 保存的每项数据都是 key-value 对，<br>也就是由 key 和 value 两个值组成。Map 里的 key 是不可重复的，key 用户标识集合里的每项数据.<br>1.Map–&gt;HashMap、TreeMap<br>HashMap底层是hash表，无序，频繁的插入、删除、查询元素<br>TreeMap底层是二叉树(红黑树)，有序，按照键升序遍历输出</p><p>阻塞队列<br>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供的阻塞队列：<br>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br>ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);<br>访问者的公平性是使用可重入锁实现的，代码如下：</p><pre><code>public ArrayBlockingQueue(int capacity, boolean fair) {    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();}</code></pre><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><p>详情请看阻塞队列</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 集合大致可以分为 Set、List、Queue 和 Map 四种体系，&lt;br&gt;其中 Set 代表无序、不可重复的集合；&lt;br&gt;List 代表有序、重复的集合；&lt;br&gt;而 Map 则代表具有映射关系的集合；&lt;br&gt;Java 5 又增加了 Queue 体系集合，代表一
      
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java多线程概念</title>
    <link href="http://yoursite.com/2019/04/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/04/14/java多线程概念/</id>
    <published>2019-04-14T03:39:16.000Z</published>
    <updated>2019-09-20T07:54:01.615Z</updated>
    
    <content type="html"><![CDATA[<p>线程和进程的概念：<br>线程：进程中负责程序执行的执行单元，线程本身依靠程序进行运行；<br>线程是程序中顺序控制流，只能使用分配给程序的资源和环境；<br>进程：执行中的程序，一个进程至少包含一个线程；<br>单线程：程序中只存在一个线程，实际上主方法就是一个主线程；<br>多线程：在一个程序中运行多个任务，目的是更好的使用CPU资源；</p><p>并发与并行的概念：<br>并行：多个CPU实例或者多台机器同时执行一段处理逻辑，是真正的同时；<br>并发：通过CPU的调度算法，让用户看上去同时执行，实际上从CPU操作层面不是真正的同时，<br>并发往往在场景中有公共的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反映系统的处理能力；<br>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu 是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。<br>同步：Java中同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的正确。例如在代码中简单的加入synchronize关键字，在保证结果正确的同时，提高了性能，线程安全优先级高于性能。</p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停的切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下个任务，但是在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务的保存到再加载的过程就是一次上下文切换。</p><p>Java程序是操作系统的一个进程，而线程是进程中创建的贡献进程的资源。多线程主要是利用多处理器实现并发功能的。<br>并发原理：<br>多个线程“同时”运行只是我们感官上的一种表现。事实上线程是并发运行的（时间片轮转进程调度算法），单个CPU的情况下任何一个时间内有且仅有一个进程占有CPU，如果有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，各个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。OS将时间划分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行，而其他线程全部等，只要每个时间片段足够小，用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。所有并发技术不是绝对意义上的“同时发生”。</p><p>单核CPU(单处理器)上，只可能存在并发而不可能存在并行。并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作，每个小时间片执行一个操作，多个操作快速切换执行.</p><p>注意：Java中的多线程是一种抢占机制而不是分时机制。<br>抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。</p><p>Java中线程也是用一个对象(java.lang.Thread)来表示的。<br>每个进程至少有一个线程，作为程序的入口，通常情况下这个线程我们称之为主线程。<br>在Java中，程序的入口是main方法，因此main方法实际上就是运行在主线程中的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程和进程的概念：&lt;br&gt;线程：进程中负责程序执行的执行单元，线程本身依靠程序进行运行；&lt;br&gt;线程是程序中顺序控制流，只能使用分配给程序的资源和环境；&lt;br&gt;进程：执行中的程序，一个进程至少包含一个线程；&lt;br&gt;单线程：程序中只存在一个线程，实际上主方法就是一个主线程；&lt;
      
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java多线程实现" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>hdfs原理</title>
    <link href="http://yoursite.com/2019/04/13/hdfs%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/13/hdfs原理/</id>
    <published>2019-04-13T11:36:47.000Z</published>
    <updated>2019-04-13T11:37:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hadoop原理" scheme="http://yoursite.com/tags/hadoop%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2019/04/13/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/04/13/冒泡排序/</id>
    <published>2019-04-13T11:32:13.000Z</published>
    <updated>2019-04-13T11:33:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://yoursite.com/2019/04/13/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/13/垃圾回收机制/</id>
    <published>2019-04-13T11:10:22.000Z</published>
    <updated>2019-04-13T11:10:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
