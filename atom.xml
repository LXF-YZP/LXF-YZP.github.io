<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-15T02:55:50.136Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别</title>
    <link href="http://yoursite.com/2020/07/13/jdk1.7%E5%92%8C1.8%E4%B8%ADConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/13/jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别/</id>
    <published>2020-07-13T11:57:10.000Z</published>
    <updated>2020-07-15T02:55:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-在-JDK8-与-JDK7-中的区别"><a href="#HashMap-在-JDK8-与-JDK7-中的区别" class="headerlink" title="HashMap 在 JDK8 与 JDK7 中的区别"></a>HashMap 在 JDK8 与 JDK7 中的区别</h3><ul><li>插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。</li><li>JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）</li><li>扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。</li><li>JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移</li></ul><a id="more"></a><h3 id="ConcurrentHashMap-在-JDK7-与-JDK8-中的区别"><a href="#ConcurrentHashMap-在-JDK7-与-JDK8-中的区别" class="headerlink" title="ConcurrentHashMap 在 JDK7 与 JDK8 中的区别"></a>ConcurrentHashMap 在 JDK7 与 JDK8 中的区别</h3><ul><li><p>ConcurrentHashMap 在 jdk8 中初始化采用了延迟初始化策略，他会在第一次执行 put 的时候初始化 table。</p></li><li><p>JDK7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK8 采用 CAS (读)+Synchronized (写) 保证线程安全。</p></li><li><p>锁的粒度：原来是对需要进行数据操作的 Segment 加锁，JDK8 调整为对每个数组元素加锁（Node）。</p></li><li><p>链表转化为红黑树：定位结点的 hash 算法简化会带来弊端，Hash 冲突加剧，因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。</p></li><li><p>查询时间复杂度：从原来的遍历链表 O (n)，变成遍历红黑树 O (logN)。</p></li><li><p>JDK8 推荐使用 mappingCount 方法而不是 size 方法获取当前 map 表的大小，因为这个方法的返回值是 long 类型，size 方法是返回值类型是 int</p></li></ul><h3 id="ConcurrentHashMap-与-HashMap-相比，有以下不同点"><a href="#ConcurrentHashMap-与-HashMap-相比，有以下不同点" class="headerlink" title="ConcurrentHashMap 与 HashMap 相比，有以下不同点"></a>ConcurrentHashMap 与 HashMap 相比，有以下不同点</h3><ul><li>ConcurrentHashMap 线程安全，而 HashMap 非线程安全;</li><li>HashMap 允许 Key 和 Value 为 null，而 ConcurrentHashMap 不允许;</li><li>HashMap 迭代器是强一致性，ConcurrentHashMap 迭代器是弱一致性，HashMap 不允许通过 Iterator 遍历的同时通过 HashMap 修改，而 ConcurrentHashMap 允许该行为，并且该更新对后续的遍历可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-在-JDK8-与-JDK7-中的区别&quot;&gt;&lt;a href=&quot;#HashMap-在-JDK8-与-JDK7-中的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap 在 JDK8 与 JDK7 中的区别&quot;&gt;&lt;/a&gt;HashMap 在 JDK8 与 JDK7 中的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。&lt;/li&gt;
&lt;li&gt;JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）&lt;/li&gt;
&lt;li&gt;扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。&lt;/li&gt;
&lt;li&gt;JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hashmap扩容浅谈</title>
    <link href="http://yoursite.com/2020/07/12/hashmap%E6%89%A9%E5%AE%B9%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/07/12/hashmap扩容浅谈/</id>
    <published>2020-07-12T11:57:10.000Z</published>
    <updated>2020-07-13T09:57:16.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-7-中Hashmap扩容机制"><a href="#Java-7-中Hashmap扩容机制" class="headerlink" title="Java 7 中Hashmap扩容机制"></a>Java 7 中Hashmap扩容机制</h3><h5 id="一、什么时候扩容："><a href="#一、什么时候扩容：" class="headerlink" title="一、什么时候扩容："></a>一、什么时候扩容：</h5><p>扩容必须满足两个条件：<br>1、 存放新值的时候当前已有元素的个数必须大于等于阈值<br>2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</p><a id="more"></a><h5 id="二、下面我们看源码，如下："><a href="#二、下面我们看源码，如下：" class="headerlink" title="二、下面我们看源码，如下："></a>二、下面我们看源码，如下：</h5><p>首先是put()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　　　//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span><br><span class="line">　　　　if (table == EMPTY_TABLE) &#123;</span><br><span class="line">　　　　　　inflateTable(threshold);//如果为空，则初始化</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　//判断key是否为空</span><br><span class="line">　　　　if (key == null)</span><br><span class="line">　　　　　　return putForNullKey(value);//hashmap允许key为空</span><br><span class="line">　　　　</span><br><span class="line">　　　　//计算当前key的哈希值　　　　</span><br><span class="line">　　　　int hash = hash(key);</span><br><span class="line">　　　　//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span><br><span class="line">　　　　int i = indexFor(hash, table.length);</span><br><span class="line">　　　　for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">　　　　　　Object k;</span><br><span class="line">　　　　　　//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span><br><span class="line">　　　　　　if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">　　　　　　　　V oldValue = e.value;</span><br><span class="line">　　　　　　　　e.value = value;</span><br><span class="line">　　　　　　　　e.recordAccess(this);</span><br><span class="line">　　　　　　　　return oldValue;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　modCount++;</span><br><span class="line">　　　　//存放值的具体方法</span><br><span class="line">　　　　addEntry(hash, key, value, i);</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在put()方法中有调用addEntry()方法，这个方法里面是具体的存值，在存值之前还要判断是否需要扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">　　　　//1、判断当前个数是否大于等于阈值</span><br><span class="line">　　　　//2、当前存放是否发生哈希碰撞</span><br><span class="line">　　　　//如果上面两个条件否发生，那么就扩容</span><br><span class="line">　　　　if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　//扩容，并且把原来数组中的元素重新放到新数组中</span><br><span class="line">　　　　　　resize(2 * table.length);</span><br><span class="line">　　　　　　hash = (null != key) ? hash(key) : 0;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">如果需要扩容，调用扩容的方法resize()</span><br></pre></td></tr></table></figure><p>void resize(int newCapacity) {<br>　　　　Entry[] oldTable = table;<br>　　　　int oldCapacity = oldTable.length;<br>　　　　//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作<br>　　　　if (oldCapacity == MAXIMUM_CAPACITY) {<br>　　　　　　threshold = Integer.MAX_VALUE;<br>　　　　　　return;<br>　　　　}</p><p>　　　　Entry[] newTable = new Entry[newCapacity];<br>　　　　// transfer()方法把原数组中的值放到新数组中<br>　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>　　　　//设置hashmap扩容后为新的数组引用<br>　　　　table = newTable;<br>　　　　//设置hashmap扩容新的阈值<br>　　　　threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer()在实际扩容时候把原来数组中的元素放入新的数组中</span><br></pre></td></tr></table></figure><p>void transfer(Entry[] newTable, boolean rehash) {<br>　　　　int newCapacity = newTable.length;<br>　　　　for (Entry&lt;K,V&gt; e : table) {<br>　　　　　　while(null != e) {<br>　　　　　　　　Entry&lt;K,V&gt; next = e.next;<br>　　　　　　　　if (rehash) {<br>　　　　　　　　　　e.hash = null == e.key ? 0 : hash(e.key);<br>　　　　　　　　}<br>　　　　　　　　//通过key值的hash值和新数组的大小算出在当前数组中的存放位置<br>　　　　　　　　int i = indexFor(e.hash, newCapacity);<br>　　　　　　　　e.next = newTable[i];<br>　　　　　　　　newTable[i] = e;<br>　　　　　　　　e = next;<br>　　　　　　}<br>　　　　}<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 三、总结：</span><br><span class="line"></span><br><span class="line">Hashmap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</span><br><span class="line">因为上面这两个条件，所以存在下面这些情况</span><br><span class="line">&gt;&gt; 就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</span><br><span class="line"></span><br><span class="line">&gt;&gt; 当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（虽然hash冲突，但是这时元素个数小于阈值12，并没有同时满足扩容的两个条件。所以不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，也没有同时满足扩容的两个条件，所以叶不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java 8 中Hashmap扩容机制</span><br><span class="line"></span><br><span class="line">##### 一、Java8的扩容机制：</span><br><span class="line">Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：当前存放新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">&gt;&gt;（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,&quot;zhangsan&quot;），而map里面原有数据&lt;&quot;name&quot;,&quot;lisi&quot;&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</span><br><span class="line"></span><br><span class="line">&gt;&gt;（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</span><br><span class="line">##### 二、背景知识：</span><br><span class="line"></span><br><span class="line">　　Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key/value值，还存了后一个Entry对的地址。</span><br><span class="line"></span><br><span class="line">　　Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但是数组的对象以前是Entry对，现在换成了Node对象（可以理解是Entry对，结构一样，存储时也会存key/value键值对、后一个Node的地址），以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树。</span><br><span class="line"></span><br><span class="line">##### 三、源码：</span><br><span class="line"></span><br><span class="line">　　在jdk7中，当new Hashmap()的时候会对对象进行初始化，而jdk8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。</span><br></pre></td></tr></table></figure><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><p>复制代码<br>    /**<br>     * Implements Map.put and related methods<br>     *<br>     * @param hash key值计算传来的下标<br>     * @param key<br>     * @param value<br>     * @param onlyIfAbsent true只是在值为空的时候存储数据，false都存储数据<br>     * @param evict<br>     * @return 返回被覆盖的值，如果没有覆盖则返回null<br>     */<br>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        // 申明entry数组对象tab[]:当前Entry[]对象<br>        Node&lt;K,V&gt;[] tab;<br>        // 申明entry对象p:这里表示存放的单个节点<br>        Node&lt;K,V&gt; p;<br>        // n:为当前Entry对象长度<br>　　　　 // i:为当前存放对象节点的位置下标<br>        int n, i;</p><pre><code>    /**     * 流程判断     * 1、如果当前Node数组(tab)为空，则直接创建(通过resize()创建)，并将当前创建后的长度设置给n     * 2、如果要存放对象所在位置的Node节点为空，则直接将对象存放位置创建新Node，并将值直接存入     * 3、存放的Node数组不为空，且存放的下标节点Node不为空（该Node节点为链表的首节点）     *   1）比较链表的首节点存放的对象和当前存放对象是否为同一个对象，如果是则直接覆盖并将原来的值返回     *   2）如果不是分两种情况     *      （1）存储处节点为红黑树node结构，调用方法putTreeVal()直接将数据插入     *      （2）不是红黑树，则表示为链表，则进行遍历     *          A.如果存入的链表下一个位置为空，则先将值直接存入，存入后检查当前存入位置是否已经大于链表的第8个位置     *              a.如果大于,调用treeifyBin方法判断是扩容 还是 需要将该链表转红黑树（大于8且总数据量大于64则转红黑色，否则对数组进行扩容）     *              b.当前存入位置链表长度没有大于8，则存入成功，终端循环操作。     *          B.如果存入链表的下一个位置有值，且该值和存入对象“一样”，则直接覆盖，并将原来的值返回     *          上面AB两种情况执行完成后，判断返回的原对象是否为空，如果不为空，则将原对象的原始value返回     * 上面123三种情况下，如果没有覆盖原值，则表示新增存入数据，存储数据完成后，size+1,然后判断当前数据量是否大于阈值，     * 如果大于阈值，则进行扩容。     */    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            // 按照红黑树直接将数据存入            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);//该方法判断是扩容还是需要将该链表转红黑树                    break;                }                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 如果不是替换数据存入，而是新增位置存入后，则将map的size进行加1，然后判断容量是否超过阈值，超过则扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treeifyBin()方法判断是扩容还是将当前链表转红黑树</span><br></pre></td></tr></table></figure><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * 从指定hash位置处的链表nodes头部开始，全部替换成红黑树结构。 * 除非整个数组对象（Map集合）数据量很小（小于64），该情况下则通过resize()对这个Map进行扩容，而代替将链表转红黑树的操作。 */final void treeifyBin(HashMap.Node&lt;K,V&gt;[] tab, int hash) {    int n, index; HashMap.Node&lt;K,V&gt; e;    // 如果Map为空或者当前存入数据n（可以理解为map的size()）的数量小于64便进行扩容    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    // 如果size()大于64则将正在存入的该值所在链表转化成红黑树    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        HashMap.TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            HashMap.TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><p>```</p><h5 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h5><p>1）Java 8 在新增数据存入成功后进行扩容<br>2）扩容会发生在两种情况下（满足任意一种条件即发生扩容）：<br>   a 当前存入数据大于阈值即发生扩容<br>   b 存入数据到某一条链表上，此时数据大于8，且总数量小于64即发生扩容<br>3）此外需要注意一点java7是在存入数据前进行判断是否扩容，而java8是在存入数据库在进行扩容的判断。</p><p>ConcurrentHashMap知识参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html" target="_blank" rel="noopener">https://www.cnblogs.com/zerotomax/p/8687425.html</a></p><p>Java8 HashMap扩容可参考：<a href="https://blog.csdn.net/goosson/article/details/81029729" target="_blank" rel="noopener">https://blog.csdn.net/goosson/article/details/81029729</a> （注：该文章中关于Java8 底层数据结构描述不准确，只有当数据量大于64才会有红黑树+链表）</p><p>这里补充一下jdk8关于红黑树和链表的知识：</p><p>　　第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;=7,从0开始，及第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p><p>[参考链接]<a href="https://www.cnblogs.com/yanzige/p/8392142.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanzige/p/8392142.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-7-中Hashmap扩容机制&quot;&gt;&lt;a href=&quot;#Java-7-中Hashmap扩容机制&quot; class=&quot;headerlink&quot; title=&quot;Java 7 中Hashmap扩容机制&quot;&gt;&lt;/a&gt;Java 7 中Hashmap扩容机制&lt;/h3&gt;&lt;h5 id=&quot;一、什么时候扩容：&quot;&gt;&lt;a href=&quot;#一、什么时候扩容：&quot; class=&quot;headerlink&quot; title=&quot;一、什么时候扩容：&quot;&gt;&lt;/a&gt;一、什么时候扩容：&lt;/h5&gt;&lt;p&gt;扩容必须满足两个条件：&lt;br&gt;1、 存放新值的时候当前已有元素的个数必须大于等于阈值&lt;br&gt;2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hashmap中hash方法的一些看法</title>
    <link href="http://yoursite.com/2020/07/11/hashmap%E4%B8%ADhash%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/11/hashmap中hash方法的一些看法/</id>
    <published>2020-07-11T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:19.968Z</updated>
    
    <content type="html"><![CDATA[<p>hashcode一般用 int 来表示，32 位。<br>下面两个 hashcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">只有第 32 位（从右到左）不一样;</span><br></pre></td></tr></table></figure><p>在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.</p><a id="more"></a><p>大家又知道，hashcode 对 8 取模，效果等同于 hashcode &amp; (8 - 1)。</p><p>那么，前面的 A 和 （8 - 1）相与的结果如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">结果为 7，也就是，会放进 array [7]。</span><br></pre></td></tr></table></figure><p>大家再看 B 的计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">虽然 B 的第 32 位为 1,前面的高位，全是 0。</span><br></pre></td></tr></table></figure><p>所以，问题明白了吗，我们计算出来的 hashcode，低位相同，高位不同；但是，因为和我们进行与计算的队友太过垃圾，导致我们出现了 hash 冲突。</p><h5 id="怎么来解决这个问题呢？"><a href="#怎么来解决这个问题呢？" class="headerlink" title="怎么来解决这个问题呢？"></a>怎么来解决这个问题呢？</h5><p>我们能不能把高位也参与计算呢？自然，是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hashmap 中如何优化</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">这里，其实分了 3 个步骤：</span><br><span class="line"></span><br><span class="line">&gt;&gt; 计算 hashcode，作为操作数 1</span><br><span class="line"></span><br><span class="line">&gt;&gt; h = key.hashCode()</span><br><span class="line">&gt;&gt; 将第一步的 hashcode，右移 16 位，作为操作数 2</span><br><span class="line"></span><br><span class="line">&gt;&gt; h &gt;&gt;&gt; 16</span><br><span class="line">&gt;&gt; 操作数 1 和 操作数 2 进行异或操作，得到最终的 hashcode</span><br><span class="line"></span><br><span class="line">还是拿前面的来算，</span><br></pre></td></tr></table></figure><p>0111 1111 1111 1111 1111 1111 1111 1111  ——A<br>0000 0000 0000 0000 0111 1111 1111 1111   —– A &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>这里算出来的结果是 2147450880，再去对 7 进行与运算：</p><p>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 8 -1<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  —— 0<br>这里的 A，算出来，依然在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再拿 B 来算一下：</span><br></pre></td></tr></table></figure><p>1111 1111 1111 1111 1111 1111 1111 1111  —— B<br>0000 0000 0000 0000 1111 1111 1111 1111   —– B &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>1111 1111 1111 1111 0000 0000 0000 0000    — -65536<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 7<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  ——- 0<br>最终算出来为 0，所以，应该放在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里两个虽然算出来都是array[0](只是凑巧)</span><br><span class="line"></span><br><span class="line">下边提供下源代码：</span><br></pre></td></tr></table></figure><p>public class BinaryTest {<br>    public static void main(String[] args) {<br>        int a = 0b00001111111111111111111111111011;<br>        int b = 0b10001101111111111111110111111011;</p><pre><code>    int i = tabAt(32, a);    System.out.println(&quot;index for a:&quot; + i);    i = tabAt(32, b);    System.out.println(&quot;index for b:&quot; + i);}static final int tabAt(int  arraySize, int hash) {    int h = hash;    int finalHashCode = h ^ (h &gt;&gt;&gt; 16);    int i = finalHashCode &amp; (arraySize - 1);    return i;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虽然说，我测试了几个数字，还是有些冲突，但是，你把高 16 位弄进来参与计算，总比你不弄进来计算要好吧。</span><br><span class="line"></span><br><span class="line">大家也可以看看 hashmap 中，hash 方法的注释：</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Computes key.hashCode() and spreads (XORs) higher bits of hash</li><li>to lower.  Because the table uses power-of-two masking, sets of</li><li>hashes that vary only in bits above the current mask will</li><li>always collide. (Among known examples are sets of Float keys</li><li>holding consecutive whole numbers in small tables.)  So we</li><li>apply a transform that spreads the impact of higher bits</li><li>downward. There is a tradeoff between speed, utility, and</li><li>quality of bit-spreading. Because many common sets of hashes</li><li>are already reasonably distributed (so don’t benefit from</li><li>spreading), and because we use trees to handle large sets of</li><li>collisions in bins, we just XOR some shifted bits in the</li><li>cheapest possible way to reduce systematic lossage, as well as</li><li>to incorporate impact of the highest bits that would otherwise</li><li>never be used in index calculations because of table bounds.</li><li>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">里面提到了 2 点：</span><br></pre></td></tr></table></figure></li></ul><p>So we apply a transform that spreads the impact of higher bits downward.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，我们进行了一个转换，把高位的作用利用起来。</span><br></pre></td></tr></table></figure><p>we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as<br>to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们仅仅异或了从高位移动下来的二进制位，用最经济的方式，削减系统性能损失，同样，因为数组大小的限制，导致高位在索引计算中一直用不到，我们通过这种转换将其利用起来。</span><br><span class="line"></span><br><span class="line">#### ConcurrentHashMap 如何优化</span><br><span class="line">在 concurrentHashMap 中，其主要是：</span><br></pre></td></tr></table></figure><p>final V putVal(K key, V value, boolean onlyIfAbsent) {<br>    if (key == null || value == null) throw new NullPointerException();<br>    int hash = spread(key.hashCode());</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里主要是使用 spread 方法来计算 hash 值：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家如果要仔细观察每一步的二进制，可以使用下面的 demo：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    // 1<br>    String s = Integer.toBinaryString(h);<br>    System.out.println(“h:” + s);</p><pre><code>// 2String lower16Bits = Integer.toBinaryString(h &gt;&gt;&gt; 16);System.out.println(&quot;lower16Bits:&quot; + lower16Bits);// 3int temp = h ^ (h &gt;&gt;&gt; 16);System.out.println(&quot;h ^ (h &gt;&gt;&gt; 16):&quot; + Integer.toBinaryString(temp));// 4int result = (temp) &amp; HASH_BITS;System.out.println(&quot;final:&quot; + Integer.toBinaryString(result));return result;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里和 HashMap 相比，多了点东西，也就是多出来了：</span><br></pre></td></tr></table></figure><p>&amp; HASH_BITS;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 (h ^ (h &gt;&gt;&gt; 16)) 计算出来的 hashcode，可能是负数。这里，和 HASH_BITS 进行了相与：</span><br></pre></td></tr></table></figure><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash<br>1111 1111 1111 1111 1111 1111 1111 1111   假设计算出来的hashcode为负数，因为第32位为1<br>0111 1111 1111 1111 1111 1111 1111 1111       0x7fffffff<br>    进行相与<br>0111 …………………………….    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​这里，第 32 位，因为 0x7fffffff 的第 32 位，总为 0，所以相与后的结果，第 32 位也总为 0 ，所以，这样的话，hashcode 就总是正数了，不会是负数。</span><br><span class="line"></span><br><span class="line">***concurrentHashMap 中，node 的 hashcode，为啥不能是负数***</span><br><span class="line">当 hashcode 为正数时，表示该哈希桶为正常的链表结构。</span><br><span class="line">当 hashcode 为负数时，有几种情况：</span><br><span class="line"></span><br><span class="line">***ForwardingNode***</span><br><span class="line">此时，其 hash 值为：</span><br></pre></td></tr></table></figure><p>static final int MOVED     = -1; // hash for forwarding nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当节点为 ForwardingNode 类型时（表示哈希表在扩容进行中，该哈希桶已经被迁移到了新的临时 hash 表，此时，要 get 的话，需要去临时 hash 表查找；要 put 的话，是不行的，会帮助扩容）</span><br><span class="line"></span><br><span class="line">***TreeBin***</span><br></pre></td></tr></table></figure><p>static final int TREEBIN   = -2; // hash for roots of trees</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示，该哈希桶，已经转了红黑树。</span><br><span class="line"></span><br><span class="line">***扩容时的位运算***</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Returns the stamp bits for resizing a table of size n.</li><li>Must be negative when shifted left by RESIZE_STAMP_SHIFT.</li><li>/<br>static final int resizeStamp(int n) {<br>   return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这里，假设，n 为 4，即，hashmap 中数组容量为 4.</span><br><span class="line"></span><br><span class="line">+ 下面这句，求 4 的二进制表示中，前面有多少个 0.</span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(n)</span><br><span class="line"></span><br><span class="line">表示为 32 位后，如下</span><br><span class="line"></span><br><span class="line">0000 0000 0000 0000, 0000 0000 0000 0100</span><br><span class="line"></span><br><span class="line">所以，前面有 29 个 0，即，这里的结果为 29.</span><br><span class="line"></span><br><span class="line">+ (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)</span><br><span class="line"></span><br><span class="line">这一句呢，其中 RESIZE_STAMP_BITS 是个常量，为 16. 相当于，把 1 向左移动 15 位。</span><br><span class="line"></span><br><span class="line">二进制为：</span><br></pre></td></tr></table></figure></li></ul><p>1000 0000 0000 0000   – 1 &lt;&lt; 15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 0000 0000 0001 1101   – 29<br>0000 0000 0000 0000 1000 0000 0000 0000   – 1 &lt;&lt; 15<br>进行或运算<br>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以，最终结果是，</span><br><span class="line">![](hashmap中hash方法的一些看法/aaa.png)</span><br><span class="line"></span><br><span class="line">这个数，换算为 10 进制，为 32972，是个正数。</span><br><span class="line">这个数，有啥用呢？</span><br><span class="line">在 addCount 函数中，当整个哈希表的键值对数量，超过 sizeCtl 时（一般为 0.75 * 数组长度），就会触发扩容。</span><br></pre></td></tr></table></figure><p>java.util.concurrent.ConcurrentHashMap#addCount</p><p>int sc =  sizeCtl;<br>boolean bSumExteedSizeControl = newBaseCount &gt;= (long) sc;<br>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1 处，如果扩容条件满足</span><br><span class="line"></span><br><span class="line">+ 2 处，如果 sc 小于 0，这个 sc 是啥，就是前面说的 sizeCtl，此时应该是等于：0.75 * 数组长度，不可能为负数</span><br><span class="line"></span><br><span class="line">+ 3 处，将 sc（此时为正数），cas 修改为：</span><br></pre></td></tr></table></figure><p>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个数有点意思了，rs 就是前面我们的 resizeStamp 得到的结果。</span><br><span class="line"></span><br><span class="line">按照前面的 demo，我们拿到的结果为：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为</span><br></pre></td></tr></table></figure><p>private static int RESIZE_STAMP_BITS = 16;<br>private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;<br>所以，RESIZE_STAMP_SHIFT 为 16.</p><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。<br>1000 0000 0001 1101 0000 0000 0000 0000 —   左移16位，即   rs &lt;&lt; RESIZE_STAMP_SHIFT<br>1000 0000 0001 1101 0000 0000 0000 0010    – (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)<br>最终，这个数，第一位是 1，说明了，这个数，肯定是负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大家如果看过其他人写的资料，也就知道，当 sizeCtl 为负数时，表示正在扩容。</span><br><span class="line"></span><br><span class="line">所以，这里</span><br></pre></td></tr></table></figure><p>if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这句话就是，如果当前线程成功地，利用 cas，将 sizeCtl 从正数，变成负数，就可以进行扩容。</span><br><span class="line"></span><br><span class="line">扩容时，其他线程怎么执行</span><br></pre></td></tr></table></figure><p>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        // 2.1<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        // 2.2<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><pre><code>此时，因为上面的线程触发了扩容，sc 已经变成了负数了，此时，新的线程进来，会判断 2 处。2 处是满足的，会进入 2.1 处判断，这里的部分条件看不懂，大概是：扩容已经结束，就不再执行，直接 break否则，进入 2.2 处，辅助扩容，同时，把 sc 变成 sc + 1，增加扩容线程数。[参考链接]http://iambigboss.top/post/73353_1_1.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashcode一般用 int 来表示，32 位。&lt;br&gt;下面两个 hashcode:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0111 1111 1111 1111 1111 1111 1111 1111  ------A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1111  ------B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;只有第 32 位（从右到左）不一样;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2020/07/10/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/10/HashMap详解/</id>
    <published>2020-07-10T11:57:10.000Z</published>
    <updated>2020-07-15T02:45:13.929Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//默认的初始化容量为16，必须是2的n次幂</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">//最大容量为 2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。</span><br><span class="line">//为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。</span><br><span class="line">//若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，</span><br><span class="line">//若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">//当红黑树上的元素个数，减少到6个时，就退化为链表</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。</span><br><span class="line">//这是为了避免，数组扩容和树化阈值之间的冲突。</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">//存放所有Node节点的数组</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">//存放所有的键值对</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">//map中的实际键值对个数，即数组中元素个数</span><br><span class="line">transient int size;</span><br><span class="line">//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。</span><br><span class="line">//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。</span><br><span class="line">transient int modCount;</span><br><span class="line">//数组扩容阈值</span><br><span class="line">int threshold;</span><br><span class="line">//加载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line">//普通单向链表节点类</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span><br><span class="line">final int hash;</span><br><span class="line">final K key;</span><br><span class="line">V value;</span><br><span class="line">//指向单链表的下一个节点</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">this.hash = hash;</span><br><span class="line">this.key = key;</span><br><span class="line">this.value = value;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//转化为红黑树的节点类</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">//当前节点的父节点</span><br><span class="line">TreeNode&lt;K,V&gt; parent;  </span><br><span class="line">//左孩子节点</span><br><span class="line">TreeNode&lt;K,V&gt; left;</span><br><span class="line">//右孩子节点</span><br><span class="line">TreeNode&lt;K,V&gt; right;</span><br><span class="line">//指向前一个节点</span><br><span class="line">TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">//当前节点是红色或者黑色的标识</span><br><span class="line">boolean red;</span><br><span class="line">TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">super(hash, key, val, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="hash-计算原理"><a href="#hash-计算原理" class="headerlink" title="hash()计算原理"></a>hash()计算原理</h4><p>前面 put 方法中说到，需要先把当前 key 进行哈希处理，我们看下这个方法是怎么实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，会先判断 key 是否为空，若为空则返回 0。这也说明了 hashMap 是支持 key 传 null 的。若非空，则先计算 key 的 hashCode 值，赋值给 h，然后把 h 右移 16 位，并与原来的 h 进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>我们知道，hashCode () 方法继承自父类 Object，它返回的是一个 int 类型的数值，可以保证同一个应用单次执行的每次调用，返回结果都是相同的（这个说明可以在 hashCode 源码上找到），这就保证了 hash 的确定性。在此基础上，再进行某些固定的运算，肯定结果也是可以确定的。</p><p>我随便运行一段程序，把它的 hashCode 的二进制打印出来，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    int hash = o.hashCode();</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">    System.out.println(Integer.toBinaryString(hash));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//1836019240</span><br><span class="line">//1101101011011110110111000101000</span><br></pre></td></tr></table></figure><p>然后，进行 (h = key.hashCode ()) ^ (h &gt;&gt;&gt; 16) 这一段运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//h原来的值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//无符号右移16位，其实相当于把低位16位舍去，只保留高16位</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">//然后高16位和原 h进行异或运算</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">^</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">=</span><br><span class="line">0110 1101 0110 1111 0000 0011 0100 0111</span><br></pre></td></tr></table></figure><p>可以看到，其实相当于，我们把高 16 位值和当前 h 的低 16 位进行了混合，这样可以尽量保留高 16 位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p><strong>(n-1) &amp; hash 作用</strong><br>//②<br>//这是 put 方法中用来根据hash()值寻找在数组中的下标的逻辑，<br>//n为数组长度， hash为调用 hash()方法混合处理之后的hash值。<br>i = (n - 1) &amp; hash<br>我们知道，如果给定某个数值，去找它在某个数组中的下标位置时，直接用模运算就可以了（假设数组值从 0 开始递增）。如，我找 14 在数组长度为 16 的数组中的下标，即为 14 % 16，等于 14 。 18 的位置即为 18%16，等于 2。</p><p>而②中，就是取模运算的位运算形式。以 18%16 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//18的二进制</span><br><span class="line">0001 0010</span><br><span class="line">//16 -1 即 15的二进制</span><br><span class="line">0000 1111</span><br><span class="line">//与运算之后的结果为</span><br><span class="line">0000 0010</span><br><span class="line">// 可以看到，上边的结果转化为十进制就是 2 。</span><br><span class="line">//其实我们会发现一个规律，因为n是2的n次幂，因此它的二进制表现形式肯定是类似于</span><br><span class="line">0001 0000</span><br><span class="line">//这样的形式，只有一个位是1，其他位都是0。而它减 1 之后的形式就是类似于</span><br><span class="line">0000 1111 </span><br><span class="line">//这样的形式，高位都是0，低位都是1，因此它和任意值进行与运算，结果值肯定在这个区间内</span><br><span class="line">0000 0000  ~  0000 1111</span><br><span class="line">//也就是0到15之间，（以n为16为例）</span><br><span class="line">//因此，这个运算就可以实现取模运算，而且位运算还有个好处，就是速度比较快。</span><br></pre></td></tr></table></figure><p><strong>为什么高低位异或运算可以减少哈希碰撞</strong></p><p>我们想象一下，假如用 key 原来的 hashCode 值，直接和 (n-1) 进行与运算来求数组下标，而不进行高低位混合运算，会产生什么样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//例如我有另外一个h2，和原来的 h相比较，高16位有很大的不同，但是低16位相似度很高，甚至相同的话。</span><br><span class="line">//原h值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//另外一个h2值</span><br><span class="line">0100 0101 1110 1011 0110 0110 0010 1000</span><br><span class="line">// n -1 ,即 15 的二进制</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">//可以发现 h2 和 h 的高位不相同，但是低位相似度非常高。</span><br><span class="line">//他们分别和 n -1 进行与运算时，得到的结果却是相同的。（此处n假设为16）</span><br><span class="line">//因为 n-1 的高16位都是0，不管 h 的高 16 位是什么，与运算之后，都不影响最终结果，高位一定全是 0</span><br><span class="line">//因此，哈希碰撞的概率就大大增加了，并且 h 的高16 位特征全都丢失了。</span><br></pre></td></tr></table></figure><p>有同学可能就会有疑问了，我进行高低 16 位混合运算，是可以的，这样可以保证尽量减少高区位的特征。那么，为什么选择用异或运算呢，我用与、或、非运算不行吗？</p><p>这是有一定的道理的。我们看一个表格，就能明白了。</p><ul><li><p>与运算，0和1的比例3：1<br>0 1 0 1<br>&amp; 1 0 1 0<br>0 0 0 1</p></li><li><p>或运算，0和1的比例1：3<br>0 1 0 1<br>| 1 0 1 0<br>1 1 0 1</p></li><li><p>异或运算，0和1的比例1：1<br>0 1 0 1<br>^ 1 0 0 1<br>1 1 0 0</p></li></ul><p>可以看到两个值进行与运算，结果会趋向于 0；或运算，结果会趋向于 1；而只有异或运算，0 和 1 的比例可以达到 1:1 的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</p><p>所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了。</p><p>以上，就是为什么要对一个 hash 值进行高低位混合，并且选择异或运算来混合的原因。</p><h4 id="如何确保-key-的唯一性"><a href="#如何确保-key-的唯一性" class="headerlink" title="如何确保 key 的唯一性"></a>如何确保 key 的唯一性</h4><p>HashMap 中不允许存在相同的 key 的，那怎么保证 key 的唯一性呢，判断的代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure><p>首先通过 hash 算法算出的值必须相等，算出的结果是 int，所以可以用 == 符号判断。只是这个条件可不行，要知道哈希碰撞是什么意思，有可能两个不一样的 key 最后产生的 hash 值是相同的。</p><p>并且待插入的 key == 当前索引已存在的 key，或者 待插入的 key.equals (当前索引已存在的 key)，注意 == 和 equals 是或的关系。== 符号意味着这是同一个对象， equals 用来确定两个对象内容相同。</p><p>如果 key 是基本数据类型，比如 int，那相同的值肯定是相等的，并且产生的 hashCode 也是一致的。</p><p>String 类型算是最常用的 key 类型了，我们都知道相同的字符串产生的 hashCode 也是一样的，并且字符串可以用 equals 判断相等。</p><p>但是如果用引用类型当做 key 呢，比如我定义了一个 MoonKey 作为 key 值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MoonKey &#123;</span><br><span class="line"></span><br><span class="line">    private String keyTile;</span><br><span class="line"></span><br><span class="line">    public String getKeyTile() &#123;</span><br><span class="line">        return keyTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyTile(String keyTile) &#123;</span><br><span class="line">        this.keyTile = keyTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        MoonKey moonKey = (MoonKey) o;</span><br><span class="line">        return Objects.equals(keyTile, moonKey.keyTile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用下面的代码进行两次添加，你说 size 的长度是 1 还是 2 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MoonKey, String&gt; m = new HashMap&lt;&gt;();</span><br><span class="line">MoonKey moonKey = new MoonKey();</span><br><span class="line">moonKey.setKeyTile(&quot;1&quot;);</span><br><span class="line">MoonKey moonKey1 = new MoonKey();</span><br><span class="line">moonKey1.setKeyTile(&quot;1&quot;);</span><br><span class="line">m.put(moonKey, &quot;1&quot;);</span><br><span class="line">m.put(moonKey1, &quot;2&quot;);</span><br><span class="line">System.out.println(hash(moonKey));</span><br><span class="line">System.out.println(hash(moonKey1));</span><br><span class="line">System.out.println(m.size());</span><br></pre></td></tr></table></figure><p>答案是 2 ，为什么呢，因为 MoonKey 没有重写 hashCode 方法，导致 moonkey 和 moonKey1 的 hash 值不可能一样，当不重写 hashCode 方法时，默认继承自 Object 的 hashCode 方法，而每个 Object 对象的 hash 值都是独一无二的。</p><p>划重点，正确的做法应该是加上 hashCode 的重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">  return Objects.hash(keyTile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是为什么要求重写 equals 方法的同时，也必须重写 hashCode 方法的原因之一。 如果两个对象通过调用 equals 方法是相等的，那么这两个对象调用 hashCode 方法必须返回相同的整数。有了这个基础才能保证 HashMap 或者 HashSet 的 key 唯一。</p><p>[参考链接]<a href="https://www.cnblogs.com/fengzheng/p/13180526.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengzheng/p/13180526.html</a></p><h4 id="tableSizeFor-源码："><a href="#tableSizeFor-源码：" class="headerlink" title="tableSizeFor()源码："></a>tableSizeFor()源码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">/**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> */</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法被调用的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">   </span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 都是 2 的幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂（initialCapacity 如果就是 2 的幂，则返回的还是这个数）。</p><h5 id="下面分析这个算法："><a href="#下面分析这个算法：" class="headerlink" title="下面分析这个算法："></a>下面分析这个算法：</h5><p>首先，为什么要对 cap 做减 1 操作。int n = cap - 1;<br>这是为了防止，cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 又没有执行这个减 1 操作，则执行完后面的几条无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。</p><h5 id="下面看看这几个无符号右移操作："><a href="#下面看看这几个无符号右移操作：" class="headerlink" title="下面看看这几个无符号右移操作："></a>下面看看这几个无符号右移操作：</h5><p>如果 n 这时为 0 了（经过了 cap-1 之后），则经过后面的几次无符号右移依然是 0，最后返回的 capacity 是 1（最后有个 n+1 的操作）。<br>这里只讨论 n 不等于 0 的情况。</p><h6 id="第一次右移"><a href="#第一次右移" class="headerlink" title="第一次右移"></a>第一次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 1;</span><br></pre></td></tr></table></figure><p>由于 n 不等于 0，则 n 的二进制表示中总会有一 bit 为 1，这时考虑最高位的 1。通过无符号右移 1 位，则将最高位的 1 右移了 1 位，再做或操作，使得 n 的二进制表示中与最高位的 1 紧邻的右边一位也为 1，如 000011xxxxxx。</p><h6 id="第二次右移"><a href="#第二次右移" class="headerlink" title="第二次右移"></a>第二次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 2;</span><br></pre></td></tr></table></figure><p>注意，这个 n 已经经过了 n |= n &gt;&gt;&gt; 1; 操作。假设此时 n 为 000011xxxxxx ，则 n 无符号右移两位，会将最高位两个连续的 1 右移两位，然后再与原来的 n 做或操作，这样 n 的二进制表示的高位中会有 4 个连续的 1。如 00001111xxxxxx 。</p><h6 id="第三次右移"><a href="#第三次右移" class="headerlink" title="第三次右移"></a>第三次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 4;</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的 4 个 1，右移 4 位，再做或操作，这样 n 的二进制表示的高位中会有 8 个连续的 1。如 00001111 1111xxxxxx 。</p><h6 id="以此类推"><a href="#以此类推" class="headerlink" title="以此类推"></a>以此类推</h6><p>注意，容量最大也就是 32bit 的正数，因此最后 n |= n &gt;&gt;&gt; 16; ，最多也就 32 个 1（但是这已经是负数了。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY (2 ^ 30)，则取 MAXIMUM_CAPACITY。如果等于 MAXIMUM_CAPACITY (2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大 30 个 1，不会大于等于 MAXIMUM_CAPACITY。30 个 1，加 1 之后得 2 ^ 30） 。</p><h5 id="举一个例子说明下吧。"><a href="#举一个例子说明下吧。" class="headerlink" title="举一个例子说明下吧。"></a>举一个例子说明下吧。</h5><p><img src="/2020/07/10/HashMap详解/aaa.png" alt></p><p>注意，得到的这个 capacity 却被赋值给了 threshold。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>开始以为这个是个 Bug，感觉应该这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span><br></pre></td></tr></table></figure><p>这样才符合 threshold 的意思（当 HashMap 的 size 到达 threshold 这个阈值时会扩容）。<br>但是，请注意，在构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算.</p><h4 id="resize-扩容机制"><a href="#resize-扩容机制" class="headerlink" title="resize() 扩容机制"></a>resize() 扩容机制</h4><p>在上边 put 方法中，我们会发现，当数组为空的时候，会调用 resize 方法，当数组的 size 大于阈值的时候，也会调用 resize方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">//旧数组</span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">//旧数组的容量</span><br><span class="line">int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">//旧数组的扩容阈值，注意看，这里取的是当前对象的 threshold 值，下边的第2种情况会用到。</span><br><span class="line">int oldThr = threshold;</span><br><span class="line">//初始化新数组的容量和阈值，分三种情况讨论。</span><br><span class="line">int newCap, newThr = 0;</span><br><span class="line">//1.当旧数组的容量大于0时，说明在这之前肯定调用过 resize扩容过一次，才会导致旧容量不为0。</span><br><span class="line">//为什么这样说呢，之前我在 tableSizeFor 卖了个关子，需要注意的是，它返回的值是赋给了 threshold 而不是 capacity。</span><br><span class="line">//我们在这之前，压根就没有在任何地方看到过，它给 capacity 赋初始值。</span><br><span class="line">if (oldCap &gt; 0) &#123;</span><br><span class="line">//容量达到了最大值</span><br><span class="line">if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line">return oldTab;</span><br><span class="line">&#125;</span><br><span class="line">//新数组的容量和阈值都扩大原来的2倍</span><br><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line"> oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">&#125;</span><br><span class="line">//2.到这里，说明 oldCap &lt;= 0，并且 oldThr(threshold) &gt; 0，这就是 map 初始化的时候，第一次调用 resize的情况</span><br><span class="line">//而 oldThr的值等于 threshold，此时的 threshold 是通过 tableSizeFor 方法得到的一个2的n次幂的值(我们以16为例)。</span><br><span class="line">//因此，需要把 oldThr 的值，也就是 threshold ，赋值给新数组的容量 newCap，以保证数组的容量是2的n次幂。</span><br><span class="line">//所以我们可以得出结论，当map第一次 put 元素的时候，就会走到这个分支，把数组的容量设置为正确的值（2的n次幂)</span><br><span class="line">//但是，此时 threshold 的值也是2的n次幂，这不对啊，它应该是数组的容量乘以加载因子才对。别着急，这个会在③处理。</span><br><span class="line">else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">newCap = oldThr;</span><br><span class="line">//3.到这里，说明 oldCap 和 oldThr 都是小于等于0的。也说明我们的map是通过默认无参构造来创建的，</span><br><span class="line">//于是，数组的容量和阈值都取默认值就可以了，即 16 和 12。</span><br><span class="line">else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line">//③ 这里就是处理第2种情况，因为只有这种情况 newThr 才为0，</span><br><span class="line">//因此计算 newThr（用 newCap即16 乘以加载因子 0.75，得到 12） ，并把它赋值给 threshold</span><br><span class="line">if (newThr == 0) &#123;</span><br><span class="line">float ft = (float)newCap * loadFactor;</span><br><span class="line">newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">//赋予 threshold 正确的值，表示数组下次需要扩容的阈值（此时就把原来的 16 修正为了 12）。</span><br><span class="line">threshold = newThr;</span><br><span class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line">//如果原来的数组不为空，那么我们就需要把原来数组中的元素重新分配到新的数组中</span><br><span class="line">//如果是第2种情况，由于是第一次调用resize，此时数组肯定是空的，因此也就不需要重新分配元素。</span><br><span class="line">if (oldTab != null) &#123;</span><br><span class="line">//遍历旧数组</span><br><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">//取到当前下标的第一个元素，如果存在，则分三种情况重新分配位置</span><br><span class="line">if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">oldTab[j] = null;</span><br><span class="line">//1.如果当前元素的下一个元素为空，则说明此处只有一个元素</span><br><span class="line">//则直接用它的hash()值和新数组的容量取模就可以了，得到新的下标位置。</span><br><span class="line">if (e.next == null)</span><br><span class="line">newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">//2.如果是红黑树结构，则拆分红黑树，必要时有可能退化为链表</span><br><span class="line">else if (e instanceof TreeNode)</span><br><span class="line">((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">//3.到这里说明，这是一个长度大于 1 的普通链表，则需要计算并</span><br><span class="line">//判断当前位置的链表是否需要移动到新的位置</span><br><span class="line">else &#123; // preserve order</span><br><span class="line">// loHead 和 loTail 分别代表链表旧位置的头尾节点</span><br><span class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">// hiHead 和 hiTail 分别代表链表移动到新位置的头尾节点</span><br><span class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">do &#123;</span><br><span class="line">next = e.next;</span><br><span class="line">//如果当前元素的hash值和oldCap做与运算为0，则原位置不变</span><br><span class="line">if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">if (loTail == null)</span><br><span class="line">loHead = e;</span><br><span class="line">else</span><br><span class="line">loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">&#125;</span><br><span class="line">//否则，需要移动到新的位置</span><br><span class="line">else &#123;</span><br><span class="line">if (hiTail == null)</span><br><span class="line">hiHead = e;</span><br><span class="line">else</span><br><span class="line">hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while ((e = next) != null);</span><br><span class="line">//原位置不变的一条链表，数组下标不变</span><br><span class="line">if (loTail != null) &#123;</span><br><span class="line">loTail.next = null;</span><br><span class="line">newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line">//移动到新位置的一条链表，数组下标为原下标加上旧数组的容量</span><br><span class="line">if (hiTail != null) &#123;</span><br><span class="line">hiTail.next = null;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="你一般用什么作为HashMap的key"><a href="#你一般用什么作为HashMap的key" class="headerlink" title="你一般用什么作为HashMap的key?"></a>你一般用什么作为HashMap的key?</h5><p>一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</p><p>(1)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。<br>(2)因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</p><h5 id="我用可变类当HashMap的key有什么问题"><a href="#我用可变类当HashMap的key有什么问题" class="headerlink" title="我用可变类当HashMap的key有什么问题?"></a>我用可变类当HashMap的key有什么问题?</h5><p>hashcode可能发生改变，导致put进去的值，无法get出，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">Object objectValue = new Object();</span><br><span class="line">changeMap.put(list, objectValue);</span><br><span class="line">System.out.println(changeMap.get(list));</span><br><span class="line">list.add(&quot;hello world&quot;);//hashcode发生了改变</span><br><span class="line">System.out.println(changeMap.get(list));</span><br></pre></td></tr></table></figure><p>输出值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@74a14482</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/129724004" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/129724004</a><br>[参考链接]<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br>[参考链接]<a href="https://www.lizenghai.com/archives/65376.html" target="_blank" rel="noopener">https://www.lizenghai.com/archives/65376.html</a><br><a href="https://my.oschina.net/u/2307589/blog/1800587" target="_blank" rel="noopener">https://my.oschina.net/u/2307589/blog/1800587</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//默认的初始化容量为16，必须是2的n次幂&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//最大容量为 2^30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int TREEIFY_THRESHOLD = 8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//当红黑树上的元素个数，减少到6个时，就退化为链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int UNTREEIFY_THRESHOLD = 6;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//这是为了避免，数组扩容和树化阈值之间的冲突。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int MIN_TREEIFY_CAPACITY = 64;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//存放所有Node节点的数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Node&amp;lt;K,V&amp;gt;[] table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//存放所有的键值对&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//map中的实际键值对个数，即数组中元素个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient int size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient int modCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//数组扩容阈值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int threshold;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//加载因子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;final float loadFactor;					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//普通单向链表节点类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	final int hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	final K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	V value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//指向单链表的下一个节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.hash = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转化为红黑树的节点类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//当前节点的父节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; parent;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//左孩子节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//右孩子节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//指向前一个节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//当前节点是红色或者黑色的标识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	boolean red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		super(hash, key, val, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://yoursite.com/2020/07/09/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/09/ThreadLocal详解/</id>
    <published>2020-07-09T11:57:10.000Z</published>
    <updated>2020-07-09T11:14:41.873Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/07/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/07/ConcurrentHashMap详解/</id>
    <published>2020-07-07T11:57:10.000Z</published>
    <updated>2020-07-15T07:18:50.606Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>ConcurrentHashMap 是 HashMap 的线程安全版本；</li><li>不允许 [key,value] 为 null;</li><li>比 Hashtable 锁粒度更细；</li><li>采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；</li><li>负载因子 0.75;</li><li>默认初始化容量 16;</li><li>put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；</li><li>put 时出现 hash 冲突，则采用 synchronized;</li><li>查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；</li><li>ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;</li></ul><a id="more"></a><h4 id="效率低下的-HashTable-容器"><a href="#效率低下的-HashTable-容器" class="headerlink" title="效率低下的 HashTable 容器"></a>效率低下的 HashTable 容器</h4><p>HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下。<br>因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><ul><li>什么时候会触发扩容</li></ul><ol><li>链表转换为红黑树时 (链表节点个数达到 8 个可能会转换为红黑树)。如果转换时 map 长度小于 64 则直接扩容一倍，不转化为红黑树。如果此时 map 长度大于 64，则不会扩容，直接进行链表转红黑树的操作。(即链表长度大于等于8且map的长度大于64才会将链表转换为红黑树)</li><li>map 中总节点数大于阈值 (即大于 map 长度的 0.75 倍) 时会进行扩容。</li></ol><ul><li>如何扩容</li></ul><ol><li>创建一个新的 map，是原先 map 的两倍。注意此过程是单线程创建的；</li><li>复制旧的 map 到新的 map 中。注意此过程是多线程并发完成。（将 map 按照线程数量平均划分成多个相等区域，每个线程负责一块区域的复制任务）；</li></ol><h4 id="成员变量解析"><a href="#成员变量解析" class="headerlink" title="成员变量解析"></a>成员变量解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile Node&lt;K,V&gt;[] table</span><br></pre></td></tr></table></figure><p>默认为 null，初始化发生在第一次插入操作，默认大小为 16 的数组，用来存储 Node 节点数据，扩容时大小总是 2 的幂次方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable</span><br></pre></td></tr></table></figure><p>默认为 null，扩容时新生成的数组，其大小为原数组的两倍。</p><ul><li>ForwardingNode<br>一个特殊的 Node 节点，hash 值为 - 1，其中存储 nextTable 的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MOVED = -1</span><br></pre></td></tr></table></figure><p>扩容节点的 hash 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl</span><br></pre></td></tr></table></figure><p>默认为 0，用来控制 table 的初始化和扩容操作，具体应用在后续会体现出来。<br>-1 代表 table 正在初始化<br>-N 表示有 N-1 个线程正在进行扩容操作<br>其余情况：<br>(1) 如果 table 未初始化，表示 table 需要初始化的大小。<br>(2) 如果 table 初始化完成，表示 table 的容量，默认是 table 大小的 0.75 倍，居然用这个公式算 0.75（n - (n &gt;&gt;&gt; 2)）—-(即n-n/4)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe U</span><br></pre></td></tr></table></figure><p>在 ConcurrentHashMap 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层 CMPXCHG 指令实现。CAS (V,O,N) 核心思想为： 若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用 CAS 是通过 sun.misc.Unsafe 类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 java 中的 “指针”。该成员变量的获取是在静态代码块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">.......</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-类相关方法"><a href="#Unsafe-类相关方法" class="headerlink" title="Unsafe 类相关方法"></a>Unsafe 类相关方法</h4><p>ConcurrentHashMap 废弃了分段锁，改用 CAS + Synchronized + valatile 保证线程安全，而 Java 主要通过 Unsafe 类实现 CAS，因此源代码大量使用了 Unsafe 类的三个 CAS 方法，如下：</p><ul><li>compareAndSwapObject(Object o, long offset, Object expected, Object x);</li><li>compareAndSwapInt(Object o, long offset, int expected, int x);</li><li>compareAndSwapLong(Object o, long offset, long expected, long x);<br>这些方法非常相似，区别只是参数 expected 和 x 的类型。它们表达的意思是，如果对象 o 在 offset 位置的值是 expected，则把值修改为 x，否则不修改。其中 o 是给定的对象，offset 表示对象内存偏移量，expected 表示当前位置的期望值，x 表示修改后的新值。<br>此外，ConcurrentHashMap 封装了三个数组元素访问方法，底层依然是调用 Unsafe 类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//从主存获取tab[i]，避免读到脏数据</span><br><span class="line">static final  Node tabAt(Node[] tab, int i) &#123;</span><br><span class="line">    return (Node)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值从c改成v</span><br><span class="line">static final  boolean casTabAt(Node[] tab, int i,</span><br><span class="line">                                    Node c, Node v) &#123;</span><br><span class="line">    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值v写到主存</span><br><span class="line">static final  void setTabAt(Node[] tab, int i, Node v) &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>带有并行度(concurrencyLevel)的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">            initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">        //initialCapacity这是想存储的容量，size类似初始化的容量</span><br><span class="line">        long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method" target="_blank" rel="noopener">https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//onlyIfAbsent表示key不存在才插入，存在则不更新</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap-中，是怎么去初始化底层数组的"><a href="#ConcurrentHashMap-中，是怎么去初始化底层数组的" class="headerlink" title="ConcurrentHashMap 中，是怎么去初始化底层数组的"></a>ConcurrentHashMap 中，是怎么去初始化底层数组的</h4><p>在我们用无参构造函数，去 new 一个 ConcurrentHashMap 时，此时还不会去创建底层数组，这个是一个小优化。什么时候创建数组呢，是在我们第一次去 put 的时候。<br>put 的时候，会调用 putVal。</p><p>其中，putVal 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">     // 1</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">         // 2</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br></pre></td></tr></table></figure><ul><li>1 处，把 field table，赋值给局部变量 tab</li><li>2 处，如果 tab 为 null，则进行 initTable 初始化</li></ul><p><strong><em>这个 2 处，在多线程 put 的时候，是可能多个线程同时进来的。有并发问题。</em></strong></p><p>我们接下来，看看 initTable 是怎么解决这个问题的，毕竟，我们 new 数组，只 new 一次即可，new 那么多次，没用，对性能有损耗。所以，这里面肯定会多线程争夺初始化权利的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl;</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line">    */</span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab;</span><br><span class="line">     int sc;</span><br><span class="line">     </span><br><span class="line">     // 0</span><br><span class="line">       while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">         // 1</span><br><span class="line">           if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); // lost initialization race; just spin</span><br><span class="line">         // 2</span><br><span class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 // 3</span><br><span class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                     // 4</span><br><span class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                 // 5</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">             </span><br><span class="line">           &#125;// end if</span><br><span class="line">         </span><br><span class="line">       &#125;// end while</span><br><span class="line">       return tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，这里把 sizeCtl，赋值给局部变量 sc。这里的 sizeCtl 是一个很重要的 field，当我们 new 完之后，默认这个字段，要么为 0，要么为准备创建的底层数组的长度。<br>这里去判断是否小于 0，那肯定不满足，小于 0，会是什么意思？当某个线程，抢到了这个 initTable 中的底层数组的创建权利时，就会把 sizeCtl 改为 -1。<br>所以，这里的意思是，看看是否已经有其他线程在初始化了，如果已经有了，则直接调用：<br>Thread.yield();<br>这个方法的意思是，暗示操作系统，自己准备放弃 cpu；但操作系统，自有它自己的线程调度规则，所以，这个方法可能没什么效果；我们业务代码，这里一般可以修改为 Thread.sleep。<br>这个方法调用完成后，后续也没有其他代码，所以会直接跳转到循环开始处（0 处代码），判断 table 是否初始化 ok 了，如果没有 ok，则会继续进来。</p></li><li><p>2 处，使用 cas，如果此时，sizeCtl 的值等于 sc 的值，就修改 sizeCtl 为 -1；如果成功，则返回 true，进入 3 处<br>否则，会跳转到 0 处，继续循环。</p></li><li><p>3 处，虽然抢到了控制权，但是这里还是要再判断一下，不然可能出现重复初始化，即，不加这一行，4 处的代码，会被重复执行</p></li><li><p>4 处开始，这里去执行真正的初始化逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">// 1</span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">// 2</span><br><span class="line">table = tab = nt;</span><br><span class="line">sc = n - (n &gt;&gt;&gt; 2);</span><br></pre></td></tr></table></figure></li></ul><p>这里的 1 处，new 数组；2 处，赋值给 field：table；此时，因为 table 这个 field 是 volatile 修饰的，所以其他线程会马上感知到。0 处代码就不会为 true 了，就不会继续循环了。</p><ul><li>5 处，修改 sizeCtl 为正数。</li></ul><p>这里说下，为啥要加 3 处的那个判断。</p><p>现在，假设线程 A，在初始化完成后，走到了 5 处，修改了 sizeCtl 为正数；而线程 B，刚好执行 1 处代码：</p><p>// 1<br>if ((sc = sizeCtl) &lt; 0)<br>那肯定，1 处就不满足了；然后就会进到 2 处，cas 修改成功，进行初始化。没有 3 处判断的话，就会重复初始化。</p><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>1.判断键值是否为 null，为 null 抛出异常。<br>2.调用 spread() 方法计算 key 的 hashCode () 获得哈希地址，这个 HashMap 相似。<br>3.如果当前 table 为空，则初始化 table，需要注意的是这里并没有加 synchronized，也就是允许多个线程去尝试初始化 table，但是在初始化函数里面使用了 CAS 保证只有一个线程去执行初始化过程。<br>4.使用 容量大小 - 1 &amp; 哈希地址 计算出待插入键值的下标，如果该下标上的 bucket 为 null，则直接调用实现 CAS 原子性操作的 casTabAt() 方法将节点插入到 table 中，如果插入成功则完成 put 操作，结束返回。插入失败 (被别的线程抢先插入了) 则继续往下执行。<br>5.如果该下标上的节点 (头节点) 的哈希地址为 - 1，代表需要扩容，该线程执行 helpTransfer() 方法协助扩容。<br>6.如果该下标上的 bucket 不为空，且又不需要扩容，则进入到 bucket 中，同时锁住这个 bucket，注意只是锁住该下标上的 bucket 而已，其他的 bucket 并未加锁，其他线程仍然可以操作其他未上锁的 bucket，这个就是 ConcurrentHashMap 为什么高效的原因之一。<br>7.进入到 bucket 里面，首先判断这个 bucket 存储的是红黑树 (哈希地址小于 0，原因后面分析) 还是链表。<br>8.如果是链表，则遍历链表看看是否有哈希地址和键 key 相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里结束加锁。<br>9.最后判断该 bucket 上的链表长度是否大于链表转红黑树的阈值 (8)，大于则调用 treeifyBin() 方法将链表转成红黑树，以免链表过长影响效率。<br>10.调用 addCount() 方法，作用是将 ConcurrentHashMap 的键值对数量 + 1，还有另一个作用是检查 ConcurrentHashMap 是否需要扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span><br><span class="line">    //址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span><br><span class="line">    //过spread()加多了 &amp;0x7fffffff，让结果为正数。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span><br><span class="line">        //下面介绍。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //调用实现了CAS原子性操作的tabAt方法</span><br><span class="line">        //tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span><br><span class="line">        //e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span><br><span class="line">        //这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span><br><span class="line">        //希地址做与运算，和HashMap的算法一样。</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span><br><span class="line">            //casTable()方法，</span><br><span class="line">            //casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span><br><span class="line">            //个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span><br><span class="line">            //的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span><br><span class="line">            //功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span><br><span class="line">            //失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span><br><span class="line">        //table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span><br><span class="line">        //HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        //如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span><br><span class="line">        //中，将新节点插入或者覆盖旧值。</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span><br><span class="line">            //该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span><br><span class="line">            //可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span><br><span class="line">            //以提高了ConcurrentHashMap的效率，提高了并发度。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果该下标上的节点的哈希地址大于等于0，则表示这是</span><br><span class="line">                    //个链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果哈希地址、键key相同 或者 键key不为空</span><br><span class="line">                            //且键key相同，则表示存在键key和待插入的键</span><br><span class="line">                            //key相同，则执行更新值value的操作。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果找到了链表的最后一个节点都没有找到相</span><br><span class="line">                            //同键Key的，则是插入操作，将插入的键值新建</span><br><span class="line">                            //个节点并且添加到链表尾部，这个和HashMap一</span><br><span class="line">                            //样都是插入到尾部。</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果该下标上的节点的哈希地址小于0 且为树节点</span><br><span class="line">                    //则将带插入键值新增到红黑树</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //如果插入的结果不为null，则表示为替换</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != null)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span><br><span class="line">            //红黑树，提高效率。这点和HashMap一样。</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="http://iambigboss.top/post/73849_1_1.html" target="_blank" rel="noopener">http://iambigboss.top/post/73849_1_1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap 是 HashMap 的线程安全版本；&lt;/li&gt;
&lt;li&gt;不允许 [key,value] 为 null;&lt;/li&gt;
&lt;li&gt;比 Hashtable 锁粒度更细；&lt;/li&gt;
&lt;li&gt;采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；&lt;/li&gt;
&lt;li&gt;负载因子 0.75;&lt;/li&gt;
&lt;li&gt;默认初始化容量 16;&lt;/li&gt;
&lt;li&gt;put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；&lt;/li&gt;
&lt;li&gt;put 时出现 hash 冲突，则采用 synchronized;&lt;/li&gt;
&lt;li&gt;查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；&lt;/li&gt;
&lt;li&gt;ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务</title>
    <link href="http://yoursite.com/2020/07/06/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/06/quartz定时任务/</id>
    <published>2020-07-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:36:45.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Quartz-API-的关键接口是："><a href="#Quartz-API-的关键接口是：" class="headerlink" title="Quartz API 的关键接口是："></a>Quartz API 的关键接口是：</h4><ul><li>Scheduler - 与调度程序交互的主要 API。</li><li>Job - 由希望由调度程序执行的组件实现的接口。</li><li>JobDetail - 用于定义作业的实例。</li><li>Trigger（即触发器） - 定义执行给定作业的计划的组件。</li><li>JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。</li><li>TriggerBuilder - 用于定义 / 构建触发器实例。</li></ul><a id="more"></a><ul><li><p>定时任务类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void run() throws SchedulerException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;journal&quot;, journalService);//可以保存到JobExecutionContext中</span><br><span class="line">        SchedulerFactory schedFact = new StdSchedulerFactory();</span><br><span class="line">        Scheduler sched = schedFact.getScheduler();</span><br><span class="line">        sched.start();</span><br><span class="line"></span><br><span class="line">        JobDetail job = newJob(SimpleTestJob.class)</span><br><span class="line">                .withIdentity(&quot;myJob&quot;, &quot;group&quot;)</span><br><span class="line">                .usingJobData(new JobDataMap(map))</span><br><span class="line">                .build();</span><br><span class="line">        Trigger trigger = newTrigger()</span><br><span class="line">                .withIdentity(&quot;myTrigger&quot;, &quot;group&quot;)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(simpleSchedule()</span><br><span class="line">                .withIntervalInMinutes(5)//设置定时任务间隔时间</span><br><span class="line">                .repeatForever())</span><br><span class="line">                .build();</span><br><span class="line">        sched.scheduleJob(job, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体执行任务的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTestJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; jobParams = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        for (String string : jobParams.keySet()) &#123;</span><br><span class="line">            Object obj = jobParams.get(string);</span><br><span class="line">            journalService = (JournalService) obj;</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">        String format = dateFormat.format(new Date());</span><br><span class="line">        System.out.println(&quot;----------------------- &quot; + format + &quot; -------------------------&quot;);</span><br><span class="line">        List&lt;Journal&gt; journalList = journalService.selectByOperateDate(format);</span><br><span class="line">        for (Journal journal : journalList) &#123;</span><br><span class="line">            String str = dateFormat.format(journal.getOperateDate());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Quartz-API-的关键接口是：&quot;&gt;&lt;a href=&quot;#Quartz-API-的关键接口是：&quot; class=&quot;headerlink&quot; title=&quot;Quartz API 的关键接口是：&quot;&gt;&lt;/a&gt;Quartz API 的关键接口是：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Scheduler - 与调度程序交互的主要 API。&lt;/li&gt;
&lt;li&gt;Job - 由希望由调度程序执行的组件实现的接口。&lt;/li&gt;
&lt;li&gt;JobDetail - 用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;Trigger（即触发器） - 定义执行给定作业的计划的组件。&lt;/li&gt;
&lt;li&gt;JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;TriggerBuilder - 用于定义 / 构建触发器实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="quartz" scheme="http://yoursite.com/categories/quartz/"/>
    
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>post请求url中https报错问题</title>
    <link href="http://yoursite.com/2020/07/05/post%E8%AF%B7%E6%B1%82url%E4%B8%ADhttps%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/05/post请求url中https报错问题/</id>
    <published>2020-07-05T11:57:10.000Z</published>
    <updated>2020-07-06T09:30:20.093Z</updated>
    
    <content type="html"><![CDATA[<ul><li>异常日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException:</span><br><span class="line">    Caused by: java.security.cert.CertificateException: No subject alternative names present</span><br><span class="line">        at sun.security.util.HostnameChecker.matchIP(Unknown Source)</span><br><span class="line">        at sun.security.util.HostnameChecker.match(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SslHandshakeExc_NsanPresent&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">URL url = new URL(&quot;https://192.168.2.222:8443/wbsystem/login.jsp&quot;);</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sc.init(null, trustAllCerts, null);</span><br><span class="line">HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line"> </span><br><span class="line">HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">conn.setHostnameVerifier(new Servlet_test().new TrustAnyHostnameVerifier());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 定制Trust</span><br><span class="line">static TrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; &#125;;</span><br><span class="line"> </span><br><span class="line">// 定制Verifier</span><br><span class="line">public class TrustAnyHostnameVerifier implements HostnameVerifier &#123;</span><br><span class="line"></span><br><span class="line">public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;异常日志&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;javax.net.ssl.SSLHandshakeException:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Caused by: java.security.cert.CertificateException: No subject alternative names present&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.matchIP(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.match(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http请求" scheme="http://yoursite.com/categories/http%E8%AF%B7%E6%B1%82/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>java中变量初始化</title>
    <link href="http://yoursite.com/2020/07/04/java%E4%B8%AD%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/04/java中变量初始化/</id>
    <published>2020-07-04T11:57:10.000Z</published>
    <updated>2020-07-06T09:48:55.654Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的笔记，今天放到自己的博客中；</p><a id="more"></a><p>1.对于类的成员变量，不管程序有没有显式的进行初始化，Java虚拟机都会先自动给它初始化为默认值；<br>默认值如下：<br>boolean  false<br>char     ‘\u0000’<br>byte     0<br>short    0<br>int      0<br>long     0<br>float    0.0f<br>double   0.0d</p><p>2.局部变量声明之后，Java虚拟机就不会自动给他初始化为默认值，因此局部变量使用之前必须进行显示的初始化。<br>但是需要声明的是：对于只负责接收一个表达式的值的局部变量可以不初始化，参与运算和直接输出等其他的情况的局部变量需要进行初始化</p><p>通过下面这个测试可以看到JVM对哪些数据初始化，哪写数据不初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestStatic &#123;</span><br><span class="line">    static int x; //类的成员变量，JVM负责初始化</span><br><span class="line">    static int method() &#123;</span><br><span class="line">        int y=0;  //此处必须自己初始化，它不属于类成员变量，是个method的局部变量，JVM不负责初始化</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestStatic as=new TestStatic();</span><br><span class="line">        int z=0;  //此处必须自己初始化，它不属于类成员变量，是个主函数里的局部变量，JVM不负责初始化</span><br><span class="line">        int aa=3; //此处aa参与了运算，所以必须初始化</span><br><span class="line">        aa=aa+2;</span><br><span class="line">        int a=1,b=2,max; //max只是负责接收表达式的值，不需要初始化</span><br><span class="line">        max=a&gt;b?2:1; </span><br><span class="line">        System.out.println(max); //1</span><br><span class="line">        System.out.println(aa); //5</span><br><span class="line">        System.out.println(&quot;z=&quot;+z); //z=0</span><br><span class="line">        System.out.println(&quot;x=&quot;+as.x); //x=0  </span><br><span class="line">        System.out.println(&quot;y=&quot;+as.method()); //y=0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结为一句话便是：类里定义的数据成员称为属性，属性可不赋初值，若不赋初值则JAVA会按上表为其添加默认值；方法里定义的数据成员称为变量，变量在参与运算之前必须赋初值。</p></blockquote><p>[参考链接]<a href="http://www.jb51.net/article/90743.htm" target="_blank" rel="noopener">http://www.jb51.net/article/90743.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前的笔记，今天放到自己的博客中；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java是按值传递还是按引用传递</title>
    <link href="http://yoursite.com/2020/07/03/Java%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/07/03/Java是按值传递还是按引用传递/</id>
    <published>2020-07-03T11:57:10.000Z</published>
    <updated>2020-07-03T08:16:15.263Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在开始之前，我们先理解按值传递、按引用传递的概念。</li></ul><p>1、什么是值传递？<br>指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。</p><p>2、什么是引用传递<br>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><a id="more"></a><p>明确地说，java都是按值传递的！java的世界里，都是按值传递。其实按值、按引用都只是个概念，关键是我们如何去理解java传参的本质。</p><p>下面就结合一个例子来说，有些情况下，所传参数的值，是个“引用”，这一点容易让人产生困惑。</p><p>请看下面的例子<br>首先有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog = new Dog(&quot;Rover&quot;);</span><br><span class="line">foo(myDog);</span><br></pre></td></tr></table></figure><p>这时，你传给了foo函数一个参数，这个参数值，是个引用，也就是Rover这只dog的内存地址（这只是粗略的说明，因为在java中，这个地址并非是真正的地址）<br>假设这时候Rover的地址是42，那么，我们就是传了42这个地址给foo方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Dog someDog) &#123;</span><br><span class="line">    someDog.setName(&quot;Max&quot;);     // AAA</span><br><span class="line">    someDog = new Dog(&quot;Fifi&quot;);  // BBB</span><br><span class="line">    someDog.setName(&quot;Rowlf&quot;);   // CCC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步解析foo方法</p><p>1.参数 someDog的值是一个地址（42）</p><p>2.在AAA这一行：<br>someDog，也就是函数外声明的myDog，name从Rover被改成了Max</p><p>3.在BBB这一行：<br>这就是关键的地方了，又new了一只dog，new 意味着又在新的地址空间放上了一只Dog，我们假设其地址是74。这时，someDog的值，会从42变成了74</p><p>4.在CCC这一行：<br>这时候的修改，是对内存地址为74的那只狗的修改，而非原先的42</p><p>从这个例子，我们可以看到，foo方法的参数someDog，它是一个值，而非引用。如果它是引用，那么在foo方法内部的修改（包括BBB、CCC这两行），都应该会对42地址空间的dog产生影响，也就是方法外的参数，mydog也会指向新的地址空间。</p><p>不细究概念了，再总结下Java初学者容易犯错的地方：<br>假如你想像例子一样，传递一个对象到一个方法中，并由该方法修改对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Object();</span><br><span class="line">foo(a);//在方法内部修改a的属性值</span><br><span class="line">return a;//希望此时的a已经是修改后的值</span><br></pre></td></tr></table></figure><p>要切记，这个Objct一定要在调用方法前，就初始化好（new一个），然后再作为参数传进去，并且在方法中不能再初始化这个参数。这样，在方法中对该参数的修改，才会有效。</p><p>[stackoverflow链接]<br><a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在开始之前，我们先理解按值传递、按引用传递的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、什么是值传递？&lt;br&gt;指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。&lt;/p&gt;
&lt;p&gt;2、什么是引用传递&lt;br&gt;指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java时间转换</title>
    <link href="http://yoursite.com/2020/06/30/Java%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/Java时间转换/</id>
    <published>2020-06-30T11:57:10.000Z</published>
    <updated>2020-07-09T06:47:12.987Z</updated>
    
    <content type="html"><![CDATA[<ul><li>时间字符串和时间转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 把时间转换为字符串</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">Date date = new Date(136464513123L);</span><br><span class="line">String string = dateFormat.format(date);</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">// 把字符串转化为时间</span><br><span class="line">String string = &quot;2018-07-19&quot;;</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);// 这里要与时间字符串的格式一样即可，否则报错</span><br><span class="line">Date date = dateFormat.parse(string);</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//转换成时间格式12小时制</span><br><span class="line">SimpleDateFormat 12 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">//转换成时间格式24小时制</span><br><span class="line">SimpleDateFormat 24 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">12小时制与24小时制制需要把HH变换大小写就可以了</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//默认输出格式</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date);//Fri Oct 27 16:56:37 CST 2017</span><br><span class="line">//日期格式化显示，首先定义格式</span><br><span class="line">SimpleDateFormat sdf1=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//显示20171027格式</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//显示2017-10-27格式</span><br><span class="line">SimpleDateFormat sdf3=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//显示2017-10-27 10:00:00格式</span><br><span class="line">SimpleDateFormat sdf4=new SimpleDateFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;);//显示2017年10月27日10时00分00秒格式</span><br><span class="line">//将格式应用于日期</span><br><span class="line">System.out.println(sdf1.format(date));//20171027</span><br><span class="line">System.out.println(sdf2.format(date));//2017-10-27</span><br><span class="line">System.out.println(sdf3.format(date));//2017-10-27 17:11:13</span><br><span class="line">System.out.println(sdf4.format(date));//2017年10月27日17时11分13秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;时间字符串和时间转换&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 把时间转换为字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = new Date(136464513123L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = dateFormat.format(date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--------------------------------------------------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 把字符串转化为时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = &amp;quot;2018-07-19&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat (&amp;quot;yyyy-MM-dd&amp;quot;);// 这里要与时间字符串的格式一样即可，否则报错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = dateFormat.parse(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转换成时间格式12小时制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SimpleDateFormat 12 = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转换成时间格式24小时制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SimpleDateFormat 24 = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12小时制与24小时制制需要把HH变换大小写就可以了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>byte强制转换问题</title>
    <link href="http://yoursite.com/2020/06/15/byte%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/15/byte类型强制转换问题/</id>
    <published>2020-06-15T11:57:10.000Z</published>
    <updated>2020-07-15T03:08:15.882Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //50是int类型的字面值，b是byte类型的变量</span><br><span class="line">        //int容量是2个字节，byte容量是1个字节</span><br><span class="line">        //大容量转换成小容量需要强制类型转换符</span><br><span class="line">        //然而，这里并不需要强制类型转换符即可编译通过，为什么？</span><br><span class="line">        byte b = 50;</span><br><span class="line">        </span><br><span class="line">        //此处，不需要强制类型转换符，编译通过</span><br><span class="line">        byte b1 = 127;</span><br><span class="line">        </span><br><span class="line">        //此处，编译又不通过了，为什么？</span><br><span class="line">        byte b2 = 128;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：在Java语法中，sun公司对byte字符有一定的优待，当一个整数型字面值不超出byte类型的取值范围，即可不需要强制类型转换符直接赋值给byte，且编译通过，但超出byte的取值范围编译，则无法赋值给byte，编译不通过。这个属于特殊语法机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础、基本类型" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java空字符串和null的区别</title>
    <link href="http://yoursite.com/2020/06/11/Java%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/06/11/Java空字符串和null的区别/</id>
    <published>2020-06-11T11:57:10.000Z</published>
    <updated>2020-07-07T06:42:16.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java空字符串与null的区别："><a href="#Java空字符串与null的区别：" class="headerlink" title="Java空字符串与null的区别："></a>Java空字符串与null的区别：</h3><ul><li>类型<br>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）<br>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）</li><li>内存分配<br>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；<br>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：<br>就如下：<br>String str = new String(“abc”) ;<br>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<a id="more"></a></li><li>示例程序：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 = new String() ;</span><br><span class="line">        String str2 = null ;</span><br><span class="line">        String str3 = &quot;&quot; ;</span><br><span class="line">        System.out.println(str1==str2);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str2==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str1==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         //值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;&quot;; //str1对应一个空串，声明对象的引用</span><br><span class="line">String str2 = null; //str2引用为空</span><br><span class="line">String str3 = new String(); //str3将指向具体的String实例，默认值为“”</span><br><span class="line">注意：str1和str3被实例化，而str2没有实例化，但str1和str3所指的地址不同，但值一样，都为空。</span><br></pre></td></tr></table></figure><p>有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (str != null &amp;&amp; str.length() != 0)</span><br></pre></td></tr></table></figure><p>注意：首先要检查 str 不为 null。如果在一个 null 值上调用方法，会出现错误。</p><p>通过如上的程序可以得出如下结论：<br>字符串对象与null的值不相等，且内存地址也不相等；<br>空字符串对象与null的值不相等，且内存地址也不相等；<br>new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null）</p><p>以下是java 判断字符串是否为空的四种方法:<br>方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:<br>                     if(s == null || s.equals(“”));<br>方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:<br>                     if(s == null || s.length() == 0);<br>方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.<br>                     if(s == null || s.isEmpty());<br>方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:<br>                     if (s == null || s == “”);</p><p>注意:s == null 是有必要存在的.<br>　　“如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException.<br>　　并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException.”<br>　　如下Java代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　String str = null;</span><br><span class="line">　　if(str.equals(&quot;&quot;) || str == null)&#123;//会抛出异常</span><br><span class="line">　　          System.out.println(&quot;success&quot;);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.cnblogs.com/qiuting/p/5373571.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiuting/p/5373571.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java空字符串与null的区别：&quot;&gt;&lt;a href=&quot;#Java空字符串与null的区别：&quot; class=&quot;headerlink&quot; title=&quot;Java空字符串与null的区别：&quot;&gt;&lt;/a&gt;Java空字符串与null的区别：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类型&lt;br&gt;null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）&lt;br&gt;“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）&lt;/li&gt;
&lt;li&gt;内存分配&lt;br&gt;String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；&lt;br&gt;String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；&lt;br&gt;在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：&lt;br&gt;就如下：&lt;br&gt;String str = new String(“abc”) ;&lt;br&gt;ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>properties转yml配置文件</title>
    <link href="http://yoursite.com/2020/06/10/properties%E8%BD%ACyml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/10/properties转yml配置文件/</id>
    <published>2020-06-10T11:57:10.000Z</published>
    <updated>2020-07-07T02:35:13.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用在线问答转换 将各自properties文件转成yml文件类型<a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">https://www.toyaml.com/index.html</a></li><li>因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author yuezp</span><br><span class="line"> * @Date 2020/5/9 5:29 下午</span><br><span class="line"> * @Version v1.0</span><br><span class="line"> */</span><br><span class="line">public class YmlResourceFactory extends DefaultPropertySourceFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        String sourceName = (name == null) ? resource.getResource().getFilename() : name;</span><br><span class="line">        assert sourceName != null;</span><br><span class="line">        if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) &#123;</span><br><span class="line">            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();</span><br><span class="line">            factory.setResources(resource.getResource());</span><br><span class="line">            factory.afterPropertiesSet();</span><br><span class="line">            Properties properties = factory.getObject();</span><br><span class="line">            assert properties != null;</span><br><span class="line">            return new PropertiesPropertySource(sourceName, properties);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.createPropertySource(name, resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>APP启动类中的@PropertySource  修改为@PropertySource(value = {“classpath:application-服务名.yml”,”application-bdev.yml”},encoding = “UTF-8”, factory = YmlResourceFactory.class)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用在线问答转换 将各自properties文件转成yml文件类型&lt;a href=&quot;https://www.toyaml.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.toyaml.com/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举使用</title>
    <link href="http://yoursite.com/2020/06/09/%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/09/枚举使用/</id>
    <published>2020-06-09T11:57:10.000Z</published>
    <updated>2020-07-07T02:31:32.632Z</updated>
    
    <content type="html"><![CDATA[<p>枚举例子如下 ：<br>普通java类定义常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Operation &#123;  </span><br><span class="line">    private String operType;</span><br><span class="line">    </span><br><span class="line">    private Operation(String operType)&#123; </span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static final Operation ADD = new Operation(&quot;add&quot;);</span><br><span class="line">    public static final Operation DELETE = new Operation(&quot;delete&quot;);</span><br><span class="line">    public static final Operation MODIFY= new Operation(&quot;modify&quot;);</span><br><span class="line">    public static final Operation SELECT = new Operation(&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">    public String getOperType() &#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>枚举定义常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum OperationByEnum&#123;</span><br><span class="line">    ADD(&quot;add&quot;), DELETE(&quot;delete&quot;), MODIFY(&quot;modify&quot;), SELECT(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看上述两个类的 class 文件可以看出两种方式可以认为是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap OperationByEnum.class</span><br><span class="line">Compiled from &quot;OperationByEnum.java&quot;</span><br><span class="line">public final class OperationByEnum extends java.lang.Enum&lt;OperationByEnum&gt; &#123;</span><br><span class="line">  public static final OperationByEnum ADD;</span><br><span class="line">  public static final OperationByEnum DELETE;</span><br><span class="line">  public static final OperationByEnum MODIFY;</span><br><span class="line">  public static final OperationByEnum SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">  public static OperationByEnum[] values();</span><br><span class="line">  public static OperationByEnum valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap Operation.class</span><br><span class="line">Compiled from &quot;Operation.java&quot;</span><br><span class="line">public class Operation &#123;</span><br><span class="line">  public static final Operation ADD;</span><br><span class="line">  public static final Operation DELETE;</span><br><span class="line">  public static final Operation MODIFY;</span><br><span class="line">  public static final Operation SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public enum  ClusterType &#123;</span><br><span class="line"></span><br><span class="line">    kafka,</span><br><span class="line">    storm,</span><br><span class="line"></span><br><span class="line">    hdfs (&quot;hello&quot;,&quot;world&quot;),</span><br><span class="line"></span><br><span class="line">    yarn (&quot;nihao&quot;, &quot;haode&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String key;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    ClusterType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClusterType(String key, String value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ClusterType&#123;&quot; +</span><br><span class="line">                &quot;key=&apos;&quot; + key + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, value=&apos;&quot; + value + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;&#125; &quot; + super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;111 = &quot; + ClusterType.kafka);</span><br><span class="line">        ClusterType.kafka.setKey(&quot;hello&quot;);</span><br><span class="line">        String key = ClusterType.kafka.getKey();</span><br><span class="line">        System.out.println(&quot;222 = &quot; + key);</span><br><span class="line"></span><br><span class="line">        ClusterType.kafka.setValue(&quot;world&quot;);</span><br><span class="line">        String value = ClusterType.kafka.getValue();</span><br><span class="line">        System.out.println(&quot;333 = &quot; + value);</span><br><span class="line"></span><br><span class="line">        ClusterType hdfs = ClusterType.hdfs;</span><br><span class="line">        System.out.println(&quot;444 = &quot; + hdfs);</span><br><span class="line">        String s = ClusterType.hdfs.getKey();</span><br><span class="line">        System.out.println(&quot;555 = &quot; + s);</span><br><span class="line">        String value1 = ClusterType.hdfs.getValue();</span><br><span class="line">        System.out.println(&quot;666 = &quot; + value1);</span><br><span class="line">        ClusterType[] values = ClusterType.values();</span><br><span class="line">        for (ClusterType clusterType : values) &#123;</span><br><span class="line">            System.out.println(clusterType);</span><br><span class="line">        &#125;</span><br><span class="line">        ClusterType hdfs1 = ClusterType.valueOf(&quot;hdfs&quot;);</span><br><span class="line">        System.out.println(hdfs1);</span><br><span class="line">        String s1 = ClusterType.class.toString();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举中valueof用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   String str = &quot;ADD&quot;;</span><br><span class="line">OperationByEnum ob = OperationByEnum.valueOf(str);</span><br><span class="line">System.out.println(ob == OperationByEnum.ADD);//TRUE</span><br><span class="line"></span><br><span class="line">String str2=&quot;add&quot;;</span><br><span class="line">OperationByEnum ob1 = OperationByEnum.valueOf(str2);</span><br></pre></td></tr></table></figure><p>枚举类是一种特殊的 JAVA 类，枚举类中每声明一个枚举值就代表枚举类的一个实例对象。<br>与 JAVA 普通类一样，声明枚举类时也可以声明类的属性、方法、构造函数，但构造函数必须为私有。<br>枚举类也可以实现接口，继承抽象类。可以作为 switch 语句的参数。<br>若枚举类只有一个枚举值，则可以当做单例设计模式使用。<br>注意：为什么要对weekend 构造函数进行私有化， 答：保证外界无法通过调用构造函数再实例化出一个非法的枚举<br>同理 string 也要进行私有化，防止外界的非法更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> * 带抽象方法的枚举</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public enum OperationByEnum &#123;</span><br><span class="line">    ADD(&quot;add&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;增&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    DELETE(&quot;delete&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;删&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    MODIFY(&quot;modify&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;改&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    SELECT(&quot;select&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;查&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">        this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract String getChineseName();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        print(OperationByEnum.ADD);</span><br><span class="line">        String chineseName = OperationByEnum.ADD.getChineseName();</span><br><span class="line">        System.out.println(chineseName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print(OperationByEnum arg)&#123;</span><br><span class="line">        System.out.println(arg.getOperType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接：<a href="http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6" target="_blank" rel="noopener">http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6</a></p><p>常量的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public class ResultCode &#123;</span><br><span class="line"></span><br><span class="line">    public String code;</span><br><span class="line">    public String message;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSystemError() &#123;</span><br><span class="line">        return SYSTEM_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSUCCESS() &#123;</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ResultCode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultCode(String code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final ResultCode SUCCESS// 编译错误，常量需要初始化</span><br><span class="line">    public static final ResultCode SUCCESS = new ResultCode();</span><br><span class="line">    public static final ResultCode SYSTEM_ERROR = new ResultCode(&quot;E00001&quot;,&quot;系统错误&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ResultCode&#123;&quot; +</span><br><span class="line">                &quot;code=&apos;&quot; + code + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, message=&apos;&quot; + message + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ResultCode.SUCCESS.toString());</span><br><span class="line">        ResultCode.SUCCESS = new ResultCode(&quot;123&quot;, &quot;234&quot;);//报编译错误因为SUCCESS是常量</span><br><span class="line">        SUCCESS.setCode(&quot;nihao&quot;);//但是可以给常量赋值属性   &lt;--------------------</span><br><span class="line">        System.out.println(SUCCESS.getCode()); // 输出nihao                   -</span><br><span class="line">        System.out.println(ResultCode.SYSTEM_ERROR.toString());               -</span><br><span class="line">    &#125;                                                                         -</span><br><span class="line">                                                                              -</span><br><span class="line">                                                                              -</span><br><span class="line">&#125;                                                                             -</span><br><span class="line">```                                                                           -</span><br><span class="line">final修饰的变量一般用于常量的定义上，因为一旦定义就无法改变了                      -</span><br><span class="line">（基础数据类型的话，无法改变的是值；引用数据类型的话，无法改变的是引用              -</span><br><span class="line">&lt;引用不能改变即存在变量中的地址无法改变，但是引用的值是可以通过方法来改变的&gt;）。-----&gt;</span><br><span class="line">PS：本质上基础数据类型跟引用数据类型在内存中的都是值，</span><br><span class="line">只不过这个值对于用户的含义不同，一个存储的就是值本身，一个存储的值是引用地址。</span><br><span class="line">常量可以在定义时不初始化，但是必须在静态代码块中初始化。如下例子：</span><br></pre></td></tr></table></figure><p>package bonc.cn.com;</p><p>/**</p><ul><li><p>Created by yzp on 2017/11/6.</p></li><li><p>/<br>public class StringStudy {</p><p>  public static final String STR;<br>  public static final A a;<br>  static {</p><pre><code>STR = &quot;INIT&quot;;a = new A();a.a = &quot;abc&quot;;//常量可以在静态代码块中初始化，但是不允许修改引用，不过引用的对象中的属性是可以随意修改的。</code></pre><p>  }</p></li></ul><p>}</p><p>class A {<br>    String a;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">常量的三种动态初始化：</span><br></pre></td></tr></table></figure><p>public class Configuration {</p><p>public static final String CONFIG = “你想要指定的一些配置项”;</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">当我们需要给Configuration类中的CONFIG常量第一次使用时动态指定一个值时，而此时我们又不想去修改源代码，那我们有三种方法去实现这种需求。</span><br><span class="line"></span><br><span class="line">第一种：使用一个static静态代码块来指定，然后在静态代码块中，我们去动态读取外部的一个Properties文件的值。（最推荐）</span><br></pre></td></tr></table></figure><p>import java.util.Properties;</p><p>/**</p><ul><li><p>第一种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>Properties properties = new Properties();//把一个properties读进来CONFIG = &quot;properties.getConfig&quot;;//通过properties的配置项config来初始化我们的常量config</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二种：我们可以配置Java的运行时配置，来指定一个-Dname=value的参数，这样也可以在类内部动态的接受到运行时指定的一个参数。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第二种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getProperty(&quot;CONFIG&quot;);//通过系统的-D配置参数name=value形式来拿到这个配置值//如果是eclipse，右键-&gt;RUN AS-&gt;Run Configurations-&gt;arguments-&gt;VMarguments 里输入（-DCONFIG=我们想要加入的配置）</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三种：我们还可以读的到系统配置的PATH或者CLASSPATH里面的值，同理，我们也可以配置自己的环境变量，然后在程序中一样也能读到这些配置的环境变量。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第三种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getenv(&quot;PATH&quot;);//通过System.getenv()方法可以拿到系统环境变量，但我自己指定的环境变量没有取得成功，如果有知道原因的给我留言哈谢谢</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p></li></ul><p>final double PI=3.1415926</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原先很多书上说常量的初始化只有在定义的时候才可以，</span><br><span class="line">像上边的代码一样。其实常量的初始化也可以在构造函数中定义，但要注意必须要在所有重载的构造函数中都要定义一遍。</span><br><span class="line">常量在JAVA中经常定义成静态的static，这是为了节省内存，也是因为他是不能改变的。</span><br><span class="line">于是变成了：</span><br></pre></td></tr></table></figure><p>statis final double PI=3.1415926</p><pre><code>当定义静态常量的时候，就不能使用构造函数初始化常量了，这是因为我们经常直接使用类名调用静态成员，而构造函数的第一次运行，是在第一次new这个类的对象的时候。我们如果不去new，那么常量就永远不能初始化。所以，这个时候必须用上边的代码直接初始化。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举例子如下 ：&lt;br&gt;普通java类定义常量&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Operation &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Operation(String operType)&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this.operType = operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation ADD = new Operation(&amp;quot;add&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation DELETE = new Operation(&amp;quot;delete&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation MODIFY= new Operation(&amp;quot;modify&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation SELECT = new Operation(&amp;quot;select&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getOperType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://yoursite.com/2020/06/06/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/06/06/Java泛型/</id>
    <published>2020-06-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:49:06.874Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lt-extends-T-gt-和-lt-super-T-gt-的区别"><a href="#lt-extends-T-gt-和-lt-super-T-gt-的区别" class="headerlink" title="&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别"></a>&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别</h4><ul><li>&lt;? extends T&gt; 表示该通配符所代表的类型是 T 类型的子类。</li><li>&lt;? super T&gt; 表示该通配符所代表的类型是 T 类型的父类。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fun():</span><br><span class="line">&lt;T&gt;是用来规范T的，例如&lt;T extends Object&gt;就规定了边界，</span><br><span class="line">即规定了所有出现T的地方，T类型必须是Object的子类。</span><br><span class="line"></span><br><span class="line">Box 类定义为一个泛型类:</span><br><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T object;</span><br><span class="line"></span><br><span class="line">    public void set(T object) &#123; this.object = object; &#125;</span><br><span class="line">    public T get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建一个 Box 对象，不带泛型参数，发现获取对象的时候需要强制转换</span><br><span class="line"></span><br><span class="line">Box box2 = new Box();</span><br><span class="line">box2.set(new Apple());</span><br><span class="line">Apple apple = (Apple) box2.get();</span><br><span class="line">创建一个 Box 对象，带泛型参数，获取对象的时候就不需要强制转换</span><br><span class="line"></span><br><span class="line">Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();</span><br><span class="line">box.set(new Apple());</span><br><span class="line">Apple apple = box.get();</span><br><span class="line">总结下泛型的好处就是</span><br><span class="line">省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上;</span><br></pre></td></tr></table></figure><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 element(即元素)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Test&lt;T&gt; &#123;    </span><br><span class="line">    public List&lt;T&gt; list = new ArrayList&lt;T&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">和</span><br><span class="line">public class Test&lt;A&gt; &#123;    </span><br><span class="line">    public List&lt;A&gt; list = new ArrayList&lt;A&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 T 换成了 A，在执行效果上是没有任何区别的，只不过我们约定好了 T 代表 type，<br>所以还是按照约定规范来比较好，增加了代码的可读性；</p><p>如果要定义多个泛型参数，比如说两个泛型参数<br>很典型的一个栗子是 Map 的 key,value 泛型，我们也可以定义一个这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Mymap&lt;K, V&gt; &#123;</span><br><span class="line">    public K getKey();</span><br><span class="line">    public V getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MymapImpl&lt;K, V&gt; implements Mymap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public MymapImpl(K key, V value) &#123;</span><br><span class="line">       this.key = key;</span><br><span class="line">       this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey()    &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来就可以传入任意类型，创建实例了，不用转化类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mymap&lt;String, Integer&gt; mp1= new MymapImpl&lt;String, Integer&gt;(&quot;Even&quot;, 8);</span><br><span class="line">Mymap&lt;String, String&gt;  mp2= new MymapImpl&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">Mymap&lt;Integer, Integer&gt; mp3= new MymapImpl&lt;Integer, Integer&gt;(888, 888);</span><br></pre></td></tr></table></figure><h4 id="List，List，List-lt-gt-区别"><a href="#List，List，List-lt-gt-区别" class="headerlink" title="List，List，List&lt;?&gt; 区别"></a>List<t>，List<object>，List&lt;?&gt; 区别</object></t></h4><ul><li>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是 T 类型</t></t></li><li>ArrayList<?> al=new ArrayList<?>(); 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</li><li>ArrayList&lt;? extends E&gt; al=new ArrayList&lt;? extends E&gt;();<br>泛型的限定：<br>? extends E: 接收 E 类型或者 E 的子类型。<br>? super E: 接收 E 类型或者 E 的父类型<br>? 和 T 区别是？是一个不确定类，？和 T 都表示不确定的类型 ，<br>但如果是 T 的话，函数里面可以对 T 进行操作，比方 T car = getCar()，而不能用？ car = getCar()。</li></ul><p>[参考链接]<a href="http://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">http://www.jianshu.com/p/95f349258afb</a><br>[参考链接]<a href="http://frankco.iteye.com/blog/1668466" target="_blank" rel="noopener">http://frankco.iteye.com/blog/1668466</a></p><h4 id="最后来说说-T，Class，Class-lt-gt-区别："><a href="#最后来说说-T，Class，Class-lt-gt-区别：" class="headerlink" title="最后来说说 T，Class，Class&lt;?&gt; 区别："></a>最后来说说 T，Class<t>，Class&lt;?&gt; 区别：</t></h4><p>T 是一种具体的类，例如 String,List,Map…… 等等，这些都是属于具体的类，这个比较好理解<br>Class 是什么呢，Class 也是一个类，但 Class 是存放上面 String,List,Map…… 类信息的一个类，有点抽象，我们一步一步来看 。</p><p>如何获取到 Class 类呢，有三种方式：</p><ol><li>调用 Object 类的 getClass() 方法来得到 Class 对象，这也是最常见的产生 Class 对象的方法。<br>例如：</li></ol><p>List list = null;<br>Class clazz = list.getClass();</p><ol start="2"><li>使用 Class 类的中静态 forName() 方法获得与字符串对应的 Class 对象。<br>例如：Class clazz = Class.forName(“com.lyang.demo.fanxing.People”);</li><li>获取 Class 类型对象的第三个方法非常简单。如果 T 是一个 Java 类型，那么 T.class 就代表了匹配的类对象。<br>Class clazz = List.class;<br>那么问题来了，Class 类是创建出来了，但是 Class<t> 和 Class&lt;?&gt; 适用于什么时候呢？</t></li></ol><p>使用 Class<t> 和 Class&lt;?&gt; 多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。<br>People people = (People) Class.forName(“com.lyang.demo.fanxing.People”).newInstance();<br>看到了么，需要强转，如果反射的类型不是 People 类，就会报<br>java.lang.ClassCastException 错误。</t></p><p>使用 Class<t> 泛型后，不用强转了</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        return clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  throws IllegalAccessException, InstantiationException  &#123;</span><br><span class="line">            Fruit fruit= createInstance(Fruit .class);</span><br><span class="line">            People people= createInstance(People.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 Class<t> 和 Class<?> 有什么区别呢？Class<t> 在实例化的时候，T 要替换成具体类Class<?> 它是个通配泛型，? 可以代表任何类型，主要用于声明时的限制情况<br>例如可以声明一个<br>public Class<?> clazz;但是你不能声明一个public Class<t> clazz;因为 T 需要指定类型所以当不知道定声明什么类型的 Class 的时候可以定义一个 Class<?>,Class&lt;?&gt; 可以用于参数类型定义，方法返回值定义等。</t></t></t></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;lt-extends-T-gt-和-lt-super-T-gt-的区别&quot;&gt;&lt;a href=&quot;#lt-extends-T-gt-和-lt-super-T-gt-的区别&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&quot;&gt;&lt;/a&gt;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;? extends T&amp;gt; 表示该通配符所代表的类型是 T 类型的子类。&lt;/li&gt;
&lt;li&gt;&amp;lt;? super T&amp;gt; 表示该通配符所代表的类型是 T 类型的父类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>方法中参数前有final修饰</title>
    <link href="http://yoursite.com/2020/06/05/%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0%E5%89%8D%E6%9C%89final%E4%BF%AE%E9%A5%B0/"/>
    <id>http://yoursite.com/2020/06/05/方法中参数前有final修饰/</id>
    <published>2020-06-05T11:57:10.000Z</published>
    <updated>2020-07-07T01:05:31.892Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；</p><p>如下基本数据类型的代码例子：</p><pre><code>/** * final修饰的基本数据类型的值是不能够改变的 * @param i */public static void setValue(final int i) {    //编译通不过，基本数据类型不能够改变    i = 10;}</code></pre><p>如下引用数据类型的代码例子：</p><pre><code>/** * 对应final修饰的基本数据类型方法内部是不可以变得，但是引用数据类型是引用不可以变，但是值可以变 * @param user */public static void setUser(final User user) {    //引用的数据类型的值是可以改变的，但是指向的引用是不能够变的    user.setPassword(&quot;sdf&quot;);    //引用的数据类型引用是不可以变得，否则编译是不能够通过的    user = new User();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；&lt;/p&gt;
&lt;p&gt;如下基本数据类型的代码例子：&lt;/
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2020/06/04/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/04/Java异常处理/</id>
    <published>2020-06-04T11:57:10.000Z</published>
    <updated>2020-07-07T00:43:09.223Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，<br>在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、<br>IndexOutOfBoundsException 等），这些异常类分为两大类：Error 和 Exception。</p><p>Error 是无法处理的异常，比如 OutOfMemoryError，一般发生这种异常，<br>JVM 会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>Exception，也就是我们经常见到的一些异常情况，<br>比如 NullPointerException、IndexOutOfBoundsException，这些异常是我们可以处理的异常。</p><p>Exception 类的异常包括 checked exception 和 unchecked exception<br>（unchecked exception 也称运行时异常 RuntimeException，<br>当然这里的运行时异常并不是前面我所说的运行期间的异常，<br>只是 Java 中用运行时异常这个术语来表示，Exception 类的异常都是在运行期间发生的）。</p><p>unchecked exception（非检查异常），也称运行时异常（RuntimeException），<br>比如常见的 NullPointerException、IndexOutOfBoundsException。对于运行时异常，<br>java 编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。<br>　　<br>checked exception（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<br>java 编译器强制程序员必须进行捕获处理，比如常见的 IOExeption 和 SQLException。<br>对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><p>在 Java 中，所有异常类的父类是 Throwable 类，Error 类是 error 类型异常的父类，<br>Exception 类是 exception 类型异常的父类，RuntimeException 类是所有运行时异常的父类，<br>RuntimeException 以外的并且继承 Exception 的类是非运行时异常。<br>　　<br>典型的 RuntimeException 包括 NullPointerException、IndexOutOfBoundsException、<br>IllegalArgumentException 等。<br>　　<br>典型的非 RuntimeException 包括 IOException、SQLException 等。</p><p>在Java中什么是内存不足错误？<br>答：在Java中，OutOfMemoryError是 java.lang.VirtualMachineError的一个子类，<br>当堆内存耗尽时会被JVM抛出。我们能通过设置Java选项来提供更大的内存供应用使用来达到修复的目的。<br>$&gt;java MyProgram -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=256m</p><p>引发Exception in thread main的各种不同情形？<br>答：通常的一些主线程异常情形主要有以下几种：<br>Exception in thread main java.lang.UnsupportedClassVersionError:当编译和运行Java类的JDK版本不同的时出现这种异常。<br>Exception in thread main java.lang.NoClassDefFoundError:这种异常出现的原因有两种：第一种是提供类全名时附带有.class；第二种是指定类未找到。<br>Exception in thread main java.lang.NoSuchMethodError: main:当试图运行一个没main方法的类时会出现这种异常。<br>Exception in thread main java.lang.NoSuchMethodError: main:无论何时main方法任何异常，它打印异常到控制台。其第一部分是陈述main方法抛出的异常，第二部分打印异常类名，后接异常类信息。</p><p>Java中final,finally,finalize的区别？<br>答：final和finally在Java中是关键字，而finalize则是一个方法。<br>final关键字使得类变量不可变，避免类被其它类继承或方法被重写。finally跟try-catch块一起使用，即使是出现了异常，其子句总会被执行，通常，finally子句用来关闭相关资源。finally方法中的对象被销毁之前会被垃圾回收。<br>综上三者，只有finally用于异常处理。</p><p>在main方法抛出异常时发生了什么？<br>答：当main方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><p>catch子句能为空吗？<br>答：可以有空的catch子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的catch子句。Catch子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><p>链接：<a href="http://www.jianshu.com/p/f6865c97cd52" target="_blank" rel="noopener">http://www.jianshu.com/p/f6865c97cd52</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，&lt;br&gt;在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、&lt;br&gt;IndexOutOfBoundsException 等
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>值传递</title>
    <link href="http://yoursite.com/2020/06/03/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/06/03/值传递/</id>
    <published>2020-06-03T11:57:10.000Z</published>
    <updated>2020-07-07T00:41:03.767Z</updated>
    
    <content type="html"><![CDATA[<p>首先举例如下：<br>public class Employee {  </p><pre><code>public String name=null;  public Employee(String n){      this.name=n;  }  //将两个Employee对象交换  public static void swap(Employee e1,Employee e2){      Employee temp=e1;      e1=e2;      e2=temp;              System.out.println(e1.name+&quot; &quot;+e2.name); //打印结果：李四 张三  }  //主函数  public static void main(String[] args) {      Employee worker=new Employee(&quot;张三&quot;);      Employee manager=new Employee(&quot;李四&quot;);      swap(worker,manager);      System.out.println(worker.name+&quot; &quot;+manager.name); //打印结果仍然是： 张三 李四  }  </code></pre><p>}<br>上面的结果让人很失望，虽然形参对象 e1,e2 的内容交换了，<br>但实参对象 worker,manager 并没有互换内容。<br>这里面最重要的原因就在于形参 e1,e2 是实参 worker,manager 的地址拷贝。</p><p>传值：<br>传递的是值的副本。方法中对副本的修改，不会影响到调用方法<br>传引用：<br>传递的是引用的副本，共用一个内存，会影响到调用方法。<br>此时，形参和实参指向同一个内存地址。<br>对引用副本本身（对象地址）的修改，如设置为 null，重新指向其他对象，不会影响到调用方法。</p><p>链接：<a href="http://6924918.blog.51cto.com/6914918/1283761" target="_blank" rel="noopener">http://6924918.blog.51cto.com/6914918/1283761</a></p><p>String简单介绍：<br>两种方式是有区别的，这和 java 的内存管理有关，前面已经说过，string 创建之后是不可变的，<br>所以按照第一种方式创建的字符串会放在栈里，更确切的是常量池中，<br>常量池就是用来保存在编译阶段确定好了大小的数据，<br>一般我们定义的 int 等基本数据类型就保存在这里。<br>其具体的一个流程就是，编译器首先检查常量池，看看有没有一个 “string”，如果没有则创建。<br>如果有的话，则则直接把 str1 指向那个位置。<br>第二种创建字符串的方法是通过 new 关键字，还是 java 的内存分配，<br>java 会将 new 的对象放在堆中，这一部分对象是在运行时创建的对象。<br>所以我们每一次 new 的时候，都会创建不同的对象，即便是堆中已经有了一个一模一样的。<br>写一个小例子</p><pre><code>String str1 = &quot;string&quot;;String str4 = &quot;string&quot;;String str2 = new String(&quot;string&quot;);String str3 = new String(&quot;string&quot;);/*用于测试两种创建字符串方式的区别*/System.out.println(str1 == str4);System.out.println(str2 == str3);System.out.println(str3 == str1);str3 = str3.intern(); //一个不常见的方法System.out.println(str3 == str1);</code></pre><p>这个的运行结果是<br>true // 解释：两个字符串的内容完全相同，因而指向常量池中的同一个区域<br>false // 解释：每一次 new 都会创建一个新的对象<br>false // 解释： 注意 == 比较的是地址，不仅仅是内容<br>true // 介绍一下 intern 方法，这个方法会返回一个字符串在常量池中的一个地址，<br>如果常量池中有与 str3 内容相同的 string 则返回那个地址，如果没有，<br>则在常量池中创建一个 string 后再返回。实际上，str3 现在指向了 str1 的地址。</p><p>string 是不变的，那么为什么 str1 + “some” 是合法的，<br>其实，每次对 string 进行修改，都会创建一个新的对象。<br>所以如果需要对一个字符串不断的修改的话，效率是非常的低的，<br>因为堆的好处是可以动态的增加空间，劣势就是分配新的空间消耗是很大的</p><p>String 字符串常量：<br>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，<br>则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。<br>因此，每次在对 String 类型的对象进行改变的时候其实都等同于<br>生成了一个新的 String 对象，然后将指针指向新的 String 对象，<br>所以经常改变内容的字符串最好不要用 String，因为每次生成对象<br>都会对系统性能产生影响。</p><p>StringBuffer 字符串变量 (线程安全）：<br>所谓变量，即是可以随时变化的量。如果对 StringBuffer 对象进<br>行改变，每次结果都会对 StringBuffer 对象进行操作，而不是生<br>成新的对象。所以一般字符串要经常变化的话使用 StringBuffer。</p><p>StringBuilder 字符串变量（非线程安全）：<br>StringBuilder 和 StringBuffer 类功能基本相似，方法也差不多，<br>主要区别在于 StringBuffer 类的方法是多线程安全的，<br>而 StringBuilder 不是线程安全的，相比而言 StringBuilder 类会略微快一点。</p><p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>    （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中<br>    （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。<br>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量<br>    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。<br>         引用变量名和对应的对象仍然存储在相应的堆中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先举例如下：&lt;br&gt;public class Employee {  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String name=null;  

public Employee(String n){  
    this.name=n;  
}  
//将两个
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>kafka基础笔记</title>
    <link href="http://yoursite.com/2020/06/02/kafka%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/02/kafka基础笔记/</id>
    <published>2020-06-02T11:57:10.000Z</published>
    <updated>2020-07-06T09:59:10.073Z</updated>
    
    <content type="html"><![CDATA[<p>consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）<br>一种是topic-partition粒度（用户自己去管理）；</p><a id="more"></a><p>// 订阅指定的 topic 列表,并且会自动进行动态 partition 订阅<br>// 当发生以下情况时,会进行 rebalance: 1.订阅的 topic 列表改变; 2.topic 被创建或删除; 3.consumer 线程 die; 4. 加一个新的 consumer 线程<br>// 当发生 rebalance 时，会唤醒 ConsumerRebalanceListener 线程<br>public void subscribe(Collection topics, ConsumerRebalanceListener listener){}<br>// 同上，但是这里没有设置 listener<br>public void subscribe(Collection topics){}<br>//note: 订阅那些满足一定规则(pattern)的 topic<br>public void subscribe(Pattern pattern, ConsumerRebalanceListener listener){}</p><p>以上三种 API 都是按照 topic 级别去订阅，可以动态地获取其分配的 topic-partition，这是使用 Group 动态管理 ，它不能与手动 partition 管理一起使用。当监控到发生下面的事件时，Group 将会触发 rebalance 操作：</p><ul><li>订阅的 topic 列表变化；</li><li>topic 被创建或删除；</li><li>consumer group 的某个 consumer 实例挂掉；</li><li>一个新的 consumer 实例通过 join 方法加入到一个 group 中。</li></ul><p>consumer的两种commit实现，commitAsync()和commitSync()，即同步commit和异步commit；</p><p>kafka常用命令：<br>列出所有topic：kafka-topics.sh –zookeeper localhost:2181 –list<br>创建topic：kafka-topics.sh –zookeeper localhost:2181<br>                            –create<br>                            –topic earth<br>                            –partitions 1<br>                            –replication-factor 1</p><p>生产数据：kafka-console-producer.sh<br>                    –broker-list localhost:9092<br>                    –topic earth</p><p>消费数据：kafka-console-consumer.sh –zookeeper localhost:2181<br>                                      –topic earth<br>                                      –from-beginning</p><p>获取offset的最大最小值：kafka-run-class.sh kafka.tools.GetOffsetShell<br>                                 –broker-list localhost:9092<br>                                 –topic earth<br>                                 –time -1</p><p>最后的参数-1表示显示获取最大值，-2表示获取最小值；</p><p>查看具体某个partition数据内容：kafka-simple-consumer-shell.sh –broker-list localhost:9092<br>                                       –topic earth<br>                                       –partition 1<br>                                       –print-offsets<br>                                       –offset 18<br>                                       –clientId test<br>                                       –property print.key=true</p><p>1).System.exit(0)是将你的整个虚拟机里的内容都停掉了 ，而dispose()只是关闭这个窗口，但是并没有停止整个application exit() 。无论如何，内存都释放了！也就是说连JVM都关闭了，内存里根本不可能还有什么东西<br>2).System.exit(0)是正常退出程序，而System.exit(1)或者说非0表示非正常退出程序<br>3).System.exit(status)不管status为何值都会退出程序。和return 相比有以下不同点：return是回到上一层，而System.exit(status)是回到最上层<br>示例:<br>在一个if-else判断中，如果我们程序是按照我们预想的执行，到最后我们需要停止程序，那么我们使用System.exit(0)，而System.exit(1)一般放在catch块中，当捕获到异常，需要停止程序，我们使用System.exit(1)。这个status=1是用来表示这个程序是非正常退出。</p><p>自动关机命令：<br>表示600秒后自动关机：shutdown -s -t 600<br>取消定时关机：shutdown -a<br>表示600秒后自动重启：shutdown -r -t 600<br>rononce -p：15秒关机</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）&lt;br&gt;一种是topic-partition粒度（用户自己去管理）；&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka、大数据" scheme="http://yoursite.com/tags/kafka%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
