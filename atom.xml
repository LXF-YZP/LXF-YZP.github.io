<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-09T09:59:24.176Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在互联网上虚度人生</title>
    <link href="http://yoursite.com/2019/10/08/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%E8%99%9A%E5%BA%A6%E4%BA%BA%E7%94%9F/"/>
    <id>http://yoursite.com/2019/10/08/如何在互联网上虚度人生/</id>
    <published>2019-10-08T10:28:24.000Z</published>
    <updated>2019-10-09T09:59:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>详情请阅读全文</p><a id="more"></a><p>这篇大部分是看别人的博客抄的，原博客说看完大概需要4分钟，我大概用了十几分钟，看来我阅读能力也不行了（一定是玩物丧志玩的）</p><p>今天你上网了吗？在网上又花了多少个小时呢，玩了多久的游戏，看到了多久的网剧或者综艺（我小时候特别喜欢看电视剧，长大之后我其实没怎么看过电视剧，当然也看得不少，唉，说话总是前后矛盾）？亦或是刷了多久的抖音短视频（我刷B站，很少看抖音）以及朋友圈（同理朋友圈也很少）？</p><p>不管你是在手机还是电脑上，我相信你总有办法在网上虚度人，短则一天，长则一年，反正在互联网上消磨的时光永远不会嫌多。因为，在互联网上待的时间总是快乐的，同时也是短暂的。</p><p>如果你还没有想好如何在互联网上虚度一生，那么我想给你提出这么几个建议，让你更好的在互联网上浪费你的时间。</p><p>1、打游戏</p><p>英雄联盟（不会），DOTA2（不会），炉石传说（不会），绝地求生（不会），这些你都有对吗。这么多的游戏客户端放在桌面，相信你一个都不想放过。（这么一看我好像没有虚度光阴，接着往下看）</p><p>我相信你很快就能过完一个晚上甚至一天。我以前玩游戏的时候总是觉得时间过得很快，科学告诉我们，游戏会给人们带来兴奋的快感（要相信科学），以及不断的求胜欲望，促使你不断地想要赢得下一场游戏，相信有了兴奋感的催化作用，你一定能在游戏上花上更多时间。</p><p>不喜欢玩端游，那还有手游呢，王者荣耀（最近刚学会），和平精英（玩的很溜了都），自走棋（不会玩）全都撸一遍，上个黄金不是事啊。</p><p>你不知不觉，周末就结束了，明天又要上班了。</p><p>2、没事刷短视频</p><p>如果你的手机上还没有抖音、微视、快手三剑客（三剑客不玩，偶尔刷抖音），那么我建议你赶紧下载吧，比起游戏，刷短视频可能更加简单，你可以这件事情上体会到百分之百的快乐，因为你不会输掉游戏，也不需要打怪升级，你只需要轻轻往下一划，就可以看到下一个有趣的视频了。</p><p>你可以在抖音上看阿猫阿狗，看跳舞的小姐姐、小哥哥（我不怎么玩抖音就是因为里面的男的居然比我帅&lt;我信他个鬼&gt;，你肯定心里骂我是个臭不要脸的，哈哈哈，主要是我没女朋友&lt;为什么没女朋友，因为我的征途是星辰大海&gt;，越说越不要脸了，哈哈哈哈哈，其实是长得太磕碜）或者是一些滑稽搞笑的视频。</p><p>这样一来，你的周末又可以在愉快的刷刷刷中度过啦。</p><p>3、第三点，追剧追热点</p><p>什么？这周末你居然没有看综艺，你竟然没有追当下最火的那个电视剧，你 out 了！还不赶紧打开电视打开手机看看最近新出的这个新剧，而且这个谁谁谁不是最近刚出道不久的当红小鲜肉呢，可不要错过了（电视剧不怎么追&lt;主要是没有什么好看的电视剧，之前追过《将夜》&gt;，综艺现在几乎不看&lt;之前每期都看天天向上，改版之后不看了&gt;）。</p><p>什么？马伊琍和文章离婚了，赶紧看看微博热搜，把前 100 条都看一遍，这个评论太神了，那个评论简直搞笑好吗。要不再刷一下其他黑料，好在朋友圈里再吐槽一下。（微博不怎么看，主要下载之后不会玩，而且我看的时候喷子是真的多，真的多，真的多&lt;可能是我玩的姿势不对&gt;）</p><p>看完了微博，下一站去哪里呢？对了，当然是去知乎了（知乎偶尔玩）。看看第一个问题，你如何看待文章和马伊琍离婚？文章在微博上发的内容又是有什么含义呢？知乎大 V 吐槽就是犀利啊，刷完前十条还不过瘾，再把后面十条看一遍吧。</p><p>知乎也看完了，下一站去哪里呢？看看今天头条又给我推送了什么好玩的东西呢？震惊，某某公众号居然劝粉丝在网上虚度人生；BAT 等互联网公司将大范围裁员，你可能就是下一个牺牲者。</p><p>哎，又变得焦虑起来了，赶紧看看到底是怎么回事儿啦。咦，后面推荐的这三条内容好像有意思呢，我再看看，今日头条的推荐算法还是懂我呀。</p><p>本来只想看今天的头条发生了什么，我怎么一下子刷了这么多的文章呀？</p><p>如果以上技能你都已经掌握了，那么恭喜你，你可以非常轻松地虚度人生了，只要保持这几种习惯，坚持个十年八八年的，相信你就会在碌碌无为中虚度光阴，成为我们所向往的油腻中年人了。</p><p>上面说的已经够多了，但是我再推荐点<br>点开你的手机下载APP今日头条，可以开始刷头条了（这个是真的虚度光阴，我之前意识到之后，果断卸载了），还有一个不得不说的是B站（哔哩哔哩）我玩这个不是看什么二次元或者鬼畜的，我一开始看这个是因为学习视频，你掰着脚趾头都不会想到这个里面的学习视频很多，而且清晰度很不错，这点比百度云好。后来学着学着就漫无目的的刷起来其他的了。</p><p>说了这么多，你该懂我的意思了吧？</p><p>[做梦也没想到写一篇虚度人生的博客还需要参考]<a href="https://www.cnblogs.com/xll1025/p/11334816.html" target="_blank" rel="noopener">https://www.cnblogs.com/xll1025/p/11334816.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详情请阅读全文&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="虚度人生" scheme="http://yoursite.com/tags/%E8%99%9A%E5%BA%A6%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之多线程间通信</title>
    <link href="http://yoursite.com/2019/09/30/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/30/Java并发之多线程间通信/</id>
    <published>2019-09-30T10:28:24.000Z</published>
    <updated>2019-10-11T07:37:51.315Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中线程通信协作的最常见的两种方式：<br>一.syncrhoized 加锁的线程的 Object 类的 wait ()/notify ()/notifyAll ()<br>二.ReentrantLock 类加锁的线程的 Condition 类的 await()/signal()/signalAll()</p><a id="more"></a><h2 id="一-syncrhoized"><a href="#一-syncrhoized" class="headerlink" title="一.syncrhoized"></a>一.syncrhoized</h2><details>  <summary>△object类中方法说明△<此处需要点击></此处需要点击></summary>  <pre><code>    /**    *Wakes up a single thread that is waiting on this object's    *monitor. If any threads are waiting on this object, one of them    *is chosen to be awakened. The choice is arbitrary and occurs at    *the discretion of the implementation. A thread waits on an object's    *monitor by calling one of the wait methods    */   public final native void notify();<p>   /**<br>    *Wakes up all threads that are waiting on this object’s monitor. A<br>    *thread waits on an object’s monitor by calling one of the<br>    *wait methods.<br>    */<br>   public final native void notifyAll();</p><p>   /**<br>    *Causes the current thread to wait until either another thread invokes the<br>    *{@link java.lang.Object#notify()} method or the<br>    *{@link java.lang.Object#notifyAll()} method for this object, or a<br>    *specified amount of time has elapsed.<br>    *The current thread must own this object’s monitor.<br>    */<br>   public final native void wait(long timeout) throws InterruptedException;</p><p>  </p></code></pre><p></p></details><p>从这三个方法的文字描述可以知道以下几点信息：<br>1）wait ()、notify () 和 notifyAll () 方法是本地方法，并且为 final 方法，无法被重写。<br>2）调用某个对象的 wait () 方法能让当前线程阻塞，并且当前线程必须拥有此对象的 monitor（即锁）<br>3）调用某个对象的 notify () 方法能够唤醒一个正在等待这个对象的 monitor 的线程，如果有多个线程都在等待这个对象的 monitor，则只能唤醒其中一个线程；<br>4）调用 notifyAll () 方法能够唤醒所有正在等待这个对象的 monitor 的线程；<br>为何这三个不是 Thread 类声明中的方法，而是 Object 类中声明的方法（当然由于 Thread 类继承了 Object 类，所以 Thread 也可以调用者三个方法）？其实这个问题很简单，由于每个对象都拥有 monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。<br>上面已经提到，如果调用某个对象的 wait () 方法，当前线程必须拥有这个对象的 monitor（即锁），因此调用 wait () 方法必须在同步块或者同步方法中进行（synchronized 块或者 synchronized 方法）。如果当前线程没有这个对象的锁就调用 wait（）方法，则会抛出 IllegalMonitorStateException.<br>调用某个对象的 wait () 方法，相当于让当前线程交出（释放）此对象的 monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread 类中的 sleep 方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；　　<br>notify () 方法能够唤醒一个正在等待该对象的 monitor 的线程，当有多个线程都在等待该对象的 monitor 的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。 同样地，调用某个对象的 notify () 方法，当前线程也必须拥有这个对象的 monitor，因此调用 notify () 方法必须在同步块或者同步方法中进行（synchronized 块或者 synchronized 方法）。</p><p>nofityAll () 方法能够唤醒所有正在等待该对象的 monitor 的线程，这一点与 notify () 方法是不同的。</p><p>这里要注意一点：notify () 和 notifyAll () 方法只是唤醒等待该对象的 monitor 的线程，并不决定哪个线程能够获取到 monitor。</p><p>举个简单的例子：假如有三个线程 Thread1、Thread2 和 Thread3 都在等待对象 objectA 的 monitor，此时 Thread4 拥有对象 objectA 的 monitor，当在 Thread4 中调用 objectA.notify () 方法之后，Thread1、Thread2 和 Thread3 只有一个能被唤醒。注意，被唤醒不等于立刻就获取了 objectA 的 monitor。假若在 Thread4 中调用 objectA.notifyAll () 方法，则 Thread1、Thread2 和 Thread3 三个线程都会被唤醒，至于哪个线程接下来能够获取到 objectA 的 monitor 就具体依赖于操作系统的调度了。</p><p>上面尤其要注意一点，一个线程被唤醒不代表立即获取了对象的 monitor，只有等调用完 notify () 或者 notifyAll () 并退出 synchronized 块，释放对象锁后，其余线程才可获得锁执行。</p><ul><li>sleep/yield/join</li></ul><p>这一组是 Thread 类的方法</p><ul><li>sleep<br>让当前线程暂停指定时间，只是让出 CPU 的使用权，并不释放锁</li><li>yield<br>Thread.yield () 方法的作用：暂停当前正在执行的线程，并执行其他线程。（可能没有效果）<br>yield () 让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用 yield () 的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证 yield () 达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。​​​官方在其注释中也有相关的说明；<br>结论：大多数情况下，yield () 将导致线程从运行状态转到可运行状态，但有可能没有效果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* A hint to the scheduler that the current thread is willing to yield</span><br><span class="line">* its current use of a processor. The scheduler is free to ignore this</span><br><span class="line">* hint.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="line">* between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="line">* should be combined with detailed profiling and benchmarking to</span><br><span class="line">* ensure that it actually has the desired effect.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="line">* for debugging or testing purposes, where it may help to reproduce</span><br><span class="line">* bugs due to race conditions. It may also be useful when designing</span><br><span class="line">* concurrency control constructs such as the ones in the</span><br><span class="line">* &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class="line">*/​​</span><br><span class="line">        ​​​​</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">+ join</span><br><span class="line">等待调用 join 方法的线程执行结束，才执行后面的代码</span><br><span class="line">其调用一定要在 start 方法之后（看源码可知）​</span><br><span class="line">使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法​</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line">wait()会立刻释放synchronized（obj）中的obj锁，以便其他线程可以执行obj.notify(),但是notify()不会立刻立刻释放sycronized（obj）中的obj锁，必须要等notify()所在线程执行完synchronized（obj）块中的所有代码才会释放这把锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ wait()和sleep()区别</span><br><span class="line">1. wait 会释放锁资源而 sleep 不会释放锁资源.</span><br><span class="line">2. wait 只能在同步方法和同步块中使用，而 sleep 任何地方都可以.</span><br><span class="line">3. wait () 无参数需要唤醒，线程状态 WAITING；wait (1000L); 到时间自己醒过来或者到时间之前被其他线程唤醒，状态和 sleep 都是 TIME_WAITING</span><br><span class="line">4. wait 是 object 顶级父类的方法，sleep 则是 Thread 的方法</span><br><span class="line">5. 调用 wait 方法需要先获得锁，而调用 sleep 方法是不需要的。</span><br><span class="line">6. 调用 wait （没有指定wait时间）方法的线程需要用 notify 来唤醒，而 sleep 必须设置超时值。v</span><br><span class="line">+ ***两者相同点：都会抛出异常，都会让渡 CPU 执行时间，等待再次调度！***</span><br><span class="line"></span><br><span class="line">wait方法有三个重载方法，并且都会调用wait(long timeout)这个方法，wait()等价于wait(0)，0代表永不超时；</span><br><span class="line">Object的wait(long timeout)方法会导致当前线程进入阻塞，直到有其他线程调用了notify或者notifyall方法才能将其唤醒，或者是阻塞时间到达了timeout而自动唤醒；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wait () 方法与 sleep () 方法的不同之处在于，wait () 方法会释放对象的 “锁标志”。当调用某一对象的 wait () 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify () 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll () 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</span><br><span class="line">sleep () 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 sleep () 方法不会释放 “锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二.lock</span><br><span class="line"></span><br><span class="line">+ Condition 的特性:</span><br><span class="line"></span><br><span class="line">任何一个 java 对象都天然继承于 Object 类，在线程间实现通信的往往会应用到 Object 的几个方法，比如 wait (),wait (long timeout),wait (long timeout, int nanos) 与 notify (),notifyAll () 几个方法实现等待 / 通知机制，同样的， 在 java Lock 体系下依然会有同样的方法实现等待 / 通知机制。从整体上来看 Object 的 wait 和 notify/notify 是与对象监视器配合完成线程间的等待 / 通知机制，而 Condition 与 Lock 配合完成等待通知机制，前者是 java 底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。</span><br><span class="line"></span><br><span class="line">&gt; 功能特性上的不同：</span><br><span class="line"></span><br><span class="line">1.Condition 能够支持不响应中断，而通过使用 Object 方式不支持；</span><br><span class="line">2.Condition 能够支持多个等待队列（new 多个 Condition 对象），而 Object 方式只能支持一个；</span><br><span class="line">3.Condition 能够支持超时时间的设置，而 Object 不支持</span><br><span class="line"></span><br><span class="line">&gt;针对 Object 的 wait 方法</span><br><span class="line"></span><br><span class="line">1.void await () throws InterruptedException: 当前线程进入等待状态，如果其他线程调用 condition 的 signal 或者 signalAll 方法并且当前线程获取 Lock 从 await 方法返回，如果在等待状态中被中断会抛出被中断异常；</span><br><span class="line">2.long awaitNanos (long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；</span><br><span class="line">3.boolean await (long time, TimeUnit unit) throws InterruptedException：同第二种，支持自定义时间单位</span><br><span class="line">4.boolean awaitUntil (Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间</span><br><span class="line"></span><br><span class="line">&gt;针对 Object 的 notify/notifyAll 方法</span><br><span class="line"></span><br><span class="line">1.void signal ()：唤醒一个等待在 condition 上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到 Lock 则可以从等待方法中返回。</span><br><span class="line">2.void signalAll ()：与 1 的区别在于能够唤醒所有等待在 condition 上的线程</span><br><span class="line"></span><br><span class="line">### Condition 实现原理分析</span><br><span class="line"></span><br><span class="line">#### 等待队列</span><br><span class="line">创建一个 condition 对象是通过 lock.newCondition(), 而这个方法实际上是会 new 出一个 ConditionObject 对象，该类是 AQS 的一个内部类。condition 是要和 lock 配合使用的也就是 condition 和 Lock 是绑定在一起的，而 lock 的实现原理又依赖于 AQS，自然而然 ConditionObject 作为 AQS 的一个内部类无可厚非。我们知道在锁机制的实现上，AQS 内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，condition 内部也是使用同样的方式，内部维护了一个 等待队列，所有调用 condition.await 方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到 ConditionObject 中有两个成员变量：</span><br></pre></td></tr></table></figure><p>/** First node of condition queue. <em>/<br>private transient Node firstWaiter;<br>/*</em> Last node of condition queue. */<br>private transient Node lastWaiter;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### await 实现原理</span><br><span class="line">当调用 condition.await () 方法后会使得当前获取 lock 的线程进入到等待队列，如果该线程能够从 await () 方法返回的话一定是该线程获取了与 condition 相关联的 lock。接下来，我们还是从源码的角度去看，只有熟悉了源码的逻辑我们的理解才是最深的。await () 方法源码为：</span><br></pre></td></tr></table></figure><p>public final void await() throws InterruptedException {<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>    // 1. 将当前线程包装成Node，尾插入到等待队列中<br>    Node node = addConditionWaiter();<br>    // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点<br>    int savedState = fullyRelease(node);<br>    int interruptMode = 0;<br>    while (!isOnSyncQueue(node)) {<br>        // 3. 当前线程进入到等待状态<br>        LockSupport.park(this);<br>        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>            break;<br>    }<br>    // 4. 自旋等待获取到同步状态（即获取到lock）<br>    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    if (node.nextWaiter != null) // clean up if cancelled<br>        unlinkCancelledWaiters();<br>    // 5. 处理被中断的情况<br>    if (interruptMode != 0)<br>        reportInterruptAfterWait(interruptMode);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码的主要逻辑请看注释，我们都知道当当前线程调用 condition.await () 方法后，会使得当前线程释放 lock 然后加入到等待队列中，直至被 signal/signalAll 后会使得当前线程从等待队列中移至到同步队列中去，直到获得了 lock 后才会从 await 方法返回，或者在等待时被中断会做中断处理。那么关于这个实现过程我们会有这样几个问题：1. 是怎样将当前线程添加到等待队列中去的？2. 释放锁的过程？3. 怎样才能从 await 方法退出？而这段代码的逻辑就是告诉我们这三个问题的答案。具体请看注释，在第 1 步中调用 addConditionWaiter 将当前线程添加到等待队列中，该方法源码为：</span><br></pre></td></tr></table></figure><p>private Node addConditionWaiter() {<br>    Node t = lastWaiter;<br>    // If lastWaiter is cancelled, clean out.<br>    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    }<br>    //将当前线程包装成Node<br>    Node node = new Node(Thread.currentThread(), Node.CONDITION);<br>    if (t == null)<br>        firstWaiter = node;<br>    else<br>        //尾插入<br>        t.nextWaiter = node;<br>    //更新lastWaiter<br>    lastWaiter = node;<br>    return node;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码就很容易理解了，将当前节点包装成 Node，如果等待队列的 firstWaiter 为 null 的话（等待队列为空队列），则将 firstWaiter 指向当前的 Node, 否则，更新 lastWaiter (尾节点) 即可。就是通过尾插入的方式将当前线程封装的 Node 插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习 AQS 时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待对列之后，会使当前线程释放 lock，由 fullyRelease 方法实现，fullyRelease 源码为：</span><br></pre></td></tr></table></figure><p>final int fullyRelease(Node node) {<br>    boolean failed = true;<br>    try {<br>        int savedState = getState();<br>        if (release(savedState)) {<br>            //成功释放同步状态<br>            failed = false;<br>            return savedState;<br>        } else {<br>            //不成功释放同步状态抛出异常<br>            throw new IllegalMonitorStateException();<br>        }<br>    } finally {<br>        if (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这段代码就很容易理解了，调用 AQS 的模板方法 release 方法释放 AQS 的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从 await 方法退出？现在回过头再来看 await 方法有这样一段逻辑：</span><br></pre></td></tr></table></figure><p>while (!isOnSyncQueue(node)) {<br>    // 3. 当前线程进入到等待状态<br>    LockSupport.park(this);<br>    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>        break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">很显然，当线程第一次调用 condition.await () 方法时，会进入到这个 while () 循环中，然后通过 LockSupport.park (this) 方法使得当前线程进入等待状态，那么要想退出这个 await 方法第一个前提条件自然而然的是要先退出这个 while 循环，出口就只剩下两个地方：1. 逻辑走到 break 退出 while 循环；2. while 循环中的逻辑判断为 false。再看代码出现第 1 种情况的条件是当前等待的线程被中断后代码会走到 break 退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的 condition 的 signal 或者 signalAll 方法），while 中逻辑判断为 false 后结束 while 循环。总结下，就是 当前线程被中断或者调用 condition.signal/condition.signalAll 方法当前节点移动到了同步队列后 ，这是当前线程退出 await 方法的前提条件。当退出 while 循环后就会调用 acquireQueued(node, savedState)，这个方法在介绍 AQS 的底层实现时说过了，若感兴趣的话可以去看这篇文章，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到 lock）。这样也说明了退出 await 方法必须是已经获得了 condition 引用（关联）的 lock。到目前为止，开头的三个问题我们通过阅读源码的方式已经完全找到了答案，也对 await 方法的理解加深。await 方法示意图如下图：</span><br><span class="line">![](Java并发之多线程间通信/aaa.png)</span><br><span class="line">如图，调用 condition.await 方法的线程必须是已经获得了 lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的 Node 尾插入到等待队列中。</span><br><span class="line"></span><br><span class="line">+ 超时机制的支持</span><br><span class="line"></span><br><span class="line">condition 还额外支持了超时机制，使用者可调用方法 awaitNanos,awaitUtil。这两个方法的实现原理，基本上与 AQS 中的 tryAcquire 方法如出一辙.</span><br><span class="line"></span><br><span class="line">+ 不响应中断的支持</span><br><span class="line"></span><br><span class="line">要想不响应中断可以调用 condition.awaitUninterruptibly () 方法，该方法的源码为：</span><br></pre></td></tr></table></figure><p>public final void awaitUninterruptibly() {<br>    Node node = addConditionWaiter();<br>    int savedState = fullyRelease(node);<br>    boolean interrupted = false;<br>    while (!isOnSyncQueue(node)) {<br>        LockSupport.park(this);<br>        if (Thread.interrupted())<br>            interrupted = true;<br>    }<br>    if (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这段方法与上面的 await 方法基本一致，只不过减少了对中断的处理，并省略了 reportInterruptAfterWait 方法抛被中断的异常。</span><br><span class="line"></span><br><span class="line">#### signal/signalAll 实现原理</span><br><span class="line">调用 condition 的 signal 或者 signalAll 方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得 lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用 condition 的 signal 方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal 方法源码为：</span><br></pre></td></tr></table></figure><p>public final void signal() {<br>    //1. 先检测当前线程是否已经获取lock<br>    if (!isHeldExclusively())<br>        throw new IllegalMonitorStateException();<br>    //2. 获取等待队列中第一个节点，之后的操作都是针对这个节点<br>    Node first = firstWaiter;<br>    if (first != null)<br>        doSignal(first);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal 方法首先会检测当前线程是否已经获取 lock，如果没有获取 lock 会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的 doSignal 方法也是基于该节点。下面我们来看看 doSignal 方法做了些什么事情，doSignal 方法源码为：</span><br></pre></td></tr></table></figure><p>private void doSignal(Node first) {<br>    do {<br>        if ( (firstWaiter = first.nextWaiter) == null)<br>            lastWaiter = null;<br>        //1. 将头结点从等待队列中移除<br>        first.nextWaiter = null;<br>        //2. while中transferForSignal方法对头结点做真正的处理<br>    } while (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != null);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体逻辑请看注释，真正对头节点做处理的逻辑在 transferForSignal 放，该方法源码为：</span><br></pre></td></tr></table></figure><p>final boolean transferForSignal(Node node) {<br>    /*<br>     * If cannot change waitStatus, the node has been cancelled.<br>     */<br>    //1. 更新状态为0<br>    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))<br>        return false;</p><pre><code>/* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). *///2.将该节点移入到同步队列中去Node p = enq(node);int ws = p.waitStatus;if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))    LockSupport.unpark(node.thread);return true;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键逻辑请看注释，这段代码主要做了两件事情 1. 将头结点的状态更改为 CONDITION；2. 调用 enq 方法，将该节点尾插入到同步队列中，关于 enq 方法请看 AQS 的底层实现这篇文章。现在我们可以得出结论：调用 condition 的 signal 的前提条件是当前线程已经获取了 lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从 await 方法中的 LockSupport.park (this) 方法中返回，从而才有机会使得调用 await 方法的线程成功退出。signal 执行示意图如下图：</span><br><span class="line">![](Java并发之多线程间通信/bbb.png)</span><br><span class="line">sigllAll 与 sigal 方法的区别体现在 doSignalAll 方法上，前面我们已经知道 doSignal 方法只会对等待队列的头节点进行操作，，而 doSignalAll 的源码为：</span><br></pre></td></tr></table></figure><p>private void doSignalAll(Node first) {<br>    lastWaiter = firstWaiter = null;<br>    do {<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = null;<br>        transferForSignal(first);<br>        first = next;<br>    } while (first != null);<br>}</p><pre><code>该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即 “通知” 当前调用 condition.await ()方法的每一个线程。[参考链接]https://www.cnblogs.com/tiancai/p/9371655.html[参考链接]https://www.artima.com/insidejvm/ed2/threadsynch.html[参考链接]https://time.geekbang.org/column/article/85241[参考链接]https://www.cnblogs.com/xdyixia/p/9386133.html[参考链接]https://www.cnblogs.com/Wanted-Tao/p/6378942.html[参考链接]https://juejin.im/post/5aeea5e951882506a36c67f0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中线程通信协作的最常见的两种方式：&lt;br&gt;一.syncrhoized 加锁的线程的 Object 类的 wait ()/notify ()/notifyAll ()&lt;br&gt;二.ReentrantLock 类加锁的线程的 Condition 类的 await()/signal()/signalAll()&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程通信" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之内存模型和happens-before规则</title>
    <link href="http://yoursite.com/2019/09/29/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/09/29/java多线程之内存模型和happens-before规则/</id>
    <published>2019-09-29T10:28:24.000Z</published>
    <updated>2019-09-30T06:50:19.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。</p><a id="more"></a><p>JMM 是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的。</p><p>JMM 是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。</p><p>Java 内存模型把 Java 虚拟机内部划分为线程栈和堆。</p><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>每一个运行在 Java 虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p><p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆上包含在 Java 程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p><p>一个本地变量可能是原始类型，在这种情况下，它总是在线程栈上。 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。 静态成员变量跟随着类定义一起也存放在堆上。 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="/2019/09/29/java多线程之内存模型和happens-before规则/1556440274529751.jpg" alt></p><h3 id="多线程可见性"><a href="#多线程可见性" class="headerlink" title="多线程可见性"></a>多线程可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其它线程能够适时得知这个修改。在单线程环境中，如果在程序前面修改了某个变量的值，后面的程序一定会读取到那个变量的新值。这看起来很自然，然而当变量的写操作和读操作在不同的线程中时，情况却并非如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *《Java并发编程实战》27页程序清单3-1</span><br><span class="line"> */</span><br><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready; </span><br><span class="line">    private static int number;</span><br><span class="line">    </span><br><span class="line">    private static class ReaderThread extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ReaderThread().start(); //启动一个线程</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，主线程和读线程都访问共享变量 ready 和 number。程序看起来会输出 42（输出42是正常思维，就是number和ready被复制之后没一会就将值更新到了主内存，更新到主内存之后，等其他线程到主内存中读取值的时候就可以看到修改后的值），但事实上很可能会输出 0，或者根本无法终止。这是因为上面的程序缺少线程间变量可见性的保证，所以在主线程中写入的变量值，可能无法被读线程感知到。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作 Happens-Before 书写在后面的代码操作。这时因为 Java 语言规范要求 JVM 在单个线程内部要维护类似严格串行的语义，如果多个操作之间有<strong><em>先后依赖关系</em></strong>，则不允许对这些操作进行重排序。</p><h3 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h3><p>对锁 M 解锁之前的所有操作 Happens-Before 对锁 M 加锁之后的所有操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class HappensBeforeLock &#123;</span><br><span class="line">    private int value = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，setValue 和 getValue 两个方法共享同一个监视器锁。假设 setValue 方法在线程 A 中执行，getValue 方法在线程 B 中执行。setValue 方法会先对 value 变量赋值，然后释放锁。getValue 方法会先获取到同一个锁后，再读取 value 的值。所以根据锁定原则，线程 A 中对 value 变量的修改，可以被线程 B 感知到。<br>如果这个两个方法上没有 synchronized 声明，则在线程 A 中执行 setValue 方法对 value 赋值后，线程 B 中 getValue 方法返回的 value 值并不能保证是最新值。<br>本条锁定规则对显示锁 (ReentrantLock) 和内置锁 (synchronized) 在加锁和解锁等操作上有着相同的内存语义。<br>对于锁定原则，可以像下面这样去理解：同一时刻只能有一个线程执行锁中的操作，所以锁中的操作被重排序外界是不关心的，只要最终结果能被外界感知到就好。除了重排序，剩下影响变量可见性的就是 CPU 缓存了。在锁被释放时，A 线程会把释放锁之前所有的操作结果同步到主内存中，而在获取锁时，B 线程会使自己 CPU 的缓存失效，重新从主内存中读取变量的值。这样，A 线程中的操作结果就会被 B 线程感知到了。</p><h3 id="传递性规则"><a href="#传递性规则" class="headerlink" title="传递性规则"></a>传递性规则</h3><p>如果操作 A Happens-Before B，B Happens-Before C，那么可以得出操作 A Happens-Before C。</p><h3 id="volatile-变量规则"><a href="#volatile-变量规则" class="headerlink" title="volatile 变量规则"></a>volatile 变量规则</h3><blockquote><p>对一个 volatile 变量的写操作及这个写操作之前的所有操作 Happens-Before 对这个变量的读操作及这个读操作之后的所有操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line">char[] configText; //线程间共享变量，用于保存配置信息</span><br><span class="line">// 此变量必须定义为volatile</span><br><span class="line">volatile boolean initialized = false;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程A中执行</span><br><span class="line">// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程B中执行</span><br><span class="line">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span><br><span class="line">while (!initialized) &#123;    </span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">//使用线程A中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>上面这段代码，读取配置文件的操作和使用配置信息的操作分别在两个不同的线程 A、B 中执行，两个线程通过共享变量 configOptions 传递配置信息，并通过共享变量 initialized 作为初始化是否完成的通知。initialized 变量被声明为 volatile 类型的，根据 volatile 变量规则，volatile 变量的写入操作 Happens-Before 对这个变量的读操作，所以在线程 A 中将变量 initialized 设为 true，线程 B 中是可以感知到这个修改操作的。<br>但是更牛逼的是，volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作对其它线程的可见性。考虑这样一种情况，如果 volatile 变量仅能保证自己的变量可见性，那么当线程 B 感知到 initialized 已经变成 true 然后执行 doSomethingWithConfig 操作时，可能无法获取到 configOptions 最新值而导致操作结果错误。所以 volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作 Happens-Before 书写在 volatile 变量读操作之后的那些操作。<br>可以这样理解 volatile 变量的写入和读取操作流程：<br>首先，volatile 变量的操作会禁止与其它普通变量的操作进行重排序，例如上面代码中会禁止 initialized = true 与它上面的两行代码进行重排序 (但是它上面的代码之间是可以重排序的)，否则会导致程序结果错误。volatile 变量的写操作就像是一条基准线，到达这条线之后，不管之前的代码有没有重排序，反正到达这条线之后，前面的操作都已完成并生成好结果。<br>然后，在 volatile 变量写操作发生后，A 线程会把 volatile 变量本身和书写在它之前的那些操作的执行结果一起同步到主内存中。<br>最后，当 B 线程读取 volatile 变量时，B 线程会使自己的 CPU 缓存失效，重新从主内存读取所需变量的值，这样无论是 volatile 本身，还是书写在 volatile 变量写操作之前的那些操作结果，都能让 B 线程感知到，也就是上面程序中的 initialized 和 configOptions 变量的最新值都可以让线程 B 感知到。<br>原子变量与 volatile 变量在读操作和写操作上有着相同的语义。</p><h3 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h3><p>Thread 对象的 start 方法及书写在 start 方法前面的代码操作 Happens-Before 此线程的每一个动作。<br>start 方法和新线程中的动作一定是在两个不同的线程中执行。线程启动规则可以这样去理解：调用 start 方法时，会将 start 方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在 start 方法调用之前的所有操作结果对于新创建的线程都是可见的。</p><h3 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h3><p>线程中的任何操作都 Happens-Before 其它线程检测到该线程已经结束。这个说法有些抽象，下面举例子对其进行说明。<br>假设两个线程 s、t。在线程 s 中调用 t.join () 方法。则线程 s 会被挂起，等待 t 线程运行结束才能恢复执行。当 t.join () 成功返回时，s 线程就知道 t 线程已经结束了。所以根据本条原则，在 t 线程中对共享变量的修改，对 s 线程都是可见的。类似的还有 Thread.isAlive 方法也可以检测到一个线程是否结束。<br>可以猜测，当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程 A 对共享变量的修改，对于其它检测了 A 线程是否结束的线程是可见的。</p><h3 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h3><p>一个线程在另一个线程上调用 interrupt,Happens-Before 被中断线程检测到 interrupt 被调用。<br>假设两个线程 A 和 B，A 先做了一些操作 operationA，然后调用 B 线程的 interrupt 方法。当 B 线程感知到自己的中断标识被设置时 (通过抛出 InterruptedException，或调用 interrupted 和 isInterrupted),operationA 中的操作结果对 B 都是可见的。</p><p>[参考链接]<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011458941</a><br>[参考链接]<a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="noopener">http://ifeve.com/java-memory-model-6/</a><br>[参考链接]<a href="http://ifeve.com/memory-model/" target="_blank" rel="noopener">http://ifeve.com/memory-model/</a><br>[参考链接]<a href="http://ifeve.com/from-singleton-happens-before/" target="_blank" rel="noopener">http://ifeve.com/from-singleton-happens-before/</a><br>[参考链接]<a href="http://blog.itpub.net/69917606/viewspace-2642808/" target="_blank" rel="noopener">http://blog.itpub.net/69917606/viewspace-2642808/</a><br>[参考链接]<a href="https://www.jianshu.com/p/4455e4234d5c" target="_blank" rel="noopener">https://www.jianshu.com/p/4455e4234d5c</a><br>[参考链接]<a href="https://www.jianshu.com/p/15106e9c4bf3" target="_blank" rel="noopener">https://www.jianshu.com/p/15106e9c4bf3</a><br>参考书籍《Java并发编程艺术》第三章，《Java并发编程实战》第三章，第十六章，《深入理解Java内存模型》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h3&gt;&lt;p&gt;JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-内存模型、happens-before规则" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81happens-before%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之CAS</title>
    <link href="http://yoursite.com/2019/09/28/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCAS/"/>
    <id>http://yoursite.com/2019/09/28/java多线程之CAS/</id>
    <published>2019-09-28T10:28:24.000Z</published>
    <updated>2019-10-09T02:47:51.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS概念"><a href="#CAS概念" class="headerlink" title="CAS概念"></a>CAS概念</h3><p>CAS 是英文单词 CompareAndSwap 的缩写，中文意思是：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。<br>CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就什么都不做。整个比较并替换的操作是一个原子操作。<br>CAS 有效地说明了 “我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”<br><strong>在多线程的情况下，当多个线程同时使用 CAS 操作一个变量时，只有一个会成功并更新值，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试。正是基于这样的原理，CAS 即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。可见 CAS 其实是一个乐观锁。</strong></p><a id="more"></a><h3 id="CAS算法在Java中的作用"><a href="#CAS算法在Java中的作用" class="headerlink" title="CAS算法在Java中的作用"></a>CAS算法在Java中的作用</h3><p>在 JDK 5 之前 Java 语言是靠 synchronized 关键字保证同步的，这会导致有锁。<br>锁机制存在以下问题：<br>1.在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>2.一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>3.如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile 是不错的机制，但是 volatile 不能保证原子性。因此对于同步最终还是要回到锁机制上来。<br>独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>学过synchronized关键字之后，我们可以保证i++操作是原子操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increase()&#123;</span><br><span class="line">    race++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种自增操作每次都会加锁，性能可能会稍微差点。<br>比较好一点的方案是使用Java并发包原子操作类（Atomic开头），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static AtomicInteger race = new AtomicInteger(0);</span><br><span class="line">public static void increase()&#123;</span><br><span class="line">    //race++; 非原子操作，取值，加1，写值</span><br><span class="line">    race.getAndIncrement()//原子操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndIncrement 方法调用 getAndAddInt 方法，最后调用的是 compareAndSwapInt 方法，即本文的主角 CAS，接下来我们开始介绍 CAS（终于开始说CAS了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the previous value</span><br><span class="line"> */</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndAddInt 方法解析：拿到内存位置的最新值 v，使用 CAS 尝试修将内存位置的值修改为目标值 v+delta，如果修改失败，则获取该内存位置的新值 v，然后继续尝试，直至修改成功。</p><h3 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h3><p>简单讲一下这个类。Java 无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个类 Unsafe，它提供了硬件级别的原子操作。<br>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。<br>从第一行的描述可以了解到 Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native long staticFieldOffset(Field paramField);</span><br></pre></td></tr></table></figure><p>这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。</p><h3 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h3><ul><li>CAS 虽然很高效的解决原子操作，但是 CAS 仍然存在三大问题：</li></ul><p>1.ABA 问题。因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B-3A。</p><p>从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>2.循环时间长开销大。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）, 使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</p><p>3.只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i＝2,j=a，合并一下 ij=2a，然后用 CAS 来操作 ij。从 Java1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p><h3 id="什么是-ABA-问题？ABA-问题怎么解决？"><a href="#什么是-ABA-问题？ABA-问题怎么解决？" class="headerlink" title="什么是 ABA 问题？ABA 问题怎么解决？"></a>什么是 ABA 问题？ABA 问题怎么解决？</h3><p>如果在这段期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA” 问题。Java 并发包为了解决这个问题，提供了一个带有标记的原子引用类 “AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。因此，在使用 CAS 前要考虑清楚 “ABA” 问题是否会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><p>[参考链接]<a href="https://blog.csdn.net/weixin_37598682/article/details/81285176" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37598682/article/details/81285176</a><br>[参考链接]<a href="https://blog.csdn.net/v123411739/article/details/79561458" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458</a><br>[参考链接]<a href="https://blog.csdn.net/fuzhongmin05/article/details/91400317" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/91400317</a><br>[参考链接]<a href="https://blog.csdn.net/zhoutaopower/article/details/86598839" target="_blank" rel="noopener">https://blog.csdn.net/zhoutaopower/article/details/86598839</a><br>[参考链接]<a href="https://www.jianshu.com/p/f0d6e7103d9b" target="_blank" rel="noopener">https://www.jianshu.com/p/f0d6e7103d9b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CAS概念&quot;&gt;&lt;a href=&quot;#CAS概念&quot; class=&quot;headerlink&quot; title=&quot;CAS概念&quot;&gt;&lt;/a&gt;CAS概念&lt;/h3&gt;&lt;p&gt;CAS 是英文单词 CompareAndSwap 的缩写，中文意思是：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。&lt;br&gt;CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就什么都不做。整个比较并替换的操作是一个原子操作。&lt;br&gt;CAS 有效地说明了 “我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”&lt;br&gt;&lt;strong&gt;在多线程的情况下，当多个线程同时使用 CAS 操作一个变量时，只有一个会成功并更新值，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试。正是基于这样的原理，CAS 即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。可见 CAS 其实是一个乐观锁。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-CAS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之AQS</title>
    <link href="http://yoursite.com/2019/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/09/27/Java多线程之AQS/</id>
    <published>2019-09-27T10:28:24.000Z</published>
    <updated>2019-10-09T09:05:50.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS概念"><a href="#AQS概念" class="headerlink" title="AQS概念"></a>AQS概念</h3><p>AQS是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。</p><a id="more"></a><h3 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h3><p>先来看看 AQS (即AbstractQueuedSynchronizer )有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="line">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，之后分析过程中所说的 queue，也就是<strong><em>阻塞队列不包含 head</em></strong><br><img src="/2019/09/27/Java多线程之AQS/aqs.png" alt></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class Node &#123;</span><br><span class="line">    // 标识节点当前在共享模式下</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标识节点当前在独占模式下</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // ======== 下面的几个int常量是给waitStatus用的 ===========</span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    // 代表此线程取消了争抢这个锁</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    // 不分析，略过吧</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    // =====================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br><span class="line">    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br><span class="line">    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    // 前驱节点的引用</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    // 后继节点的引用</span><br><span class="line">    volatile Node next;</span><br><span class="line">    // 这个就是线程本尊</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已（而已只是说说，其实真难&lt;我觉得&gt;）</p><p>我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。<br><img src="/2019/09/27/Java多线程之AQS/aqs-1.png" alt></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ReentrantLock reentrantLock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line">      // 争锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br><span class="line">    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br><span class="line">    // 否则，acquireQueued方法会将线程压到队列中</span><br><span class="line">    public final void acquire(int arg) &#123; // 此时 arg == 1</span><br><span class="line">        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">        // 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br><span class="line">        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br><span class="line">    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        // state == 0 此时此刻没有线程持有锁</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br><span class="line">            // 看看有没有别人在队列中等了半天了</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br><span class="line">                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br><span class="line">                // 因为刚刚还没人的，我判断过了</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br><span class="line">        // 这里不存在并发问题</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br><span class="line">        // 回到上面一个外层调用方法继续看:</span><br><span class="line">        // if (!tryAcquire(arg) </span><br><span class="line">        //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">        //     selfInterrupt();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br><span class="line">      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br><span class="line">    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates and enqueues node for current thread and given mode.</span><br><span class="line">     *</span><br><span class="line">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line">     * @return the new node</span><br><span class="line">     */</span><br><span class="line">    // 此方法的作用是把线程包装成node，同时进入到队列中</span><br><span class="line">    // 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br><span class="line">        if (pred != null) &#123; </span><br><span class="line">            // 将当前的队尾节点，设置为自己的前驱 </span><br><span class="line">            node.prev = pred; </span><br><span class="line">            // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br><span class="line">                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br><span class="line">                pred.next = node;</span><br><span class="line">                // 线程入队了，可以返回了</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仔细看看上面的代码，如果会到这里，</span><br><span class="line">        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br><span class="line">        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line">     * @param node the node to insert</span><br><span class="line">     * @return node&apos;s predecessor</span><br><span class="line">     */</span><br><span class="line">    // 采用自旋的方式入队</span><br><span class="line">    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br><span class="line">    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br><span class="line">    private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 之前说过，队列为空也会进来这里</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                // 初始化head节点</span><br><span class="line">                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br><span class="line">                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br><span class="line"></span><br><span class="line">                    // 这个时候有了head，但是tail还是null，设置一下，</span><br><span class="line">                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br><span class="line">                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br><span class="line">                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下面几行，和上一个方法 addWaiter 是一样的，</span><br><span class="line">                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 现在，又回到这段代码了</span><br><span class="line">    // if (!tryAcquire(arg) </span><br><span class="line">    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">    //     selfInterrupt();</span><br><span class="line"></span><br><span class="line">    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br><span class="line">    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br><span class="line">    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br><span class="line">    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br><span class="line">                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br><span class="line">                // 所以当前节点可以去试抢一下锁</span><br><span class="line">                // 这里我们说一下，为什么可以去试试：</span><br><span class="line">                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br><span class="line">                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br><span class="line">                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br><span class="line">                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br><span class="line">                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 什么时候 failed 会为 true???</span><br><span class="line">            // tryAcquire() 方法抛异常的情况</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Checks and updates status for a node that failed to acquire.</span><br><span class="line">     * Returns true if thread should block. This is the main signal</span><br><span class="line">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="line">     *</span><br><span class="line">     * @param pred node&apos;s predecessor holding status</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @return &#123;@code true&#125; if thread should block</span><br><span class="line">     */</span><br><span class="line">    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br><span class="line">    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br><span class="line">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br><span class="line">        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br><span class="line">        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br><span class="line">        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br><span class="line">        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            // 仔细想想，如果进入到这个分支意味着什么</span><br><span class="line">            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br><span class="line">            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br><span class="line">            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br><span class="line">            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个方法返回 false，那么会再走一次 for 循序，</span><br><span class="line">        //     然后再次进来此方法，此时会从第一个分支返回 true</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br><span class="line">    // 这个方法结束根据返回值我们简单分析下：</span><br><span class="line">    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br><span class="line">    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br><span class="line">    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br><span class="line"></span><br><span class="line">    // 跳回到前面是这个方法</span><br><span class="line">    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    //                parkAndCheckInterrupt())</span><br><span class="line">    //                interrupted = true;</span><br><span class="line"></span><br><span class="line">    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br><span class="line">    // 那么需要执行parkAndCheckInterrupt():</span><br><span class="line"></span><br><span class="line">    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br><span class="line">    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br><span class="line">    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br><span class="line"></span><br><span class="line">   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br><span class="line"></span><br><span class="line">    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br><span class="line">    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h3><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 往后看吧</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到ReentrantLock看tryRelease方法</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放锁</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wakes up node&apos;s successor, if one exists.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">// 唤醒后继节点</span><br><span class="line">// 从上面调用处知道，参数node是head头结点</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br><span class="line">    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 刚刚线程被挂起在这里了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><p>1.锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state 进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock () 和 unlock () 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。<br>2.线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park (thread) 来挂起线程，用 unpark 来唤醒线程。<br>3.阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于 CLH 的介绍，写得简单明了。</p><h3 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h3><p>下面属于回顾环节，用简单的示例来说一遍。</p><p>首先，第一个线程调用 reentrantLock.lock ()，翻到最前面可以发现，tryAcquire (1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock () 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock () 之前，线程 2 调用了 lock (), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node ()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0<br><img src="/2019/09/27/Java多线程之AQS/aqs-2.png" alt><br>然后线程 2 入队：<br><img src="/2019/09/27/Java多线程之AQS/aqs-3.png" alt><br>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的 waitStatus 设置为 -1。<br>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；<br>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。<br><img src="/2019/09/27/Java多线程之AQS/aqs-4.png" alt><br>这里可以简单说下 waitStatus 中 SIGNAL (-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus 代表后继节点的状态” 这种思路去看一遍源码。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的 lock 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="line"> */</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：公平锁和非公平锁只有两处不同：</p></blockquote><p>1.非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>2.非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。<br>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p>[主要参考&lt;说句不要脸的话就是我抄人家的，不过人家写的是真好，其他博客也值得一看&gt;]<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a><br>[参考链接]<a href="https://www.cnblogs.com/xll1025/p/11335107.html" target="_blank" rel="noopener">https://www.cnblogs.com/xll1025/p/11335107.html</a><br>[参考链接-模板模式]<a href="https://www.jianshu.com/p/f44c6380f52b" target="_blank" rel="noopener">https://www.jianshu.com/p/f44c6380f52b</a><br>[参考链接-模板模式]<a href="https://www.cnblogs.com/qq-361807535/p/6854191.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq-361807535/p/6854191.html</a><br>[写这个链接主要是因为写的还不错]<a href="https://www.codercto.com/a/41447.html" target="_blank" rel="noopener">https://www.codercto.com/a/41447.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AQS概念&quot;&gt;&lt;a href=&quot;#AQS概念&quot; class=&quot;headerlink&quot; title=&quot;AQS概念&quot;&gt;&lt;/a&gt;AQS概念&lt;/h3&gt;&lt;p&gt;AQS是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），JUC 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 JUC 并发包中的核心基础组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-AQS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之lock</title>
    <link href="http://yoursite.com/2019/09/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Block/"/>
    <id>http://yoursite.com/2019/09/26/Java多线程之lock/</id>
    <published>2019-09-26T10:28:24.000Z</published>
    <updated>2019-10-08T07:32:41.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>Java 从 Java SE 5 之后在并发包中提供 Lock 接口。在 java.util.concurrent.locks 包中有很多 Lock 的实现类，常用的有 ReentrantLock、ReadWriteLock（实现类 ReentrantReadWriteLock），其实现都依赖 java.util.concurrent.AbstractQueuedSynchronizer 类，实现思路都大同小异，因此我们以 ReentrantLock 作为讲解切入点。Lock 锁，可以得到和 synchronized 一样的效果，即实现原子性、有序性和可见性。相较于 synchronized，Lock 锁可手动获取锁和释放锁、可中断的获取锁、超时获取锁。Lock 是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。</p><a id="more"></a><p>Lock 锁的基本用法， l.lock () 方法进行上锁， l.unlock () 方法进行解锁，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">l.lock(); // 上锁</span><br><span class="line">try &#123;</span><br><span class="line">  // access the resource protected by this lock</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  l.unlock(); // 解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-应用场景举例"><a href="#Lock-应用场景举例" class="headerlink" title="Lock 应用场景举例"></a>Lock 应用场景举例</h3><ul><li>解决获取锁的等待问题<br>如果占有锁的线程 A 由于各种原因导致阻塞而没有释放锁，此时其他线程 B 也需要获得该锁。synchronized 的机制是让 B 持续等待，如果 A 一直没有释放锁，那么 B 将一直等待，这会很大程度影响执行的效率；而 Lock 中提供了中断线程等待的方法，也提供了带有超时时间的获取锁的方法，后面会讲到这些方法。</li><li>读写锁的分离<br>我们知道，多线程仅仅是执行读操作的话是没有冲突问题的，因而在读操作时的锁没必要是独占的。synchronized 实现同步就会导致在读操作时只能有一个线程获得锁，其他线程只能等待锁的释放。Lock 中的 ReentrantReadWriteLock 很好的解决了这个问题。</li><li>其他锁的操作<br>如获知当前线程是否成功获得锁等，synchronized 是做不到的。</li></ul><h3 id="Lock-锁常用方法"><a href="#Lock-锁常用方法" class="headerlink" title="Lock 锁常用方法"></a>Lock 锁常用方法</h3><table><thead><tr><th align="center">修饰符和类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">lock（）</td><td align="center">获得锁。</td></tr><tr><td align="center">void</td><td align="center">lockInterruptibly​()</td><td align="center">获得锁，可中断。举个例子，当两个线程同时通过 lock.lockInterruptibly () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 threadB.interrupt () 方法能够中断线程 B 的等待过程。</td></tr><tr><td align="center">boolean</td><td align="center">tryLock​()</td><td align="center">锁在空闲的才能获取锁（未获得锁不会等待）。举个例子：当两个线程同时通过 lock.trylock () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 不会等待，直接放弃获取锁。</td></tr><tr><td align="center">boolean</td><td align="center">tryLock​(long time, TimeUnit unit)</td><td align="center">如果锁定可用，则此方法立即返回值 true。如果锁不可用，则当前线程将被禁用以进行线程调度，并且在发生以下三种情况之一之前处于休眠状态：①当前线程获取锁。②其他一些线程中断当前线程。③等待时间过去了，返回 false</td></tr><tr><td align="center">void</td><td align="center">unlock​()</td><td align="center">释放锁。</td></tr></tbody></table><blockquote><p>注意事项：</p><ul><li>Lock 的实例一般定义为成员变量，如果定义为局部变量，每个线程都会保存一个自己的副本，那么在获取锁的操作时，实际每个线程获取的是不同的锁，无法形成同步互斥访问。</li><li>获取锁的操作要放在 try 模块之外，原因是如果放在 try 模块内的话，当获取锁的操作发生异常会调用 finally 中的代码释放锁，而此时可能并没有获取锁，就会抛出异常。</li></ul></blockquote><p>1.lock()<br>特点：发生异常不自动释放锁；如果没有获取到锁会等待；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock(); //创建锁</span><br><span class="line"></span><br><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock(); //获得锁</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.print(&quot;业务处理&quot;); //任务处理</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock(); //释放锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.tryLock()<br>特点：带有 boolean 型返回值；无论是否成功获取锁会立即返回不进行等待；也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock(); //创建锁</span><br><span class="line"></span><br><span class="line">public void getLock() &#123;</span><br><span class="line"></span><br><span class="line">    if(lock.tryLock()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.print(&quot;业务处理&quot;); //任务处理</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); //释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">           System.out.print(&quot;获取锁失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.tryLock(long time, TimeUnit unit)<br>特点：可以设置获取锁的等待时间，如 tryLock (4, TimeUnit.SECONDS) 等待 4 秒；可以在等待过程中相应中断；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> Lock l = new ReentrantLock();</span><br><span class="line"> try &#123;</span><br><span class="line">    if (l.tryLock(4000, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;获取锁&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;: &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l.unlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;未获取锁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.lockInterruptibly()　</p><p>　　lockInterruptibly () 方法比较特殊，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够 响应中断，即中断线程的等待状态。例如，当两个线程同时通过 lock.lockInterruptibly () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 threadB.interrupt () 方法能够中断线程 B 的等待过程。</p><p>　　由于 lockInterruptibly () 的声明中抛出了异常，所以 lock.lockInterruptibly () 必须放在 try 块中或者在调用 lockInterruptibly () 的方法外声明抛出 InterruptedException，但推荐使用后者，原因稍后阐述。因此，lockInterruptibly () 一般的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //.....</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.ReentrantReadWriteLock</p><p>ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个方法：readLock () 和 writeLock () 用来获取读锁和写锁。<br>假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出结果会是，直到 thread1 执行完读操作之后，才会打印 thread2 执行读操作的信息。</p><p>而改成用读写锁的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    public void get(Thread thread) &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">             </span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread1 和 thread2 在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><blockquote><p>注意<br>当一个线程获取了锁之后，是不会被 interrupt () 方法中断的。因为 interrupt () 方法只能中断阻塞过程中的线程而不能中断正在运行过程中的线程。因此，当通过 lockInterruptibly () 方法获取某个锁时，如果不能获取到，那么只有进行等待的情况下，才可以响应中断的。与 synchronized 相比，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><blockquote><p>可中断锁<br>顾名思义，可中断锁就是可以响应中断的锁。在 Java 中，synchronized 就不是可中断锁，而 Lock 是可中断锁。<br>如果某一线程 A 正在执行锁中的代码，另一线程 B 正在等待获取该锁，可能由于等待时间过长，线程 B 不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。在前面演示 tryLock (long time, TimeUnit unit) 和 lockInterruptibly () 的用法时已经体现了 Lock 的可中断性。</p></blockquote><blockquote><p>Lock 和 synchronized 有以下几点不同：</p></blockquote><p>　　1）Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现，synchronized 是在 JVM 层面上实现的，不但可以通过一些监控工具监控 synchronized 的锁定，而且在代码执行时出现异常，JVM 会自动释放锁定，但是使用 Lock 则不行，lock 是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock () 放到 finally {} 中；</p><p>　　2）synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock () 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；</p><p>　　3）Lock 可以让等待锁的线程响应中断，线程可以中断去干别的事务，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><p>　　5）Lock 可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于 synchronized。所以说，在具体使用时要根据适当情况选择。</p><p>[参考链接]<a href="https://blog.csdn.net/qq_38737992/article/details/89607758" target="_blank" rel="noopener">https://blog.csdn.net/qq_38737992/article/details/89607758</a><br>[参考链接]<a href="https://blog.csdn.net/qq_25160969/article/details/71335362" target="_blank" rel="noopener">https://blog.csdn.net/qq_25160969/article/details/71335362</a><br>[参考链接]<a href="https://www.cnblogs.com/dolphin0520/p/3923167.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923167.html#!comments</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h3&gt;&lt;p&gt;Java 从 Java SE 5 之后在并发包中提供 Lock 接口。在 java.util.concurrent.locks 包中有很多 Lock 的实现类，常用的有 ReentrantLock、ReadWriteLock（实现类 ReentrantReadWriteLock），其实现都依赖 java.util.concurrent.AbstractQueuedSynchronizer 类，实现思路都大同小异，因此我们以 ReentrantLock 作为讲解切入点。Lock 锁，可以得到和 synchronized 一样的效果，即实现原子性、有序性和可见性。相较于 synchronized，Lock 锁可手动获取锁和释放锁、可中断的获取锁、超时获取锁。Lock 是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-lock" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-lock/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://yoursite.com/2019/09/25/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/25/MarkDown语法/</id>
    <published>2019-09-25T10:28:24.000Z</published>
    <updated>2019-10-10T02:12:41.668Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；</p><a id="more"></a><p>Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持 Markdown 编辑模式。</p><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加 #来表示<br>一个 #是一级标题，二个 #是二级标题，以此类推。支持六级标题。<br>注：标准语法一般在 #后跟个空格再写文字,vscode就是要在#之后空一格。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li>加粗<br>要加粗的文字左右分别用两个 * 号包起来</li><li>斜体<br>要倾斜的文字左右分别用一个 * 号包起来</li><li>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来</li><li>删除线<br>要加删除线的文字左右分别用两个～～号包起来<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt; 三个 &gt;&gt;&gt;</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/550)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt></p><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><ul><li>无序列表<br>语法：<br>无序列表用 - + * 任何一种都可以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：- + * 跟内容之间都要有一个空格</p><ul><li>有序列表<br>语法：<br>数字加点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：序号跟内容之间要有空格</p><ul><li>列表嵌套</li></ul><p>上一级和下一级之间敲三个空格即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 一级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br></pre></td></tr></table></figure><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p><code>代码内容</code></p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><p>示例：<br>单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create database hero;`</span><br></pre></td></tr></table></figure><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>(<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br><span class="line"></span><br><span class="line"># 十、流程图</span><br><span class="line"></span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">```  </span><br><span class="line">我这使用的vscode出不来流程图，我还花钱买了一个Markdown软件，结果发现也不支持，不知道是不是我太菜了，估计就是我太菜了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 十一、折叠语法</span><br></pre></td></tr></table></figure></p><details>  <summary>折叠文本</summary>  这个语法是折叠文本的；</details><details>  <summary>折叠代码块</summary>  <pre><code>      System.out.println("折叠代码块");  </code></pre></details><details>  <summary>折叠代码块</summary>  <pre><blockcode>      System.out.println("折叠代码块");  </blockcode></pre></details>```折叠效果：<details>  <summary>折叠文本</summary>  这个语法是折叠文本的；</details><details>  <summary>折叠代码块</summary>  <pre><code>      System.out.println("折叠代码块");  </code></pre></details><details>  <summary>折叠代码块</summary>  <pre><blockcode>      System.out.println("折叠代码块");  </blockcode></pre></details><p>流程图的技巧可以参考这个<a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">流程图</a></p><p>[参考链接] <a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006247465</a><br>[参考链接] <a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a><br>[参考链接] <a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">https://guides.github.com/features/mastering-markdown/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>git使用整理</title>
    <link href="http://yoursite.com/2019/09/24/git%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/24/git使用整理/</id>
    <published>2019-09-24T10:28:24.000Z</published>
    <updated>2019-09-29T11:38:48.747Z</updated>
    
    <content type="html"><![CDATA[<p>本文不做过多概念解释，详细概念请参照官网。本文只是针对平时使用的命令做一个记录；</p><a id="more"></a><ul><li>配置用户信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yuezp&quot;</span><br><span class="line">$ git config --global user.email &quot;yuezp@bonc.com.cn&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注:如果使⽤–global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项⽬使⽤不同的用户名称与邮件地址时，可以在那个项目目录下运行没有–global选项的命令来配置。</p></blockquote><h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><ul><li>查看配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git config —list</span><br><span class="line"></span><br><span class="line">core.excludesfile=~/.gitignore</span><br><span class="line">core.legacyheaders=false</span><br><span class="line">core.quotepath=false</span><br><span class="line">core.pager=less</span><br><span class="line">mergetool.keepbackup=true</span><br><span class="line">push.default=simple</span><br><span class="line">color.ui=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">repack.usedeltabaseoffset=true</span><br><span class="line">alias.s=status</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h3><p><strong><em>如果你本地已经生成过秘钥</em></strong></p><ul><li>查看本地库终端秘钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa</span><br><span class="line">AAAAB3NzaC1yc2EAAAADAQABAAABAQC4LHzWicHvC3rj7xHIolwADsBXxQFx19nOmltOP+vV1mI</span><br><span class="line">gLrbOdw3nu32d6SgjLKEptBAmuuBMM11tOixd2WD680leugdfhIk8j4EoKB1iuQOytEhGCIqxsQ</span><br><span class="line">kGc/PSCSlNnpvj1Pdhm5WjEUctv8KU3mqi9DwxeVe9h/8bMPoisuAAAGTRyLH6HwL/PwV+y2wRd</span><br><span class="line">lbGIgYtD9/PNhmZWanihcYWIWLrBfyTTHtFHhOASHCoOtn8sf6d4YX9Mr//2T+/QhAfti8fuPec</span><br><span class="line">AfffdTAGwR7FfjyPw2WfReFaFwI27M9G7j6ZzB8sCq8psRfUXDi3MeGmDIM6cj0TUTObmCVf</span><br><span class="line">yuezp@bonc.com.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><blockquote><p>创建 dev 分支，然后切换到 dev 分支：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><blockquote><p>git checkout 命令加上 -b 参数表示创建并切换，相当于以下两条命令：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><blockquote><p>使用git branch命令查看当前分支,git branch -a查看全部分支,git branch -r查看远程分支：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>合并分支操作<blockquote><p>在master分支创建文件readme.md,并在文件内写入内容；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.md</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>然后使用前面讲解的创建分支并切换分支命令,然后添加内容到当前分支，之后添加文件到暂存区，之后提交到本地库；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b test</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支test</span><br><span class="line"></span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;提交当前分支内容&quot;</span><br></pre></td></tr></table></figure><blockquote><p>然后切回到master分支，进行合并操作;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge test</span><br></pre></td></tr></table></figure><blockquote><p>合并之后就可以删除test分支了；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d test</span><br></pre></td></tr></table></figure><p><strong><em>上面的合并操作是没有冲突的，下面讲解有合并冲突的情况</em></strong></p><blockquote><p>在master分支创建文件readme.md,并在文件内写入内容；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.md</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br></pre></td></tr></table></figure><blockquote><p>然后使用前面讲解的创建分支并切换分支命令,然后添加内容到当前分支，之后添加文件到暂存区，之后提交到本地库；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支dev</span><br><span class="line"></span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;提交当前分支内容&quot;</span><br></pre></td></tr></table></figure><blockquote><p>然后切回到master分支，在master分支中操作文件readme.md文件，之后进行合并操作;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim readme.md</span><br><span class="line">cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支master</span><br><span class="line"></span><br><span class="line">$ git merge dev 执行完这条命令之后会发生冲突</span><br><span class="line"></span><br><span class="line">Auto-merging readme.md</span><br><span class="line">CONFLICT (content): Merge conflict in readme.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>报错之后，查看readme.md文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">合并分支操作</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">操作当前分支master</span><br><span class="line">=======</span><br><span class="line">操作当前分支test</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><blockquote><p>Git 用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，我们修改如下后保存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">合并分支操作</span><br><span class="line">操作当前分支master</span><br><span class="line">操作当前分支test</span><br></pre></td></tr></table></figure><blockquote><p>使用git命令添加到暂存区，之后添加到本地库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;合并分支操作&quot;</span><br></pre></td></tr></table></figure><blockquote><p>删除分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><blockquote><p>推送本地分支命令如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li>抓取分支</li></ul><p>从远程库 clone 项目时，默认情况下，只能看到本地的 master 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>如果要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，用这个命令创建本地 dev 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><blockquote><p>现在就可以在dev分支进行操作了；</p></blockquote><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在当前分支执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本一</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本一&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br></pre></td></tr></table></figure><p>执行命令git log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本四</span><br><span class="line"></span><br><span class="line">commit e705f67e98755ebaaaa70441c16c9f73ae906a09</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本三</span><br><span class="line"></span><br><span class="line">commit d35039370984410c90b9794809e349474974940d</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本二</span><br><span class="line"></span><br><span class="line">commit 21fd94a72dd54cea4e3c42a1988e0a5e2b42eb20</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本一</span><br></pre></td></tr></table></figure><p>可以看到当前版本是版本四，即commit id是e705f67e98755ebaaaa70441c16c9f73ae906a09的这条记录<br>准备回退到版本三，即commit id是d35039370984410c90b9794809e349474974940d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard d35039370984410c90b9794809e349474974940d</span><br></pre></td></tr></table></figure><p>再次执行git log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本三</span><br><span class="line"></span><br><span class="line">commit d35039370984410c90b9794809e349474974940d</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本二</span><br><span class="line"></span><br><span class="line">commit 21fd94a72dd54cea4e3c42a1988e0a5e2b42eb20</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本一</span><br><span class="line"></span><br><span class="line">commit 9e77a55a2cb65c9fc59556367f2ac39110a30a91 (origin/test, test)</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br></pre></td></tr></table></figure><p>如果想再返回版本四，首先执行git reflog获取到版本四的commit id然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本四id</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在当前分支创建readme.md文件，然后git add再git commit -m “信息”<br>现在想删除文件readme.md,一种方法是右键删除，还有一种是使用rm删除；<br>这个时候，Git 知道你删除了文件，因此，工作区和版本库就不一致了，git status 命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令 git rm 删掉，并且 git commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm readme.md</span><br><span class="line">rm &apos;readme.md&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove readme.md&quot;</span><br><span class="line">[master d46f35e] remove readme.md</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 readme.md</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br></pre></td></tr></table></figure><p>git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以 “一键还原”。</p><ul><li>撤销修改<br>在该工作区修改了readme.md文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vim readme.md</span><br><span class="line">添加内容：</span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh  新加内容</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>你可以发现，Git 会告诉你，git checkout – file 可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br></pre></td></tr></table></figure><p>命令 git checkout – readme.md意思就是，把 readme.md 文件在工作区的修改全部撤销，这里有两种情况：<br>第一种是 readme.md自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.md </span><br><span class="line">head----1</span><br><span class="line">head----2</span><br><span class="line">head----3</span><br></pre></td></tr></table></figure><p>第二种是 readme.md 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">添加内容：</span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh  </span><br><span class="line">jjjjjjjjjjjjjjjjj 新加内容</span><br><span class="line"></span><br><span class="line">$ git checkout -- readme.md</span><br><span class="line"></span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh</span><br></pre></td></tr></table></figure><p>总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。</p><p>第二种方法使用用命令 git reset HEAD <file> 也可以把暂存区的修改撤销掉（unstage），重新放回工作区：</file></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.md</span><br></pre></td></tr></table></figure><p>git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。</p><p>再用 git status 查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.md</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong><em>如果你本地没有生成过秘钥</em></strong></p><ul><li>生成秘钥</li></ul><p>如果本地库终端不存在 ~/.ssh 目录或不存在 ~/.ssh/id_rsa.pub 文件，则⽣生成密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “xxx@bonc.com.cn&quot;</span><br></pre></td></tr></table></figure><p>复制本地库密钥(即~/.ssh/id_rsa.pub 文件)到远程库个人配置中（就是你的gitlab或者GitHub中）</p><p><strong><em>方法一</em></strong></p><h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p>有两种创建 Git 项目仓库的方法:在现有目录中初始化 Repository，或克隆一个既有的 Git仓库。</p><ul><li>在现有目录中初始化Repository</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为 .git 的⼦目录，这个⼦目录含有你初始化的 Git 仓库中所有的必须文件，这<br>些文件是 Git 仓库的骨干。</p><ul><li>从服务器克隆一个现有的Git仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone [Remote URL] [Repository Name]</span><br></pre></td></tr></table></figure><p>如果不需要自定义本地仓库名称，可以不指定 Repository Name，本地仓库名称将与远程库相同;</p><h3 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h3><p>git add<br>将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。</p><h2 id="整个Github提交流程如下："><a href="#整个Github提交流程如下：" class="headerlink" title="整个Github提交流程如下："></a>整个Github提交流程如下：</h2><ul><li><p>首先在本地创建版本库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir github_repository</span><br><span class="line">$ cd github_repository</span><br></pre></td></tr></table></figure></li><li><p>初始化版本库</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><ul><li><p>添加文件或者文件夹到版本库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all </span><br><span class="line">$ git status</span><br><span class="line">$ git commit -m &quot;提交信息&quot;</span><br></pre></td></tr></table></figure></li><li><p>在GitHub账户上创建远程仓库</p></li></ul><p>这里请按照GitHub上的操作流程走就行</p><ul><li>将本地仓库和远程仓库进行关联</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:LXF-YZP/study.git</span><br><span class="line">注：我远程仓库的名字和本地仓库的名字都是study</span><br></pre></td></tr></table></figure><ul><li>将本体仓库提交到远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line">如果你在GitHub上创建远程仓库的时候还创建了README.md,那么在执行上面的push命令之前请执行</span><br><span class="line"></span><br><span class="line">$ git pull --rebase origin master</span><br><span class="line"></span><br><span class="line">不然会报错：</span><br><span class="line">To github.com:LXF-YZP/study.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:LXF-YZP/study.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>方法二</em></strong><br>首先在GitHub上创建远程仓库，然后使用命令进行克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:LXF-YZP/study.git</span><br></pre></td></tr></table></figure><blockquote><p>参考之前项目经理写的Git使用说明<br>[参考文章]<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文不做过多概念解释，详细概念请参照官网。本文只是针对平时使用的命令做一个记录；&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC详解</title>
    <link href="http://yoursite.com/2019/09/23/Spring%20IOC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Spring IOC详解/</id>
    <published>2019-09-23T10:28:24.000Z</published>
    <updated>2019-09-27T11:28:39.550Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、ioc" scheme="http://yoursite.com/tags/spring%E3%80%81ioc/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP之动态代理</title>
    <link href="http://yoursite.com/2019/09/22/Spring%20AOP%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/22/Spring AOP之动态代理/</id>
    <published>2019-09-22T10:28:24.000Z</published>
    <updated>2019-09-27T11:27:54.319Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、动态代理" scheme="http://yoursite.com/tags/spring%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP详解</title>
    <link href="http://yoursite.com/2019/09/21/Spring%20AOP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/21/Spring AOP详解/</id>
    <published>2019-09-21T10:28:24.000Z</published>
    <updated>2019-09-27T11:25:36.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、aop" scheme="http://yoursite.com/tags/spring%E3%80%81aop/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之各种锁概念</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/20/Java多线程之各种锁概念/</id>
    <published>2019-09-20T10:28:24.000Z</published>
    <updated>2019-10-09T08:57:33.989Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。</p><a id="more"></a><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li>公平锁：指的是线程按照申请锁的顺序来获取锁（这里的公平和鹅城张麻子说的公平，公平，还是公平不一样，没看过的建议看一下《让子弹飞》，具体讲的什么我就不说了，再说就扯远了）；</li><li>非公平锁：指的是多个线程获取锁的顺序并不是按照申请锁的顺序来的，有可能会出现后申请锁的线程比先申请锁的线程先获得锁；<br>非公平锁一上来就尝试占用锁，如果尝试占用失败，就采用公平锁的方式到末尾排队。在高并发的情况下，有可能造成优先级反转或饥饿现象。非公平锁的优点在于吞吐量比公平锁大。</li></ul><ul><li>ReentrantLock：可以指定构造方法的 boolean 类型来指定是公平锁还是非公平锁，默认是非公平锁</li><li>Synchronized：是一种非公平锁</li></ul><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><ul><li>独占锁：是指该锁一次只能被一个线程所持有。ReentrantLock 和 synchronized 都是独占锁；</li><li>共享锁：是指该锁可以被多个线程所持有，ReentrantReadWriteLock：其读锁是共享锁，其写锁是独占锁，读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的；</li></ul><h2 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h2><ul><li>上面说到的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在 Java 中的具体实现就是 ReentrantLock；读写锁在 Java 中的具体实现就是 ReadWriteLock。</li><li>互斥锁：某个线程要更改共享数据时，先将其锁定，此时资源的状态为 “锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成 “非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br>互斥锁是阻塞锁，当某线程无法获取互斥量时，该线程会被 CPU 直接挂起，该线程不再消耗 CPU 时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。</li><li>读写锁：读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。读写互斥，读读共享。</li></ul><p>1.多读者可以同时读<br>2.写者写时不允许读，不允许其他写者写<br>3.读者读时不允许写者写</p><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul><li>可重入锁：指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。即获取锁的粒度是线程而不是调用。<br>在同一个线程在外层方法获取锁的时候，在进入内层方法的时候会自动获取锁，也就是说，线程可以进入任何一个它自己已经拥有的锁所同步着的代码块<br>可重入锁最大的作用是避免死锁。ReentrantLock 和 synchronized 都是可重入锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        People people = new People();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                people.get();</span><br><span class="line">            &#125;,&quot;t&quot; + i).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class People&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void get()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; get&quot;);</span><br><span class="line">            set();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; set&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><strong><em>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</em></strong></li></ul><ul><li><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如 Java 里面的同步原语 synchronized 关键字的实现就是悲观锁。</p></li><li><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS (Compare and Swap 比较并交换) 实现的。</p></li></ul><h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><blockquote><p>这三种锁是指锁的状态，并且是针对 synchronized。在 Java 5 通过引入锁升级的机制来实现高效 synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p></blockquote><blockquote><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p></blockquote><blockquote><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p></blockquote><blockquote><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p></blockquote><ul><li><p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p></li><li><p>轻量级锁：线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁 (两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</p></li><li><p>重量级锁：在 JVM 中又叫对象监视器（Monitor），它很像 C 中的 Mutex，除了具备 Mutex (0|1) 互斥的功能，它还负责实现了 Semaphore (信号量) 的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。</p></li></ul><p>整个 synchronized 锁流程如下：<br>①检测 Mark Word 里面是不是当前线程的 ID，如果是，表示当前线程处于偏向锁<br>②如果不是，则使用 CAS 将当前线程的 ID 替换 Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位 1<br>③如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。<br>④当前线程使用 CAS 将对象头的 Mark Word 替换为锁记录指针，如果成功，当前线程获得锁<br>⑤如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>⑥如果自旋成功则依然处于轻量级状态。<br>⑦如果自旋失败，则升级为重量级锁。</p><table><thead><tr><th>锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td><td align="center">如果始终得不到锁竞争的线程使用自旋会消耗 CPU</td><td align="center">追求响应时间，锁占用时间很短</td></tr><tr><td>重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗 CPU</td><td align="center">线程阻塞，响应时间缓慢</td><td align="center">追求吞吐量，锁占用时间较长</td></tr></tbody></table><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待（不会睡眠），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>自旋锁是非阻塞锁，一直占用 CPU，他在未获得锁的情况下，一直尝试得到锁也就是自旋，所以占用着 CPU，如果不能在很短的时间内获得锁，会使 CPU 效率降低。<br>一个简单的自旋锁代码实现：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public class SpinLock &#123;</span><br><span class="line">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   public void lock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       // 如果锁未被占用，则设置当前线程为锁的拥有者</span><br><span class="line">       while (!owner.compareAndSet(null, currentThread)) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       // 只有锁的拥有者才能释放锁</span><br><span class="line">       owner.compareAndSet(currentThread, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap（JDK7 与 JDK8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 HashMap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计 size 的时候，可就是获取 HashMap 全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><p>[参考链接] <a href="https://blog.csdn.net/li3781695/article/details/99715169" target="_blank" rel="noopener">https://blog.csdn.net/li3781695/article/details/99715169</a><br>[参考链接] <a href="https://blog.csdn.net/tyyj90/article/details/78236053" target="_blank" rel="noopener">https://blog.csdn.net/tyyj90/article/details/78236053</a><br>[参考链接] <a href="https://blog.csdn.net/qq_41282026/article/details/98304960" target="_blank" rel="noopener">https://blog.csdn.net/qq_41282026/article/details/98304960</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-锁概念" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/09/20/volatile/"/>
    <id>http://yoursite.com/2019/09/20/volatile/</id>
    <published>2019-09-20T09:28:24.000Z</published>
    <updated>2019-09-27T06:23:58.850Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/2019/09/20/volatile/aaa.png" alt><br>1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。<br>2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</p><a id="more"></a><h1 id="volatile通过禁止指令重排保证有序性"><a href="#volatile通过禁止指令重排保证有序性" class="headerlink" title="volatile通过禁止指令重排保证有序性"></a>volatile通过禁止指令重排保证有序性</h1><p>在多线程模式下，指令重排的时候会出现问题，所以在多线程的情况下为了保证线程安全，需要禁止掉指令重排。<br>volatile在禁止指令重排方面的应用：</p><ol><li>通过一个变量来进行初始化判断。如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean isInit = false;</span><br><span class="line">private Manager mManger;</span><br><span class="line">public Manager getManager()&#123;</span><br><span class="line">  if(!isInit)&#123;</span><br><span class="line">    mManger = initManager();</span><br><span class="line">    isInit = true;</span><br><span class="line">  &#125;</span><br><span class="line">  return mManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在单线程下没有任何问题，但是在多线程情况下如果进行了指令重排，那么代码是有问题的。比如指令重排之后，把 isInit = true 放在了 mManager = initManager() 之上，很可能在多线程的情况下出现 mManager 为空的情况，从而出现空指针异常。线程 1 执行 getManager 方法，由于指令重排，isInit = true 先执行，然后去真正初始化 mManager, 最后返回 mManager 实例，不会有任何问题。但是当线程 1 执行完 isInit = true 之后，线程 2 开始执行 getManager 方法，发现 isInit 为 true，就直接返回了 mManager，而此时 mManager 还没有初始化，所以线程 2 中会出现空指针异常。</p><ol start="2"><li>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance () 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance () 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance () 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><pre><code>1⃣️分配一块内存 M；2⃣️在内存 M 上初始化 Singleton 对象；3⃣️然后 M 的地址赋值给 instance 变量。</code></pre><p>换成代码如下：</p><pre><code>1⃣️memory = allocate () // 分配内存；2⃣️ctorInstanc (memory) // 初始化对象；3⃣️instance = memory // 设置 instance 指向刚分配的地址</code></pre><p>但是实际上优化后的执行路径却是这样的：</p><pre><code>1⃣️分配一块内存 M；2⃣️将 M 的地址赋值给 instance 变量；3⃣️最后在内存 M 上初始化 Singleton 对象。</code></pre><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance () 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance () 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>正确写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 关键字禁止指令重排序有两层意思：</p><p>1）当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>2）在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p><p>举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"></span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;        //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure><p>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。</p><p>并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果对语句 3、语句 4、语句 5 是可见的。</p><h1 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h1><ol><li>从上面知道 volatile 关键字保证了操作的可见性，但是 volatile 不能保证对变量的操作是原子性的，可以参考Java并发编程实战第三章。<br>下面看一个带有自增操作的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面例子输出的结果是小于10000的数，可能有的朋友就会有疑问，上面是对变量 inc 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 inc 自增完之后，在其他线程中都能看到修改后的值啊，所以有 10 个线程分别进行了 1000 次操作，那么最终 inc 的值应该是 1000*10=10000。</p><p>这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。</p><p>由于自增操作是不具备原子性的，它包括读取变量的原始值、进行加 1 操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量 inc 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了变量 inc 的原始值，然后线程 1 被阻塞了；<br>然后线程 2 对变量进行自增操作，线程 2 也去读取变量 inc 的原始值，由于线程 1 只是对变量 inc 进行读取操作，而没有对变量进行修改操作，所以不会导致线程 2 的工作内存中缓存变量 inc 的缓存行无效，线程 2 会直接去主存读取 inc 的值，发现 inc 的值是10，然后进行加 1 操作，并把 11 写入工作内存，最后写入主存。</p><p>然后线程 1 接着进行加 1 操作，由于已经读取了 inc 的值，注意此时在线程 1 的工作内存中 inc 的值仍然为 10，所以线程 1 对 inc 进行加 1 操作后 inc 的值为 11，然后将 11 写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc 只增加了 1。</p><p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改 volatile 变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的 happens-before 规则中的 volatile 变量规则，但是要注意，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。</p><p>根源就在这里，自增操作不是原子性操作，而且 volatile 也无法保证对变量的任何操作都是原子性的。</p><h2 id="对于不保证原子性的解释"><a href="#对于不保证原子性的解释" class="headerlink" title="对于不保证原子性的解释"></a>对于不保证原子性的解释</h2><p>对于上面解释原子性的操作，大家估计会有这种疑问，即当线程 1 将变量 a 读入到了自己的工作内存，还没有修改，被阻塞；线程 2 将主存中的 a 读入工作内存修改，写入主存；线程 1 苏醒是继续运行还是会检测工作内存的变量 a 是否需要刷新呢？</p><p>对于上面问题的解释，网上大致是有两种不同的解释：<br>观点1. 当线程一读取10之后被阻塞了。然后线程二得到了执行机会，并且在执行inc自增操作的时候没有被阻塞，那么线程二执行完自增操作之后更新工作内存，然后刷新到主存中，这时线程一又有了执行机会，那么线程一继续使用之前读取的值10进行自增操作（而不是从主存中读取值11进行自增操作）。<br>观点一就是说线程二修改了主存之后，线程一再次获得执行权后并没有马上去读取主存的值进行自增操作，而是使用原来的10进行自增操作。也就是认为线程二更新主存之后，没有马上去更新线程一的工作内存，导致线程一还是之前的值。</p><p>观点2. 1⃣️线程一读取 inc 的值后，还没有操作就被阻塞了。<br>2⃣️线程二被唤醒，从主存读取 inc 的值，加 1，然后被阻塞。（此时还没来得及把新的值重新赋值给 inc，当然也还没同步到主存）。<br>3⃣️线程一被唤醒，inc 值加 1，然后同步到主存（线程一结束）。<br>4⃣️线程二被唤醒，把最新的值赋值给 inc，同步到主存（此时线程二，inc 的值在第 2 步时已经被处理过了，仅仅只是把新的值赋值给 inc 而已。这个时候是不会再去读取 inc 的缓存行的，虽然 inc 的缓存行此时已经无效了）<br>观点二可以理解为，自增操作的三步：1.复制到工作内存 2.自增 3.写入主存，其中只有 1,2 步在执行之前会检查缓存行，第 3 步是不检查的。把计算后的值赋值给变量，是不需要去检查缓存行的。</p><p>我更倾向于观点二也就是说线程二更新主存之后，会马上使得线程一得工作内存失效，在线程一再去读取Inc的值时会去读取主存中的值。</p><p>把上面的代码改成以下任何一种都可以达到效果：<br>1⃣️采用 synchronized：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2⃣️采用 Lock：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3⃣️采用 AtomicInteger：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc = new AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。volatile 会使得变量 “立即” 刷新到内存中的！而不会在写入内存之前被阻塞！</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol><p>[参考文章]<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/2019/09/20/volatile/aaa.png&quot; alt&gt;&lt;br&gt;1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。&lt;br&gt;2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-volatile关键字" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>java多线程的生命周期</title>
    <link href="http://yoursite.com/2019/09/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/09/19/java多线程的生命周期/</id>
    <published>2019-09-19T10:28:24.000Z</published>
    <updated>2019-09-30T08:06:40.840Z</updated>
    
    <content type="html"><![CDATA[<p>Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。</p><p>在操作系统层面，线程也有 “生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了。</p><p>我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下 Java 中线程的生命周期。</p><a id="more"></a><h3 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h3><p>通用的线程生命周期基本上可以用下图这个 “五态模型” 来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。</p><p><img src="/2019/09/19/java多线程的生命周期/9bbc6fa7fb4d631484aa953626cf6ae5.png" alt></p><p>这 “五态模型” 的详细情况如下所示。</p><p>①<strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。<br>②<strong>可运行状态</strong>，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。<br>③当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>。<br>④运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。<br>⑤线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。<br>这五种状态在不同编程语言里会有简化合并。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。</p><p>除了简化合并，这五种状态也有可能被细化，比如，Java 语言里就细化了休眠状态。</p><h3 id="Java-中线程的生命周期"><a href="#Java-中线程的生命周期" class="headerlink" title="Java 中线程的生命周期"></a>Java 中线程的生命周期</h3><p>Java 语言中线程共有六种状态，分别是：</p><ol><li>NEW（初始化状态）</li><li>RUNNABLE（可运行 / 运行状态）</li><li>BLOCKED（阻塞状态）</li><li>WAITING（无时限等待）</li><li>TIMED_WAITING（有时限等待）</li><li>TERMINATED（终止状态）<br>在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，<strong>那么这个线程就永远没有 CPU 的使用权</strong>。</li></ol><p>所以 Java 线程的生命周期可以简化为下图：<br><img src="/2019/09/19/java多线程的生命周期/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png" alt></p><p>其中，BLOCKED、WAITING、TIMED_WAITING 可以理解为线程导致休眠状态的三种原因。那具体是哪些情形会导致线程从 RUNNABLE 状态转换到这三种状态呢？而这三种状态又是何时转换回 RUNNABLE 的呢？以及 NEW、TERMINATED 和 RUNNABLE 状态是如何转换的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A thread state.  A thread can be in one of the following states:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #NEW&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has not yet started is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #RUNNABLE&#125;&lt;br&gt;</span><br><span class="line">     *     A thread executing in the Java virtual machine is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #BLOCKED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is blocked waiting for a monitor lock</span><br><span class="line">     *     is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting indefinitely for another thread to</span><br><span class="line">     *     perform a particular action is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TIMED_WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting for another thread to perform an action</span><br><span class="line">     *     for up to a specified waiting time is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TERMINATED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has exited is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A thread can be in only one state at a given point in time.</span><br><span class="line">     * These states are virtual machine states which do not reflect</span><br><span class="line">     * any operating system thread states.</span><br><span class="line">     *</span><br><span class="line">     * @since   1.5</span><br><span class="line">     * @see #getState</span><br><span class="line">     */</span><br><span class="line">    public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the state of this thread.</span><br><span class="line">     * This method is designed for use in monitoring of the system state,</span><br><span class="line">     * not for synchronization control.</span><br><span class="line">     *</span><br><span class="line">     * @return this thread&apos;s state.</span><br><span class="line">     * @since 1.5</span><br><span class="line">     */</span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        // get current thread state</span><br><span class="line">        return sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-RUNNABLE-与-BLOCKED-的状态转换"><a href="#1-RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="1. RUNNABLE 与 BLOCKED 的状态转换"></a>1. RUNNABLE 与 BLOCKED 的状态转换</h3><p>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。</p><p>如果你熟悉操作系统线程的生命周期的话，可能会有个疑问：线程调用阻塞式 API 时，是否会转换到 BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。<strong>JVM 层面并不关心操作系统调度相关的状态</strong>，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。</p><p>而我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</p><h3 id="2-RUNNABLE-与-WAITING-的状态转换"><a href="#2-RUNNABLE-与-WAITING-的状态转换" class="headerlink" title="2. RUNNABLE 与 WAITING 的状态转换"></a>2. RUNNABLE 与 WAITING 的状态转换</h3><p>总体来说，有三种场景会触发这种转换。</p><p>第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait () 方法。其中，wait () 方法我们在上一篇讲解管程的时候已经深入介绍过了，这里就不再赘述。</p><p>第二种场景，调用无参数的 Thread.join () 方法。其中的 join () 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join () 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</p><p>第三种场景，调用 LockSupport.park () 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用 LockSupport.park () 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark (Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</p><h3 id="3-RUNNABLE-与-TIMED-WAITING-的状态转换"><a href="#3-RUNNABLE-与-TIMED-WAITING-的状态转换" class="headerlink" title="3. RUNNABLE 与 TIMED_WAITING 的状态转换"></a>3. RUNNABLE 与 TIMED_WAITING 的状态转换</h3><p>有五种场景会触发这种转换：</p><p>调用带超时参数的 Thread.sleep (long millis) 方法；<br>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait (long timeout) 方法；<br>调用带超时参数的 Thread.join (long millis) 方法；<br>调用带超时参数的 LockSupport.parkNanos (Object blocker, long deadline) 方法；<br>调用带超时参数的 LockSupport.parkUntil (long deadline) 方法。<br>这里你会发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了<strong>超时参数</strong>。</p><h3 id="4-从-NEW-到-RUNNABLE-状态"><a href="#4-从-NEW-到-RUNNABLE-状态" class="headerlink" title="4. 从 NEW 到 RUNNABLE 状态"></a>4. 从 NEW 到 RUNNABLE 状态</h3><p>Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run () 方法。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 自定义线程对象</span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    // 线程需要执行的代码</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建线程对象</span><br><span class="line">MyThread myThread = new MyThread();</span><br></pre></td></tr></table></figure><p>另一种是实现 Runnable 接口，重写 run () 方法，并将该实现类作为创建 Thread 对象的参数。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 实现 Runnable 接口</span><br><span class="line">class Runner implements Runnable &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    // 线程需要执行的代码</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建线程对象</span><br><span class="line">Thread thread = new Thread(new Runner());</span><br></pre></td></tr></table></figure><p>NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start () 方法就可以了，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = new MyThread();</span><br><span class="line">// 从 NEW 状态转换到 RUNNABLE 状态</span><br><span class="line">myThread.start()；</span><br></pre></td></tr></table></figure><h3 id="5-从-RUNNABLE-到-TERMINATED-状态"><a href="#5-从-RUNNABLE-到-TERMINATED-状态" class="headerlink" title="5. 从 RUNNABLE 到 TERMINATED 状态"></a>5. 从 RUNNABLE 到 TERMINATED 状态</h3><p>线程执行完 run () 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run () 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run () 方法的执行，例如 run () 方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java 的 Thread 类里面倒是有个 stop () 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用 interrupt () 方法。</p><p><strong><em>那 stop () 和 interrupt () 方法的主要区别是什么呢？</em></strong></p><p>stop () 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop () 的线程并不会自动调用 ReentrantLock 的 unlock () 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend () 和 resume () 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。</p><p>而 interrupt () 方法就温柔多了，interrupt () 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p><p>当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt () 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait ()、join ()、sleep () 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt () 方法。</p><p>当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt () 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt () 方法，线程 A 的 java.nio.channels.Selector 会立即返回。</p><p>上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt () 方法，那么线程 A 可以通过 isInterrupted () 方法，检测是不是自己被中断了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助，多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。同时，本文介绍的线程生命周期具备很强的通用性，对于学习其他语言的多线程编程也有很大的帮助。</p><p>你可以通过 jstack 命令或者 Java VisualVM 这个可视化工具将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。例如，我曾经写过一个死锁的程序，导出的线程栈明确告诉我发生了死锁，并且将死锁线程的调用栈信息清晰地显示出来了。导出线程栈，分析线程状态是诊断并发问题的一个重要工具。</p><p>[参考链接]<a href="https://time.geekbang.org/column/article/86366" target="_blank" rel="noopener">https://time.geekbang.org/column/article/86366</a><br>[参考链接]<a href="https://www.jianshu.com/p/9d98aac9cf22?utm_campaign=haruki" target="_blank" rel="noopener">https://www.jianshu.com/p/9d98aac9cf22?utm_campaign=haruki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。&lt;/p&gt;
&lt;p&gt;在操作系统层面，线程也有 “生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了。&lt;/p&gt;
&lt;p&gt;我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下 Java 中线程的生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-生命周期" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理之基本概念</title>
    <link href="http://yoursite.com/2019/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/13/计算机组成原理之基本概念/</id>
    <published>2019-09-13T11:10:22.000Z</published>
    <updated>2019-09-27T09:30:52.576Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。<br>不要问看懂看不懂，现在就是看不懂也要看啊，越到后面越需要基础的东西，早点学会基础的东西，早点享受基础知识带来的红利；<br>学计算机基础就是要苟，不知道苟啥意思是吧，我给你详细解释一下；<br><img src="/2019/09/13/计算机组成原理之基本概念/68258.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。&lt;br&gt;不要问看懂看不懂，现在就是看不懂也要看啊，越到
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理-概念" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Thrift简介</title>
    <link href="http://yoursite.com/2019/09/01/Thrift%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/09/01/Thrift简介/</id>
    <published>2019-09-01T10:28:24.000Z</published>
    <updated>2019-09-30T07:12:07.625Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Thrift" scheme="http://yoursite.com/categories/Thrift/"/>
    
    
      <category term="RPC，远程调用" scheme="http://yoursite.com/tags/RPC%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-Trie树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-Trie树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:36:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-Trie树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-二叉树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:33:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-二叉树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-图/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:35:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-图" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-堆/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-堆" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    
  </entry>
  
</feed>
