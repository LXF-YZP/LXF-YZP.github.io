<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-27T11:10:29.895Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程之内存模型和happens-before规则</title>
    <link href="http://yoursite.com/2019/09/29/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/09/29/java多线程之内存模型和happens-before规则/</id>
    <published>2019-09-29T10:28:24.000Z</published>
    <updated>2019-09-27T11:10:29.895Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-内存模型、happens-before规则" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81happens-before%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之CAS</title>
    <link href="http://yoursite.com/2019/09/28/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCAS/"/>
    <id>http://yoursite.com/2019/09/28/java多线程之CAS/</id>
    <published>2019-09-28T10:28:24.000Z</published>
    <updated>2019-09-27T11:12:33.779Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-CAS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之AQS</title>
    <link href="http://yoursite.com/2019/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/09/27/Java多线程之AQS/</id>
    <published>2019-09-27T10:28:24.000Z</published>
    <updated>2019-09-27T11:12:19.375Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-AQS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之lock</title>
    <link href="http://yoursite.com/2019/09/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Block/"/>
    <id>http://yoursite.com/2019/09/26/Java多线程之lock/</id>
    <published>2019-09-26T10:28:24.000Z</published>
    <updated>2019-09-27T11:08:27.774Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-lock" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-lock/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://yoursite.com/2019/09/25/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/25/MarkDown语法/</id>
    <published>2019-09-25T10:28:24.000Z</published>
    <updated>2019-09-27T09:49:58.307Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；</p><a id="more"></a><p>Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持 Markdown 编辑模式。</p><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加 #来表示<br>一个 #是一级标题，二个 #是二级标题，以此类推。支持六级标题。<br>注：标准语法一般在 #后跟个空格再写文字,vscode就是要在#之后空一格。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li>加粗<br>要加粗的文字左右分别用两个 * 号包起来</li><li>斜体<br>要倾斜的文字左右分别用一个 * 号包起来</li><li>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来</li><li>删除线<br>要加删除线的文字左右分别用两个～～号包起来<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt; 三个 &gt;&gt;&gt;</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/550)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt></p><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><ul><li>无序列表<br>语法：<br>无序列表用 - + * 任何一种都可以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：- + * 跟内容之间都要有一个空格</p><ul><li>有序列表<br>语法：<br>数字加点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：序号跟内容之间要有空格</p><ul><li>列表嵌套</li></ul><p>上一级和下一级之间敲三个空格即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 一级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br></pre></td></tr></table></figure><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p><code>代码内容</code></p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><p>示例：<br>单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create database hero;`</span><br></pre></td></tr></table></figure><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>(<code>)    function fun(){         echo &quot;这是一句非常牛逼的代码&quot;;    }    fun();(</code>)</p><h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><p>我这使用的vscode出不来流程图，我还花钱买了一个Markdown软件，结果发现也不支持，不知道是不是我太菜了，估计就是我太菜了。<br>流程图的技巧可以参考这个<a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">流程图</a></p><p>[参考链接] <a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006247465</a><br>[参考链接] <a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>git使用整理</title>
    <link href="http://yoursite.com/2019/09/24/git%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/24/git使用整理/</id>
    <published>2019-09-24T10:28:24.000Z</published>
    <updated>2019-09-27T11:33:18.138Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC详解</title>
    <link href="http://yoursite.com/2019/09/23/Spring%20IOC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Spring IOC详解/</id>
    <published>2019-09-23T10:28:24.000Z</published>
    <updated>2019-09-27T11:28:39.550Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、ioc" scheme="http://yoursite.com/tags/spring%E3%80%81ioc/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP之动态代理</title>
    <link href="http://yoursite.com/2019/09/22/Spring%20AOP%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/22/Spring AOP之动态代理/</id>
    <published>2019-09-22T10:28:24.000Z</published>
    <updated>2019-09-27T11:27:54.319Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、动态代理" scheme="http://yoursite.com/tags/spring%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP详解</title>
    <link href="http://yoursite.com/2019/09/21/Spring%20AOP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/21/Spring AOP详解/</id>
    <published>2019-09-21T10:28:24.000Z</published>
    <updated>2019-09-27T11:25:36.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、aop" scheme="http://yoursite.com/tags/spring%E3%80%81aop/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之各种锁概念</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/20/Java多线程之各种锁概念/</id>
    <published>2019-09-20T10:28:24.000Z</published>
    <updated>2019-09-27T10:59:40.284Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。</p><a id="more"></a><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li>公平锁：指的是线程按照申请锁的顺序来获取锁（这里的公平和鹅城张麻子说的公平，公平，还是公平不一样，没看过的建议看一下《让子弹飞》，具体讲的什么我就不说了，再说就扯远了）；</li><li>非公平锁：指的是多个线程获取锁的顺序并不是按照申请锁的顺序来的，有可能会出现后申请锁的线程比先申请锁的线程先获得锁；<br>非公平锁一上来就尝试占用锁，如果尝试占用失败，就采用公平锁的方式到末尾排队。在高并发的情况下，有可能造成优先级反转或饥饿现象。非公平锁的优点在于吞吐量比公平锁大。</li></ul><ul><li>ReentrantLock：可以指定构造方法的 boolean 类型来指定是公平锁还是非公平锁，默认是非公平锁</li><li>Synchronized：是一种非公平锁</li></ul><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><ul><li>独占锁：是指该锁一次只能被一个线程所持有。ReentrantLock 和 synchronized 都是独占锁；</li><li>共享锁：是指该锁可以被多个线程所持有，ReentrantReadWriteLock：其读锁是共享锁，其写锁是独占锁，读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的；</li></ul><h2 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h2><ul><li>上面说到的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在 Java 中的具体实现就是 ReentrantLock；读写锁在 Java 中的具体实现就是 ReadWriteLock。</li><li>互斥锁：某个线程要更改共享数据时，先将其锁定，此时资源的状态为 “锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成 “非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br>互斥锁是阻塞锁，当某线程无法获取互斥量时，该线程会被 CPU 直接挂起，该线程不再消耗 CPU 时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。</li><li>读写锁：读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。读写互斥，读读共享。</li></ul><p>1.多读者可以同时读<br>2.写者写时不允许读，不允许其他写者写<br>3.读者读时不允许写者写</p><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul><li>可重入锁：指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。即获取锁的粒度是线程而不是调用。<br>在同一个线程在外层方法获取锁的时候，在进入内层方法的时候会自动获取锁，也就是说，线程可以进入任何一个它自己已经拥有的锁所同步着的代码块<br>可重入锁最大的作用是避免死锁。ReentrantLock 和 synchronized 都是可重入锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        People people = new People();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                people.get();</span><br><span class="line">            &#125;,&quot;t&quot; + i).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class People&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void get()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; get&quot;);</span><br><span class="line">            set();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; set&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><strong><em>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</em></strong></li></ul><ul><li><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如 Java 里面的同步原语 synchronized 关键字的实现就是悲观锁。</p></li><li><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS (Compare and Swap 比较并交换) 实现的。</p></li></ul><h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><blockquote><p>这三种锁是指锁的状态，并且是针对 synchronized。在 Java 5 通过引入锁升级的机制来实现高效 synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p></blockquote><blockquote><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p></blockquote><blockquote><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p></blockquote><blockquote><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p></blockquote><ul><li><p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p></li><li><p>轻量级锁：线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁 (两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</p></li><li><p>重量级锁：在 JVM 中又叫对象监视器（Monitor），它很像 C 中的 Mutex，除了具备 Mutex (0|1) 互斥的功能，它还负责实现了 Semaphore (信号量) 的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。</p></li></ul><p>整个 synchronized 锁流程如下：<br>①检测 Mark Word 里面是不是当前线程的 ID，如果是，表示当前线程处于偏向锁<br>②如果不是，则使用 CAS 将当前线程的 ID 替换 Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位 1<br>③如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。<br>④当前线程使用 CAS 将对象头的 Mark Word 替换为锁记录指针，如果成功，当前线程获得锁<br>⑤如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>⑥如果自旋成功则依然处于轻量级状态。<br>⑦如果自旋失败，则升级为重量级锁。</p><table><thead><tr><th>锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td><td align="center">如果始终得不到锁竞争的线程使用自旋会消耗 CPU</td><td align="center">追求响应时间，锁占用时间很短</td></tr><tr><td>重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗 CPU</td><td align="center">线程阻塞，响应时间缓慢</td><td align="center">追求吞吐量，锁占用时间较长</td></tr></tbody></table><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待（不会睡眠），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>自旋锁是非阻塞锁，一直占用 CPU，他在未获得锁的情况下，一直尝试得到锁也就是自旋，所以占用着 CPU，如果不能在很短的时间内获得锁，会使 CPU 效率降低。</p></blockquote><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap（JDK7 与 JDK8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 HashMap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计 size 的时候，可就是获取 HashMap 全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><p>[参考链接] <a href="https://blog.csdn.net/li3781695/article/details/99715169" target="_blank" rel="noopener">https://blog.csdn.net/li3781695/article/details/99715169</a><br>[参考链接] <a href="https://blog.csdn.net/tyyj90/article/details/78236053" target="_blank" rel="noopener">https://blog.csdn.net/tyyj90/article/details/78236053</a><br>[参考链接] <a href="https://blog.csdn.net/qq_41282026/article/details/98304960" target="_blank" rel="noopener">https://blog.csdn.net/qq_41282026/article/details/98304960</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-锁概念" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/09/20/volatile/"/>
    <id>http://yoursite.com/2019/09/20/volatile/</id>
    <published>2019-09-20T09:28:24.000Z</published>
    <updated>2019-09-27T06:23:58.850Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/2019/09/20/volatile/aaa.png" alt><br>1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。<br>2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</p><a id="more"></a><h1 id="volatile通过禁止指令重排保证有序性"><a href="#volatile通过禁止指令重排保证有序性" class="headerlink" title="volatile通过禁止指令重排保证有序性"></a>volatile通过禁止指令重排保证有序性</h1><p>在多线程模式下，指令重排的时候会出现问题，所以在多线程的情况下为了保证线程安全，需要禁止掉指令重排。<br>volatile在禁止指令重排方面的应用：</p><ol><li>通过一个变量来进行初始化判断。如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean isInit = false;</span><br><span class="line">private Manager mManger;</span><br><span class="line">public Manager getManager()&#123;</span><br><span class="line">  if(!isInit)&#123;</span><br><span class="line">    mManger = initManager();</span><br><span class="line">    isInit = true;</span><br><span class="line">  &#125;</span><br><span class="line">  return mManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在单线程下没有任何问题，但是在多线程情况下如果进行了指令重排，那么代码是有问题的。比如指令重排之后，把 isInit = true 放在了 mManager = initManager() 之上，很可能在多线程的情况下出现 mManager 为空的情况，从而出现空指针异常。线程 1 执行 getManager 方法，由于指令重排，isInit = true 先执行，然后去真正初始化 mManager, 最后返回 mManager 实例，不会有任何问题。但是当线程 1 执行完 isInit = true 之后，线程 2 开始执行 getManager 方法，发现 isInit 为 true，就直接返回了 mManager，而此时 mManager 还没有初始化，所以线程 2 中会出现空指针异常。</p><ol start="2"><li>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance () 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance () 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance () 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><pre><code>1⃣️分配一块内存 M；2⃣️在内存 M 上初始化 Singleton 对象；3⃣️然后 M 的地址赋值给 instance 变量。</code></pre><p>换成代码如下：</p><pre><code>1⃣️memory = allocate () // 分配内存；2⃣️ctorInstanc (memory) // 初始化对象；3⃣️instance = memory // 设置 instance 指向刚分配的地址</code></pre><p>但是实际上优化后的执行路径却是这样的：</p><pre><code>1⃣️分配一块内存 M；2⃣️将 M 的地址赋值给 instance 变量；3⃣️最后在内存 M 上初始化 Singleton 对象。</code></pre><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance () 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance () 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>正确写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 关键字禁止指令重排序有两层意思：</p><p>1）当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>2）在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p><p>举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"></span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;        //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure><p>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。</p><p>并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果对语句 3、语句 4、语句 5 是可见的。</p><h1 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h1><ol><li>从上面知道 volatile 关键字保证了操作的可见性，但是 volatile 不能保证对变量的操作是原子性的，可以参考Java并发编程实战第三章。<br>下面看一个带有自增操作的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面例子输出的结果是小于10000的数，可能有的朋友就会有疑问，上面是对变量 inc 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 inc 自增完之后，在其他线程中都能看到修改后的值啊，所以有 10 个线程分别进行了 1000 次操作，那么最终 inc 的值应该是 1000*10=10000。</p><p>这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。</p><p>由于自增操作是不具备原子性的，它包括读取变量的原始值、进行加 1 操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量 inc 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了变量 inc 的原始值，然后线程 1 被阻塞了；<br>然后线程 2 对变量进行自增操作，线程 2 也去读取变量 inc 的原始值，由于线程 1 只是对变量 inc 进行读取操作，而没有对变量进行修改操作，所以不会导致线程 2 的工作内存中缓存变量 inc 的缓存行无效，线程 2 会直接去主存读取 inc 的值，发现 inc 的值是10，然后进行加 1 操作，并把 11 写入工作内存，最后写入主存。</p><p>然后线程 1 接着进行加 1 操作，由于已经读取了 inc 的值，注意此时在线程 1 的工作内存中 inc 的值仍然为 10，所以线程 1 对 inc 进行加 1 操作后 inc 的值为 11，然后将 11 写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc 只增加了 1。</p><p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改 volatile 变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的 happens-before 规则中的 volatile 变量规则，但是要注意，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。</p><p>根源就在这里，自增操作不是原子性操作，而且 volatile 也无法保证对变量的任何操作都是原子性的。</p><h2 id="对于不保证原子性的解释"><a href="#对于不保证原子性的解释" class="headerlink" title="对于不保证原子性的解释"></a>对于不保证原子性的解释</h2><p>对于上面解释原子性的操作，大家估计会有这种疑问，即当线程 1 将变量 a 读入到了自己的工作内存，还没有修改，被阻塞；线程 2 将主存中的 a 读入工作内存修改，写入主存；线程 1 苏醒是继续运行还是会检测工作内存的变量 a 是否需要刷新呢？</p><p>对于上面问题的解释，网上大致是有两种不同的解释：<br>观点1. 当线程一读取10之后被阻塞了。然后线程二得到了执行机会，并且在执行inc自增操作的时候没有被阻塞，那么线程二执行完自增操作之后更新工作内存，然后刷新到主存中，这时线程一又有了执行机会，那么线程一继续使用之前读取的值10进行自增操作（而不是从主存中读取值11进行自增操作）。<br>观点一就是说线程二修改了主存之后，线程一再次获得执行权后并没有马上去读取主存的值进行自增操作，而是使用原来的10进行自增操作。也就是认为线程二更新主存之后，没有马上去更新线程一的工作内存，导致线程一还是之前的值。</p><p>观点2. 1⃣️线程一读取 inc 的值后，还没有操作就被阻塞了。<br>2⃣️线程二被唤醒，从主存读取 inc 的值，加 1，然后被阻塞。（此时还没来得及把新的值重新赋值给 inc，当然也还没同步到主存）。<br>3⃣️线程一被唤醒，inc 值加 1，然后同步到主存（线程一结束）。<br>4⃣️线程二被唤醒，把最新的值赋值给 inc，同步到主存（此时线程二，inc 的值在第 2 步时已经被处理过了，仅仅只是把新的值赋值给 inc 而已。这个时候是不会再去读取 inc 的缓存行的，虽然 inc 的缓存行此时已经无效了）<br>观点二可以理解为，自增操作的三步：1.复制到工作内存 2.自增 3.写入主存，其中只有 1,2 步在执行之前会检查缓存行，第 3 步是不检查的。把计算后的值赋值给变量，是不需要去检查缓存行的。</p><p>我更倾向于观点二也就是说线程二更新主存之后，会马上使得线程一得工作内存失效，在线程一再去读取Inc的值时会去读取主存中的值。</p><p>把上面的代码改成以下任何一种都可以达到效果：<br>1⃣️采用 synchronized：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2⃣️采用 Lock：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3⃣️采用 AtomicInteger：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc = new AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。volatile 会使得变量 “立即” 刷新到内存中的！而不会在写入内存之前被阻塞！</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol><p>[参考文章]<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/2019/09/20/volatile/aaa.png&quot; alt&gt;&lt;br&gt;1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。&lt;br&gt;2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-volatile关键字" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理之基本概念</title>
    <link href="http://yoursite.com/2019/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/13/计算机组成原理之基本概念/</id>
    <published>2019-09-13T11:10:22.000Z</published>
    <updated>2019-09-27T09:30:52.576Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。<br>不要问看懂看不懂，现在就是看不懂也要看啊，越到后面越需要基础的东西，早点学会基础的东西，早点享受基础知识带来的红利；<br>学计算机基础就是要苟，不知道苟啥意思是吧，我给你详细解释一下；<br><img src="/2019/09/13/计算机组成原理之基本概念/68258.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。&lt;br&gt;不要问看懂看不懂，现在就是看不懂也要看啊，越到
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理-概念" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-Trie树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-Trie树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:36:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-Trie树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-二叉树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:33:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-二叉树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-图/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:35:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-图" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-堆/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-堆" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-散列表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-散列表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:32:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-散列表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-栈/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-09-27T03:57:32.303Z</updated>
    
    <content type="html"><![CDATA[<p>不动手写一下怎么知道自己那么水呢<br>内存中的堆栈和数据结构堆栈不是一回事，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p><a id="more"></a><h2 id="用数组实现一个顺序栈"><a href="#用数组实现一个顺序栈" class="headerlink" title="用数组实现一个顺序栈"></a>用数组实现一个顺序栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package data.structure.algorithm.stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 数组实现栈</span><br><span class="line"> * @Author yuezp</span><br><span class="line"> * @Version v1.0</span><br><span class="line"> */</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line"></span><br><span class="line">    private String [] items; //数组</span><br><span class="line">    private int count;  //栈中元素个数</span><br><span class="line">    private int n;      //栈的大小</span><br><span class="line"></span><br><span class="line">    //初始化数组</span><br><span class="line">    public ArrayStack(int n) &#123;</span><br><span class="line">        this.items = new String[n];</span><br><span class="line">        this.n = n;</span><br><span class="line">        this.count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //入栈操作</span><br><span class="line">    public boolean Push (String item) &#123;</span><br><span class="line">        //将item放到下标为count的位置</span><br><span class="line">        if (count == n) &#123;  </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //将item放到下标为count的位置</span><br><span class="line">        items[count] = item;</span><br><span class="line">        count++;            </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //出栈操作</span><br><span class="line">    public String Pop () &#123;</span><br><span class="line">        //如果为零，则栈中无数据</span><br><span class="line">        if (count == 0) &#123;  </span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回数组中下标为count—1的值</span><br><span class="line">        String temp = items[count-1]; </span><br><span class="line">        count--;                      </span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用链表实现一个链式栈"><a href="#用链表实现一个链式栈" class="headerlink" title="用链表实现一个链式栈"></a>用链表实现一个链式栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package data.structure.algorithm.stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表实现栈</span><br><span class="line"> * @Author yuezp</span><br><span class="line"> * @Version v1.0</span><br><span class="line"> */</span><br><span class="line">public class StackBasedOnLinkedList &#123;</span><br><span class="line">    private Node top = null;</span><br><span class="line"></span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        // 判断是否栈空</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            top = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newNode.next = top;</span><br><span class="line">            top = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 我用 - 1 表示栈中没有数据。</span><br><span class="line">     */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (top == null) return -1;</span><br><span class="line">        int value = top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printAll() &#123;</span><br><span class="line">        Node p = top;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            System.out.print(p.data + &quot; &quot;);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Node &#123;</span><br><span class="line">        private int data;</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int data, Node next) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不动手写一下怎么知道自己那么水呢&lt;br&gt;内存中的堆栈和数据结构堆栈不是一回事，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-栈" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-跳表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-跳表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-跳表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-链表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-链表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-09-27T03:48:41.677Z</updated>
    
    <content type="html"><![CDATA[<p>不要问为什么写单链表反转这么简单的题，自己不动手试一下，怎么知道自己那么水呢；</p><a id="more"></a><h2 id="实现单链表，支持增删操作"><a href="#实现单链表，支持增删操作" class="headerlink" title="实现单链表，支持增删操作"></a>实现单链表，支持增删操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ①单链表的插入、删除、查找操作；</span><br><span class="line"> * ②链表中存储的是 int 类型的数据；</span><br><span class="line"> */</span><br><span class="line">public class SinglyLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    private Node head = null;</span><br><span class="line"></span><br><span class="line">    public Node findByValue(int value) &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        while (p != null &amp;&amp; p.data != value) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node findByIndex(int index) &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        while (p != null &amp;&amp; pos != index) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无头结点</span><br><span class="line">     // 表头部插入</span><br><span class="line">     // 这种操作将于输入的顺序相反，逆序</span><br><span class="line">     public void insertToHead(int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertToHead(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertToHead(Node newNode) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     // 顺序插入，链表尾部插入</span><br><span class="line">     public void insertTail(int value)&#123;</span><br><span class="line"></span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        // 空链表，可以插入新节点作为 head，也可以不操作</span><br><span class="line">         if (head == null)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node q = head;</span><br><span class="line">            while(q.next != null)&#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = q.next;</span><br><span class="line">            q.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insertAfter(Node p, int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertAfter(p, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertAfter(Node p, Node newNode) &#123;</span><br><span class="line">        if (p == null) return;</span><br><span class="line"></span><br><span class="line">        newNode.next = p.next;</span><br><span class="line">        p.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertBefore(Node p, int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertBefore(p, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertBefore(Node p, Node newNode) &#123;</span><br><span class="line">        if (p == null) return;</span><br><span class="line">        if (head == p) &#123;</span><br><span class="line">            insertToHead(newNode);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node q = head;</span><br><span class="line">        while (q != null &amp;&amp; q.next != p) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newNode.next = p;</span><br><span class="line">        q.next = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteByNode(Node p) &#123;</span><br><span class="line">        if (p == null || head == null) return;</span><br><span class="line"></span><br><span class="line">        if (p == head) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node q = head;</span><br><span class="line">        while (q != null &amp;&amp; q.next != p) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.next = q.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteByValue(int value) &#123;</span><br><span class="line">        if (head == null) return;</span><br><span class="line"></span><br><span class="line">        Node p = head;</span><br><span class="line">        Node q = null;</span><br><span class="line">        while (p != null &amp;&amp; p.data != value) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (p == null) return;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            q.next = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printAll() &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            System.out.print(p.data + &quot; &quot;);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断 true or false</span><br><span class="line">    public boolean TFResult(Node left, Node right)&#123;</span><br><span class="line">        Node l = left;</span><br><span class="line">        Node r = right;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;left_:&quot;+l.data);</span><br><span class="line">        System.out.println(&quot;right_:&quot;+r.data);</span><br><span class="line">        while(l != null &amp;&amp; r != null)&#123;</span><br><span class="line">           if (l.data == r.data)&#123;</span><br><span class="line">               l = l.next;</span><br><span class="line">               r = r.next;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 什么结果 &quot;);</span><br><span class="line">        if (l==null &amp;&amp; r==null)&#123;</span><br><span class="line">           System.out.println(&quot; 什么结果 &quot;);</span><br><span class="line">           return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //　判断是否为回文 </span><br><span class="line"></span><br><span class="line">    public boolean palindrome()&#123;</span><br><span class="line">       if (head == null)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           System.out.println(&quot; 开始执行找到中间节点 &quot;);</span><br><span class="line">           Node p = head;</span><br><span class="line">           Node q = head;</span><br><span class="line">           if (p.next == null)&#123;</span><br><span class="line">               System.out.println(&quot; 只有一个元素 &quot;);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           while( q.next != null &amp;&amp; q.next.next != null)&#123;</span><br><span class="line">               p = p.next;</span><br><span class="line">               q = q.next.next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           System.out.println(&quot; 中间节点 &quot; + p.data);</span><br><span class="line">           System.out.println(&quot; 开始执行奇数节点的回文判断 &quot;);</span><br><span class="line">           Node leftLink = null;</span><br><span class="line">           Node rightLink = null;</span><br><span class="line">           if(q.next == null)&#123;</span><br><span class="line">               //　p 一定为整个链表的中点，且节点数目为奇数</span><br><span class="line">               rightLink = p.next;</span><br><span class="line">               leftLink = inverseLinkList(p).next;</span><br><span class="line">               System.out.println(&quot; 左边第一个节点 &quot;+leftLink.data);</span><br><span class="line">               System.out.println(&quot; 右边第一个节点 &quot;+rightLink.data);</span><br><span class="line"></span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               //p q　均为中点</span><br><span class="line">               rightLink = p.next;</span><br><span class="line">               leftLink = inverseLinkList(p);</span><br><span class="line">           &#125;</span><br><span class="line">           return TFResult(leftLink, rightLink);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 带结点的链表翻转</span><br><span class="line">     public Node inverseLinkList_head(Node p)&#123;</span><br><span class="line">        //　Head　为新建的一个头结点</span><br><span class="line">         Node Head = new Node(9999,null);</span><br><span class="line">        // p　为原来整个链表的头结点，现在 Head 指向　整个链表</span><br><span class="line">         Head.next = p;</span><br><span class="line">        /*</span><br><span class="line">        带头结点的链表翻转等价于</span><br><span class="line">        从第二个元素开始重新头插法建立链表</span><br><span class="line">         */</span><br><span class="line">        Node Cur = p.next;</span><br><span class="line">        p.next = null;</span><br><span class="line">        Node next = null;</span><br><span class="line"></span><br><span class="line">        while(Cur != null)&#123;</span><br><span class="line">            next = Cur.next;</span><br><span class="line">            Cur.next = Head.next;</span><br><span class="line">            Head.next = Cur;</span><br><span class="line">            System.out.println(&quot;first &quot; + Head.data);</span><br><span class="line"></span><br><span class="line">            Cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //　返回左半部分的中点之前的那个节点</span><br><span class="line">         //　从此处开始同步像两边比较</span><br><span class="line">         return Head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无头结点的链表翻转</span><br><span class="line">     public Node inverseLinkList(Node p)&#123;</span><br><span class="line"></span><br><span class="line">        Node pre = null;</span><br><span class="line">        Node r = head;</span><br><span class="line">        System.out.println(&quot;z---&quot; + r.data);</span><br><span class="line">        Node next= null;</span><br><span class="line">        while(r !=p)&#123;</span><br><span class="line">            next = r.next;</span><br><span class="line"></span><br><span class="line">            r.next = pre;</span><br><span class="line">            pre = r;</span><br><span class="line">            r = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.next = pre;</span><br><span class="line">        //　返回左半部分的中点之前的那个节点</span><br><span class="line">         //　从此处开始同步像两边比较</span><br><span class="line">         return r;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Node createNode(int value) &#123;</span><br><span class="line">        return new Node(value, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        private int data;</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int data, Node next) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        SinglyLinkedList link = new SinglyLinkedList(); </span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">        //int data[] = &#123;1&#125;;</span><br><span class="line">        //int data[] = &#123;1,2&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,3,1&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,5&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,2,1&#125;;</span><br><span class="line">       // int data[] = &#123;1,2,5,2,1&#125;;</span><br><span class="line">        int data[] = &#123;1,2,5,3,1&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i =0; i &lt; data.length; i++)&#123;</span><br><span class="line">            //link.insertToHead(data[i]);</span><br><span class="line">            link.insertTail(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">       // link.printAll();</span><br><span class="line">       // Node p = link.inverseLinkList_head(link.head);</span><br><span class="line">       // while(p != null)&#123;</span><br><span class="line">       //     System.out.println(&quot;aa&quot;+p.data);</span><br><span class="line">       //     p = p.next;</span><br><span class="line">       // &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 打印原始:&quot;);</span><br><span class="line">        link.printAll();</span><br><span class="line">        if (link.palindrome())&#123;</span><br><span class="line">            System.out.println(&quot; 回文 &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot; 不是回文 &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现单链表反转"><a href="#实现单链表反转" class="headerlink" title="实现单链表反转"></a>实现单链表反转</h2><p>方法一：迭代法</p><p>假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。<br>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null; //前指针节点</span><br><span class="line">    ListNode curr = head; //当前指针节点</span><br><span class="line">    //每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next; //临时节点，暂存当前节点的下一节点，用于后移</span><br><span class="line">        curr.next = prev; //将当前节点指向它前面的节点</span><br><span class="line">        prev = curr; //前指针后移</span><br><span class="line">        curr = nextTemp; //当前指针后移</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接] <a href="https://www.iteye.com/blog/shmilyaw-hotmail-com-1798307" target="_blank" rel="noopener">https://www.iteye.com/blog/shmilyaw-hotmail-com-1798307</a></p><h2 id="实现两个有序的链表合并为一个有序链表"><a href="#实现两个有序的链表合并为一个有序链表" class="headerlink" title="实现两个有序的链表合并为一个有序链表"></a>实现两个有序的链表合并为一个有序链表</h2><p>方法一：即迭代法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line"></span><br><span class="line">        // 利用哨兵结点简化实现难度,哨兵节点即指向链表第一个节点的头结点，头结点中的数据没有实际意义；</span><br><span class="line">        ListNode soldier = new ListNode(0); </span><br><span class="line">        ListNode p = soldier;</span><br><span class="line">        </span><br><span class="line">        while ( l1 != null &amp;&amp; l2 != null )&#123;</span><br><span class="line">            if ( l1.val &lt; l2.val )&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (l1 != null) &#123; p.next = l1; &#125;</span><br><span class="line">        if (l2 != null) &#123; p.next = l2; &#125;</span><br><span class="line">        return soldier.next; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归法</p><p>递归实现请转数据结构-递归</p><h2 id="实现求链表的中间结点"><a href="#实现求链表的中间结点" class="headerlink" title="实现求链表的中间结点"></a>实现求链表的中间结点</h2><ul><li>当链表是偶数时，我们需要判断他自身是否为 null，如果为 null，说明到了末尾。</li><li>当链表是奇数时，我们需要判断他的 next 是否为 null，如果是 null，说明到了末尾。</li></ul><!-- more --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 求单链表的中间节点：</span><br><span class="line"> * 如果长度为奇数，则求出中间节点</span><br><span class="line"> * abcde---&gt;c</span><br><span class="line"> * 如果长度为偶数，则求出第二个中间节点</span><br><span class="line"> * abcdef---&gt;d </span><br><span class="line"> * 总体上的思想用的还是快慢指针，跟链表中是否包含环的求解思想一样</span><br><span class="line"> */</span><br><span class="line">public class LinkMiddle&#123;</span><br><span class="line"></span><br><span class="line">    // 求中间结点</span><br><span class="line">    public static LinkNode findMiddleNode(LinkNode list) &#123;</span><br><span class="line">        if (list == null) return null;</span><br><span class="line"></span><br><span class="line">        LinkNode fast = list;</span><br><span class="line">        LinkNode slow = list;</span><br><span class="line"></span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkNode linkNode1 = new LinkNode(&quot;1&quot;);</span><br><span class="line">        LinkNode linkNode2 = new LinkNode(&quot;2&quot;);</span><br><span class="line">        LinkNode linkNode3 = new LinkNode(&quot;3&quot;);</span><br><span class="line">        LinkNode linkNode4 = new LinkNode(&quot;4&quot;);</span><br><span class="line">        LinkNode linkNode5 = new LinkNode(&quot;5&quot;);</span><br><span class="line">        linkNode1.setNext(linkNode2);</span><br><span class="line">        linkNode2.setNext(linkNode3);</span><br><span class="line">        linkNode3.setNext(linkNode4);</span><br><span class="line">        linkNode4.setNext(linkNode5);</span><br><span class="line">        LinkNode mid =  findMiddleNode(linkNode1);</span><br><span class="line">        System.out.print(mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class LinkNode &#123;</span><br><span class="line"></span><br><span class="line">        private String val;</span><br><span class="line"></span><br><span class="line">        private LinkNode next;</span><br><span class="line"></span><br><span class="line">        public LinkNode(String data)&#123;</span><br><span class="line">            this.val  = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getData() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public LinkNode getNext() &#123;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNext(LinkNode next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;[&quot;+val+&quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要问为什么写单链表反转这么简单的题，自己不动手试一下，怎么知道自己那么水呢；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-链表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
