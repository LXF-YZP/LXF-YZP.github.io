<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-15T07:08:30.089Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac 使用 brew update 无反应，更新慢解决办法</title>
    <link href="http://yoursite.com/2020/05/15/mac%20%E4%BD%BF%E7%94%A8%20brew%20update%20%E6%97%A0%E5%8F%8D%E5%BA%94%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/15/mac 使用 brew update 无反应，更新慢解决办法/</id>
    <published>2020-05-15T11:57:10.000Z</published>
    <updated>2020-05-15T07:08:30.089Z</updated>
    
    <content type="html"><![CDATA[<p>每次 brew update 或 brew install xxx 都需要等很长时间；</p><h3 id="使用中科大的镜像替换默认源"><a href="#使用中科大的镜像替换默认源" class="headerlink" title="使用中科大的镜像替换默认源"></a>使用中科大的镜像替换默认源</h3><ul><li>第一步，替换 brew.git<h4 id="进入brew主目录"><a href="#进入brew主目录" class="headerlink" title="进入brew主目录"></a>进入brew主目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更换镜像"><a href="#更换镜像" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure><ul><li>第二步：替换 homebrew-core.git<h4 id="进入brew主目录-1"><a href="#进入brew主目录-1" class="headerlink" title="进入brew主目录"></a>进入brew主目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更换镜像-1"><a href="#更换镜像-1" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><ul><li>最后使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></li></ul><h3 id="几个镜像"><a href="#几个镜像" class="headerlink" title="几个镜像:"></a>几个镜像:</h3><ul><li><a href="https://git.coding.net/homebrew/homebrew.git" target="_blank" rel="noopener">https://git.coding.net/homebrew/homebrew.git</a> - Coding</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</a> - 清华</li><li><a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a> - 中科大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次 brew update 或 brew install xxx 都需要等很长时间；&lt;/p&gt;
&lt;h3 id=&quot;使用中科大的镜像替换默认源&quot;&gt;&lt;a href=&quot;#使用中科大的镜像替换默认源&quot; class=&quot;headerlink&quot; title=&quot;使用中科大的镜像替换默认源&quot;&gt;
      
    
    </summary>
    
    
      <category term="Mac、brew更新" scheme="http://yoursite.com/categories/Mac%E3%80%81brew%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>python3.8 不能使用 requests 问题</title>
    <link href="http://yoursite.com/2020/05/14/python3.7%20%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%20requests%20%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/14/python3.7 不能使用 requests 问题/</id>
    <published>2020-05-14T11:57:10.000Z</published>
    <updated>2020-05-15T07:14:23.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码会提示"><a href="#代码会提示" class="headerlink" title="代码会提示"></a>代码会提示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &apos;requests&apos;</span><br></pre></td></tr></table></figure><h4 id="问题：因为你的-python-还未安装-requests-库，需要通过-pip-安装。"><a href="#问题：因为你的-python-还未安装-requests-库，需要通过-pip-安装。" class="headerlink" title="问题：因为你的 python 还未安装 requests 库，需要通过 pip 安装。"></a>问题：因为你的 python 还未安装 requests 库，需要通过 pip 安装。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">luxiaofeng@yuezpdeMacBook-Pro~ pip3 install requests</span><br><span class="line">Collecting requests</span><br><span class="line">  Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85E8A760</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85E8A340</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EACDC0</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EACAC0</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;ConnectTimeoutError(&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x0000021F85EAC610</span><br><span class="line">&gt;, &apos;Connection to pypi.org timed out. (connect timeout=15)&apos;)&apos;: /simple/requests/</span><br><span class="line">  Could not find a version that satisfies the requirement requests (from versions: )</span><br><span class="line">No matching distribution found for requests</span><br></pre></td></tr></table></figure><p>从执行的过程来看，请求一直处于超时。这是由于国内很多情况下，无法正常去下载国外服务器资源导致。</p><h4 id="解决方法：使用国内镜像，常用的有镜像有"><a href="#解决方法：使用国内镜像，常用的有镜像有" class="headerlink" title="解决方法：使用国内镜像，常用的有镜像有"></a>解决方法：使用国内镜像，常用的有镜像有</h4><ul><li>清华大学镜像：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>阿里云：<a href="https://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple/</a></li><li>中科大镜像：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>中科大镜像 2：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul><h4 id="使用镜像的安装范式为："><a href="#使用镜像的安装范式为：" class="headerlink" title="使用镜像的安装范式为："></a>使用镜像的安装范式为：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install xxxx -i http://… 或者 pip install  -i https://… xxxx。</span><br><span class="line"># 示例如下：</span><br><span class="line">pip install requests -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><h4 id="注意：如果安装过程中提示需要升级-pip"><a href="#注意：如果安装过程中提示需要升级-pip" class="headerlink" title="注意：如果安装过程中提示需要升级 pip"></a>注意：如果安装过程中提示需要升级 pip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.</span><br><span class="line"># 解决命令</span><br><span class="line">python -m pip install --upgrade pip -i http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码会提示&quot;&gt;&lt;a href=&quot;#代码会提示&quot; class=&quot;headerlink&quot; title=&quot;代码会提示&quot;&gt;&lt;/a&gt;代码会提示&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
      <category term="python学习" scheme="http://yoursite.com/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="包安装" scheme="http://yoursite.com/tags/%E5%8C%85%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>PostConstruct注解</title>
    <link href="http://yoursite.com/2020/05/13/@PostConstruct%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/13/@PostConstruct注解/</id>
    <published>2020-05-13T11:57:10.000Z</published>
    <updated>2020-05-13T09:49:12.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PostConstruct-的-API-使用说明"><a href="#PostConstruct-的-API-使用说明" class="headerlink" title="@PostConstruct 的 API 使用说明"></a>@PostConstruct 的 API 使用说明</h3><blockquote><p>PostConstruct 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。应用 PostConstruct 注释的方法必须遵守以下所有标准：该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext 对象 ；该方法的返回类型必须为 void；该方法不得抛出已检查异常；应用 PostConstruct 的方法可以是 public、protected、package private 或 private；除了应用程序客户端之外，该方法不能是 static；该方法可以是 final；如果该方法抛出未检查异常，那么不得将类放入服务中，除非是能够处理异常并可从中恢复的 EJB。</p></blockquote><a id="more"></a><p><strong><em>总结为一下几点：</em></strong></p><ul><li>只有一个方法可以使用此注释进行注解；</li><li>被注解方法不得有任何参数；</li><li>被注解方法返回值为 void；</li><li>被注解方法不得抛出已检查异常；</li><li>被注解方法需是非静态方法；</li><li>此方法只会被执行一次；</li></ul><p>在具体 Bean 的实例化过程中，@PostConstruct 注释的方法，会在构造方法之后，init 方法之前进行调用。</p><ul><li><p>UserService 方法（提供缓存数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public List&lt;String&gt; getUser()&#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;张三&quot;);</span><br><span class="line">        list.add(&quot;李四&quot;);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BusinessService 方法，通过 @PostConstruct 调用 UserService：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.PostConstruct;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BusinessService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; list = null;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法执行之后，调用此方法</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;@PostConstruct方法被调用&quot;);</span><br><span class="line">        // 实例化类之前缓存获得用户信息</span><br><span class="line">        List&lt;String&gt; list = userService.getUser();</span><br><span class="line">        this.list = list;</span><br><span class="line">        if(list != null &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">            for(String user : list)&#123;</span><br><span class="line">                System.out.println(&quot;用户：&quot; + user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessService()&#123;</span><br><span class="line">        System.out.println(&quot;构造方法被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法被调用</span><br><span class="line">@PostConstruct方法被调用</span><br><span class="line">用户：张三</span><br><span class="line">用户：李四</span><br></pre></td></tr></table></figure></li></ul><p>[参考链接]<a href="https://blog.csdn.net/wo541075754/article/details/52174900" target="_blank" rel="noopener">https://blog.csdn.net/wo541075754/article/details/52174900</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PostConstruct-的-API-使用说明&quot;&gt;&lt;a href=&quot;#PostConstruct-的-API-使用说明&quot; class=&quot;headerlink&quot; title=&quot;@PostConstruct 的 API 使用说明&quot;&gt;&lt;/a&gt;@PostConstruct 的 API 使用说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;PostConstruct 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。应用 PostConstruct 注释的方法必须遵守以下所有标准：该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext 对象 ；该方法的返回类型必须为 void；该方法不得抛出已检查异常；应用 PostConstruct 的方法可以是 public、protected、package private 或 private；除了应用程序客户端之外，该方法不能是 static；该方法可以是 final；如果该方法抛出未检查异常，那么不得将类放入服务中，除非是能够处理异常并可从中恢复的 EJB。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java注解" scheme="http://yoursite.com/tags/Java%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/2020/05/08/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/08/代理模式/</id>
    <published>2020-05-08T11:57:10.000Z</published>
    <updated>2020-05-08T06:17:27.792Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性三</title>
    <link href="http://yoursite.com/2020/05/07/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%89/"/>
    <id>http://yoursite.com/2020/05/07/Java8新特性三/</id>
    <published>2020-05-07T11:57:10.000Z</published>
    <updated>2020-05-07T02:18:44.177Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性二</title>
    <link href="http://yoursite.com/2020/05/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/05/06/Java8新特性二/</id>
    <published>2020-05-06T11:57:10.000Z</published>
    <updated>2020-05-07T02:18:14.406Z</updated>
    
    <content type="html"><![CDATA[<p>Java8新特性之方法引用， </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8新特性之方法引用， &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性一</title>
    <link href="http://yoursite.com/2020/04/25/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80/"/>
    <id>http://yoursite.com/2020/04/25/Java8新特性一/</id>
    <published>2020-04-25T11:57:10.000Z</published>
    <updated>2020-05-06T08:44:42.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="为什么要使用-lambda-表达式"><a href="#为什么要使用-lambda-表达式" class="headerlink" title="为什么要使用 lambda 表达式"></a>为什么要使用 lambda 表达式</h4><p>我们直接举个例子来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest1 &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        //第一种</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;不使用Lambda表达式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        System.out.println(&quot;=======================&quot;);</span><br><span class="line">        //第二种</span><br><span class="line">        Runnable runnable1 = () -&gt; System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        runnable1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*不使用Lambda表达式</span><br><span class="line">=======================</span><br><span class="line">使用Lambda表达式*/</span><br></pre></td></tr></table></figure><p>之前我们新建一个线程使用 5 行代码，但是如果我们使用 lambda 表达式只需要 1 行代码即可，是不是很方便。</p><a id="more"></a><h4 id="lambda-表达式的使用"><a href="#lambda-表达式的使用" class="headerlink" title="lambda 表达式的使用"></a>lambda 表达式的使用</h4><ul><li>基本语法</li></ul><p>1.左边括号：lambda 的形参列表，就好比是我们定义一个接口，里面有一个抽象方法，这个抽象方法的形参列表。<br>2.箭头：lambda 的操作符，所以你看见这个箭头心中知道这是一个 lambda 表达式就可以了。<br>3.右边 lambda 体：就好比是我们实现了接口中的抽象方法。</p><ul><li><p>无参无返回值<br>这个是最简单的一种情况，就是刚刚我们所举的例子。为了不混淆我们再举一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//此时如果方法体比较复杂好几行代码，那么这个&#123;&#125;是不能省略的</span><br><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">            System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>有参数无返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(String s) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(&quot;没有使用lambda:有参数，但是没有返回值&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Consumer&lt;String&gt; consumer1 = (String s)-&gt;&#123;</span><br><span class="line">        //此时只有一行输出代码，因此可以省去外部的&#123;&#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(&quot;使用lambda:有参数，但是没有返回值&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参数无返回值，数据类型可省略，称为类型推断<br>这种情况只能称之为上面的一种特例，只不过我们可以不传入类型，由编译器帮我们推断出来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer1 = (s)-&gt;&#123;</span><br><span class="line">      //此时只有一行输出代码，因此可以省去外部的&#123;&#125;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(&quot;使用lambda:有参数，但是没有返回值&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有多个参数，有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            System.out.println(&quot;o1:&quot;+o1);</span><br><span class="line">            return o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator.compare(1,2));</span><br><span class="line">    System.out.println(&quot;======================&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator2 = (o1,o2)-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;o1:&quot;+o1);</span><br><span class="line">        return o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator2.compare(1,2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们使用了一个比较器，当然了如果只有一条 return 语句的话，那样式就更简单了。箭头直接指向我们要返回的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    //第一种：没有使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator.compare(1,2));</span><br><span class="line">    System.out.println(&quot;======================&quot;);</span><br><span class="line">    //第二种：使用lambda表达式</span><br><span class="line">    Comparator&lt;Integer&gt; comparator2 = (o1,o2)-&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator2.compare(1,2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda-表达式深入解析"><a href="#Lambda-表达式深入解析" class="headerlink" title="Lambda 表达式深入解析"></a>Lambda 表达式深入解析</h4><ul><li>什么是函数式接口</li></ul><p>比如我们的 Runnable 就是一个函数式接口，我们可以到源码中看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他主要有如下的特点：</p><blockquote><blockquote><p>含有 @FunctionalInterface 注解</p></blockquote></blockquote><blockquote><blockquote><p>只有一个抽象方法<br>也就是说只有函数式接口的变量或者是函数式接口，才能够赋值为 Lambda 表达式。当然了方法的类型可以任意。</p></blockquote></blockquote><ul><li>参数的小括号可以省略，当且仅当只有一个参数.</li><li>参数的数据类型可以省略，当且仅当 lambda表达式.</li><li>方法体的 return 和大括号可以省略，当且仅当只有一条语句.</li></ul><p>只包含一个抽象方法的接口, 称为函数式接口(除了隐含的Object对象的公共方法)；<br>函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和 Object 的 public方法一样 (必须满足即使 Object 的方法，又是 public 的接口，像 Object 的 clone () 接口就不是 public)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h3&gt;&lt;h4 id=&quot;为什么要使用-lambda-表达式&quot;&gt;&lt;a href=&quot;#为什么要使用-lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 lambda 表达式&quot;&gt;&lt;/a&gt;为什么要使用 lambda 表达式&lt;/h4&gt;&lt;p&gt;我们直接举个例子来看看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LambdaTest1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void test1() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //第一种&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runnable runnable = new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;不使用Lambda表达式&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runnable.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;=======================&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //第二种&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runnable runnable1 = () -&amp;gt; System.out.println(&amp;quot;使用Lambda表达式&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runnable1.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*不使用Lambda表达式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=======================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用Lambda表达式*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;之前我们新建一个线程使用 5 行代码，但是如果我们使用 lambda 表达式只需要 1 行代码即可，是不是很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、新特性" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>安装gradle</title>
    <link href="http://yoursite.com/2020/04/14/%E5%AE%89%E8%A3%85gradle/"/>
    <id>http://yoursite.com/2020/04/14/安装gradle/</id>
    <published>2020-04-14T11:57:10.000Z</published>
    <updated>2020-04-14T08:50:13.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gradle-安装（Mac）"><a href="#Gradle-安装（Mac）" class="headerlink" title="Gradle 安装（Mac）"></a>Gradle 安装（Mac）</h3><ul><li>下载 Gradle<br>先检查 java 环境，是否安装了 jdk 或者 jre 8 或者以上版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version &quot;1.8.0_121&quot;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>官网下载：<a href="https://gradle.org/releases" target="_blank" rel="noopener">https://gradle.org/releases</a><br>选择某一版本的 binary-only 进行下载，例如：<br><img src="/2020/04/14/安装gradle/aaa.png" alt><br>将下载的文件解压到某一目录下，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip gradle-5.2.1-bin.zip</span><br></pre></td></tr></table></figure><ul><li>配置环境变量<br>编辑 bash_profile 文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><p>加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#GRADLE</span><br><span class="line">GRADLE_HOME=/Users/luxiaofeng/gradle</span><br><span class="line">PATH=$PATH:$GRADLE_HOME/bin</span><br><span class="line">export GRADLE_HOME GRADLE_USER_HOME PATH</span><br></pre></td></tr></table></figure><p>执行下面命令使内容生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>测试安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -v</span><br></pre></td></tr></table></figure><p>出现下面内容表示安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">luxiaofeng@yuezhipingdeMacBook-Pro  ~  gradle -v</span><br><span class="line"></span><br><span class="line">Welcome to Gradle 5.2.1!</span><br><span class="line"></span><br><span class="line">Here are the highlights of this release:</span><br><span class="line"> - Define sets of dependencies that work together with Java Platform plugin</span><br><span class="line"> - New C++ plugins with dependency management built-in</span><br><span class="line"> - New C++ project types for gradle init</span><br><span class="line"> - Service injection into plugins and project extensions</span><br><span class="line"></span><br><span class="line">For more details see https://docs.gradle.org/5.2.1/release-notes.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 5.2.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2019-02-08 19:00:10 UTC</span><br><span class="line">Revision:     f02764e074c32ee8851a4e1877dd1fea8ffb7183</span><br><span class="line"></span><br><span class="line">Kotlin DSL:   1.1.3</span><br><span class="line">Kotlin:       1.3.20</span><br><span class="line">Groovy:       2.5.4</span><br><span class="line">Ant:          Apache Ant(TM) version 1.9.13 compiled on July 10 2018</span><br><span class="line">JVM:          1.8.0_221 (Oracle Corporation 25.221-b11)</span><br><span class="line">OS:           Mac OS X 10.15.3 x86_64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gradle-安装（Mac）&quot;&gt;&lt;a href=&quot;#Gradle-安装（Mac）&quot; class=&quot;headerlink&quot; title=&quot;Gradle 安装（Mac）&quot;&gt;&lt;/a&gt;Gradle 安装（Mac）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载 Gradle&lt;br&gt;先检查 java 环境，是否安装了 jdk 或者 jre 8 或者以上版本：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java version &amp;quot;1.8.0_121&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="包管理工具" scheme="http://yoursite.com/categories/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="包管理工具" scheme="http://yoursite.com/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>java反射详解</title>
    <link href="http://yoursite.com/2020/03/28/java%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/28/java反射详解/</id>
    <published>2020-03-28T11:57:10.000Z</published>
    <updated>2020-04-09T05:54:32.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p>Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。<br>用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。</p><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>静态编译：在编译时确定类型，绑定对象，即通过。<br>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了 java 的灵活性，体现了多态的应用，用于降低类之间的藕合性。</p><a id="more"></a><p>优点<br>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在 J2EE 的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p><p>缺点<br>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p><h3 id="理解-Class-类和类类型"><a href="#理解-Class-类和类类型" class="headerlink" title="理解 Class 类和类类型"></a>理解 Class 类和类类型</h3><p>想要了解反射首先理解一下 Class 类，它是反射实现的基础。<br>所有的类是 java.lang.Class 类的实例对象，而 Class 是所有类的类（There is a class named Class）<br>对于普通的对象，我们一般都会这样创建和表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code code1 = new Code();</span><br></pre></td></tr></table></figure><p>上面说了，所有的类都是 Class 的对象，那么如何表示呢，可不可以通过如下方式呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = new Class();</span><br></pre></td></tr></table></figure><p>但是我们查看 Class 的源码时，是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private  Class(ClassLoader loader) &#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到构造器是私有的，只有 JVM 可以创建 Class 的对象，因此不可以像普通类一样 new 一个 Class 对象，虽然我们不能 new 一个 Class 对象，但是却可以通过已有的类得到一个 Class 对象，共有三种方式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Code.class;</span><br><span class="line">这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span><br><span class="line">Class c2 = code1.getClass();</span><br><span class="line">code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span><br><span class="line">Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);</span><br><span class="line">这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span><br></pre></td></tr></table></figure><p>这里，c1、c2、c3 都是 Class 的对象，他们是完全一样的，而且有个学名，叫做 Code 的类类型（class type）。<br>这里就让人奇怪了，前面不是说 Code 是 Class 的对象吗，而 c1、c2、c3 也是 Class 的对象，那么 Code 和 c1、c2、c3 不就一样了吗？为什么还叫 Code 什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</p><p>举个简单例子代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //第一种：Class c1 = Code.class;</span><br><span class="line">        Class class1=ReflectDemo.class;</span><br><span class="line">        System.out.println(class1.getName());</span><br><span class="line"></span><br><span class="line">        //第二种：Class c2 = code1.getClass();</span><br><span class="line">        ReflectDemo demo2= new ReflectDemo();</span><br><span class="line">        Class c2 = demo2.getClass();</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line"></span><br><span class="line">        //第三种：Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);</span><br><span class="line">        Class class3 = Class.forName(&quot;com.tengj.reflect.ReflectDemo&quot;);</span><br><span class="line">        System.out.println(class3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br></pre></td></tr></table></figure><h3 id="Java-反射相关操作"><a href="#Java-反射相关操作" class="headerlink" title="Java 反射相关操作"></a>Java 反射相关操作</h3><p>前面我们知道了怎么获取 Class，那么我们可以通过这个 Class 干什么呢？<br>总结如下：</p><ul><li>获取成员方法 Method</li><li>获取成员变量 Field</li><li>获取构造函数 Constructor</li></ul><h4 id="获取成员方法信息"><a href="#获取成员方法信息" class="headerlink" title="获取成员方法信息"></a>获取成员方法信息</h4><p>单独获取某一个方法是通过 Class 类的以下方法获得的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的</span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的</span><br></pre></td></tr></table></figure><p>两个参数分别是方法名和方法参数类的类类型列表。<br>例如类 A 有如下一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void fun(String name,int age) &#123;</span><br><span class="line">    System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在知道 A 有一个对象 a，那么就可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);  //先生成class</span><br><span class="line">Object o = c.newInstance();                           //newInstance可以初始化一个实例</span><br><span class="line">Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);//获取方法</span><br><span class="line">method.invoke(o, &quot;tengj&quot;, 10);                              //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String msg=&quot;hello wrold&quot;;</span><br><span class="line"> public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        System.out.println(&quot;fun&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun(String name,int age) &#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);</span><br><span class="line">            method.invoke(o, &quot;tengj&quot;, 10);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫tengj,今年10岁</span><br></pre></td></tr></table></figure><p>有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：<br>1.获取所有方法的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的</span><br><span class="line">或者：</span><br><span class="line">Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的</span><br></pre></td></tr></table></figure><p>2.然后循环这个数组就得到每个方法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Method method : methods)</span><br></pre></td></tr></table></figure><p>完整代码如下：<br>person 类跟上面一样，这里以及后面就不贴出来了，只贴关键代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            for(Method m:methods)&#123;</span><br><span class="line">                String  methodName= m.getName();</span><br><span class="line">                System.out.println(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">getAge</span><br></pre></td></tr></table></figure><p>这里如果把 c.getDeclaredMethods (); 改成 c.getMethods (); 执行结果如下，多了很多方法，以为把 Object 里面的方法也打印出来了，因为 Object 是所有类的父类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br></pre></td></tr></table></figure><h4 id="获取成员变量信息"><a href="#获取成员变量信息" class="headerlink" title="获取成员变量信息"></a>获取成员变量信息</h4><p>想一想成员变量中都包括什么：成员变量类型 + 成员变量名<br>类的成员变量也是一个对象，它是 java.lang.reflect.Field 的一个对象，所以我们通过 java.lang.reflect.Field 里面封装的方法来获取这些信息。</p><p>单独获取某个成员变量，通过 Class 类的以下方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量</span><br><span class="line">public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量</span><br></pre></td></tr></table></figure><p>参数是成员变量的名字。<br>例如一个类 A 有如下成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int n;</span><br></pre></td></tr></table></figure><p>如果 A 有一个对象 a，那么就可以这样得到其成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Field field = c.getDeclaredField(&quot;n&quot;);</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取成员变量</span><br><span class="line">            Field field = c.getDeclaredField(&quot;msg&quot;); //因为msg变量是private的，所以不能用getField方法</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。</span><br><span class="line">            Object msg = field.get(o);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello wrold</span><br></pre></td></tr></table></figure><p>同样，如果想要获取所有成员变量的信息，可以通过以下几步<br>1.获取所有成员变量的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>2.遍历变量数组，获得某个成员变量 field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Field field : fields)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            for(Field field :fields)&#123;</span><br><span class="line">                System.out.println(field.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">msg</span><br></pre></td></tr></table></figure><h4 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h4><p>最后再想一想构造函数中都包括什么：构造函数参数<br>同上，类的成构造函数也是一个对象，它是 java.lang.reflect.Constructor 的一个对象，所以我们通过 java.lang.reflect.Constructor 里面封装的方法来获取这些信息。</p><p>单独获取某个构造函数，通过 Class 类的以下方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) //  获得该类所有的构造器，不包括其父类的构造器</span><br><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类</span><br></pre></td></tr></table></figure><p>这个参数为构造函数参数类的类类型列表。<br>例如类 A 有如下一个构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public A(String a, int b) &#123;</span><br><span class="line">    // code body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = a.getDeclaredConstructor(String.class, int.class);</span><br></pre></td></tr></table></figure><p>来获取这个构造函数。</p><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取构造函数</span><br><span class="line">            Constructor constructor = c.getDeclaredConstructor(String.class);</span><br><span class="line">            constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。</span><br><span class="line">            constructor.newInstance(&quot;tengj&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tengj</span><br></pre></td></tr></table></figure><p>注意：Class 的 newInstance 方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：fromClass.getDeclaredConstructor (String.class).newInstance (“tengj”);</p><p>获取所有的构造函数，可以通过以下步骤实现：<br>1.获取该类的所有构造函数，放在一个数组中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure><p>2.遍历构造函数数组，获得某个构造函数 constructor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Constructor constructor : constructors)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">            Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">            for(Constructor constructor:constructors)&#123;</span><br><span class="line">                System.out.println(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public com.tengj.reflect.Person()</span><br><span class="line">public com.tengj.reflect.Person(java.lang.String)</span><br></pre></td></tr></table></figure><p>通过反射了解集合泛型的本质<br>首先下结论：</p><ul><li>Java 中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</li></ul><p>下面通过一个实例来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 集合泛型的本质</span><br><span class="line"> * @description</span><br><span class="line"> * @author Trigl</span><br><span class="line"> * @date 2016年4月2日上午2:54:11</span><br><span class="line"> */</span><br><span class="line">public class GenericEssence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list1 = new ArrayList(); // 没有泛型 </span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 有泛型</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span><br><span class="line">         * 这个时候如果list2添加int类型会报错</span><br><span class="line">         */</span><br><span class="line">        list2.add(&quot;hello&quot;);</span><br><span class="line">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span><br><span class="line">        System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 此时list2长度为1</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span><br><span class="line">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span><br><span class="line">         * 型的元素</span><br><span class="line">         */</span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); // 结果：true，说明类类型完全相同</span><br><span class="line"></span><br><span class="line">        // 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span><br><span class="line">        try &#123;</span><br><span class="line">            Method m = c2.getMethod(&quot;add&quot;, Object.class); // 通过方法反射得到add方法</span><br><span class="line">            m.invoke(list2, 20); // 给list2添加一个int型的，上面显示在编译器是会报错的</span><br><span class="line">            System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 结果：2，说明list2长度增加了，并没有泛型检查</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span><br><span class="line">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2的长度是：1</span><br><span class="line">true</span><br><span class="line">list2的长度是：2</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        //创建methodClass的实例</span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        //获取methodClass类的add方法</span><br><span class="line">        Method method = klass.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">        //调用method对应的方法 =&gt; add(1,4)</span><br><span class="line">        Object result = method.invoke(obj,1,4);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class methodClass &#123;</span><br><span class="line">    public final int fuck = 3;</span><br><span class="line">    public int add(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sub(int a,int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h4><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个 Object Reference。下面我们看一看利用反射创建数组的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void testArray() throws ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">        Object array = Array.newInstance(cls,25);</span><br><span class="line">        //往数组里添加内容</span><br><span class="line">        Array.set(array,0,&quot;hello&quot;);</span><br><span class="line">        Array.set(array,1,&quot;Java&quot;);</span><br><span class="line">        Array.set(array,2,&quot;fuck&quot;);</span><br><span class="line">        Array.set(array,3,&quot;Scala&quot;);</span><br><span class="line">        Array.set(array,4,&quot;Clojure&quot;);</span><br><span class="line">        //获取某一项的内容</span><br><span class="line">        System.out.println(Array.get(array,3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 Array 类为 java.lang.reflect.Array 类。我们通过 Array.newInstance () 创建数组对象，它的原型是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object newInstance(Class&lt;?&gt; componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException &#123;</span><br><span class="line">        return newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 newArray 方法是一个 native 方法，它在 HotSpot JVM 里的具体实现我们后边再研究，这里先把源码贴出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static native Object newArray(Class&lt;?&gt; componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException;</span><br></pre></td></tr></table></figure><p>源码目录：openjdk\hotspot\src\share\vm\runtime\reflection.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) &#123;</span><br><span class="line">  if (element_mirror == NULL) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NullPointerException());</span><br><span class="line">  &#125;</span><br><span class="line">  if (length &lt; 0) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());</span><br><span class="line">  &#125;</span><br><span class="line">  if (java_lang_Class::is_primitive(element_mirror)) &#123;</span><br><span class="line">    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);</span><br><span class="line">    return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Klass* k = java_lang_Class::as_Klass(element_mirror);</span><br><span class="line">    if (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) &#123;</span><br><span class="line">      THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">    &#125;</span><br><span class="line">    return oopFactory::new_objArray(k, length, THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Array 类的 set 和 get 方法都为 native 方法，在 HotSpot JVM 里分别对应 Reflection::array_set 和 Reflection::array_get 方法，这里就不详细解析了。<br>[参考链接]<a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">http://tengj.top/2016/04/28/javareflect/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java反射机制&quot;&gt;&lt;a href=&quot;#Java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java反射机制&quot;&gt;&lt;/a&gt;Java反射机制&lt;/h3&gt;&lt;p&gt;Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。&lt;br&gt;用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。&lt;/p&gt;
&lt;h3 id=&quot;反射机制优缺点&quot;&gt;&lt;a href=&quot;#反射机制优缺点&quot; class=&quot;headerlink&quot; title=&quot;反射机制优缺点&quot;&gt;&lt;/a&gt;反射机制优缺点&lt;/h3&gt;&lt;p&gt;静态编译：在编译时确定类型，绑定对象，即通过。&lt;br&gt;动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了 java 的灵活性，体现了多态的应用，用于降低类之间的藕合性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、反射" scheme="http://yoursite.com/tags/Java%E3%80%81%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>注解详解</title>
    <link href="http://yoursite.com/2020/03/27/%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/27/注解详解/</id>
    <published>2020-03-27T11:57:10.000Z</published>
    <updated>2020-04-28T07:34:23.046Z</updated>
    
    <content type="html"><![CDATA[<p>{“ozone.om.address”:”hbase-2:9862”}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;{“ozone.om.address”:”hbase-2:9862”}&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java、注解" scheme="http://yoursite.com/tags/Java%E3%80%81%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://yoursite.com/2020/03/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/21/策略模式/</id>
    <published>2020-03-21T11:57:10.000Z</published>
    <updated>2020-03-20T09:48:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。<br>然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。</p><a id="more"></a><h2 id="二、基本的策略模式使用方法"><a href="#二、基本的策略模式使用方法" class="headerlink" title="二、基本的策略模式使用方法"></a>二、基本的策略模式使用方法</h2><p>我们直接来看例子：</p><h3 id="1-策略接口"><a href="#1-策略接口" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    void testStrategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备两个实现类"><a href="#2-准备两个实现类" class="headerlink" title="2. 准备两个实现类"></a>2. 准备两个实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 实现类A</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyA implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 实现类B</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyB implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-策略执行-Context-类"><a href="#3-策略执行-Context-类" class="headerlink" title="3. 策略执行 Context 类"></a>3. 策略执行 Context 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 策略执行</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class Context &#123;</span><br><span class="line">    </span><br><span class="line">    private Strategy stg;</span><br><span class="line">    </span><br><span class="line">    public void doAction() &#123;</span><br><span class="line">        this.stg.testStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    /*  Getter And Setter */</span><br><span class="line">    public Strategy getStg() &#123;</span><br><span class="line">        return stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStg(Strategy stg) &#123;</span><br><span class="line">        this.stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们准备一个 main 方法来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: StrategyTest</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy stgB = new StrategyB();</span><br><span class="line">        Context context = new Context(stgB);</span><br><span class="line">        context.setStg(stgB);</span><br><span class="line">        context.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、与-Spring-想结合的策略模式"><a href="#三、与-Spring-想结合的策略模式" class="headerlink" title="三、与 Spring 想结合的策略模式"></a>三、与 Spring 想结合的策略模式</h2><p>我们主要利用 Spring 的核心 IOC 来实现它，还是使用上面的例子；<br>由于我们要在 Spring 的配置文件中来注入 Context 的实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;context&quot; class = &quot;top.catalinali.search.service.impl.Context&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;stg&quot; ref=&quot;stgB&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;stgA&quot; class = &quot;top.catalinali.search.service.impl.StrategyA&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;stgB&quot; class = &quot;top.catalinali.search.service.impl.StrategyB&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就可以通过只修改配置文件来更改 context 的实现类，从而达到策略模式的目的。</p><h2 id="四、通过-Spring-使用策略模式替换中间件的单机与集群配置"><a href="#四、通过-Spring-使用策略模式替换中间件的单机与集群配置" class="headerlink" title="四、通过 Spring 使用策略模式替换中间件的单机与集群配置"></a>四、通过 Spring 使用策略模式替换中间件的单机与集群配置</h2><p>在开发环境中，许多中间件使用的是单机配置。可到了生产我们就需要使用集群配置。这里我们就可以通过策略模式来快速改变中间件的配置，现在我们以 Redis 为例：</p><h3 id="1-策略接口-1"><a href="#1-策略接口-1" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><p>首先我们把 Redis 方法抽成一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface JedisClient &#123;</span><br><span class="line">    String set(String key, String value);</span><br><span class="line">    String get(String key);</span><br><span class="line">    Boolean exists(String key);</span><br><span class="line">    Long expire(String key, int seconds);</span><br><span class="line">    Long ttl(String key);</span><br><span class="line">    Long incr(String key);</span><br><span class="line">    Long hset(String key, String field, String value);</span><br><span class="line">    String hget(String key, String field);</span><br><span class="line">    Long hdel(String key, String... field);</span><br><span class="line">    Boolean hexists(String key, String field);</span><br><span class="line">    List&lt;String&gt; hvals(String key);</span><br><span class="line">    Long del(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单机和集群两个实现类"><a href="#2-单机和集群两个实现类" class="headerlink" title="2. 单机和集群两个实现类"></a>2. 单机和集群两个实现类</h3><p>这里我们准备单机和集群两个实现类：JedisClientPool 和 JedisClientCluster。实现上面的 JedisClient 接口，分别使用单机和集群的代码来实现这些方法。因为代码冗长就不在这里贴出来了。</p><h3 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h3><p>我们使用不同的环境只需要把不用的配置注释掉就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 连接redis单机版 --&gt;</span><br><span class="line">&lt;bean id=&quot;jedisClientPool&quot; class=&quot;top.catalinali.common.jedis.JedisClientPool&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisPool&quot; ref=&quot;jedisPool&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.72.121&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 连接redis集群 --&gt;</span><br><span class="line">&lt;!-- &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;cn.e3mall.common.jedis.JedisClientCluster&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisCluster&quot; ref=&quot;jedisCluster&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;nodes&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt; --&gt;</span><br></pre></td></tr></table></figure><p>这样在我们开发时只需要注释掉连接集群的配置，而在上线时注释掉单机的配置就好。</p><p>[转载]<a href="https://segmentfault.com/a/1190000012474002" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012474002</a><br>[参考链接]<a href="https://juejin.im/post/59facc30518825297a0e164c" target="_blank" rel="noopener">https://juejin.im/post/59facc30518825297a0e164c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是策略模式？&quot;&gt;&lt;a href=&quot;#一、什么是策略模式？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是策略模式？&quot;&gt;&lt;/a&gt;一、什么是策略模式？&lt;/h2&gt;&lt;p&gt;在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。&lt;br&gt;然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="策略模式" scheme="http://yoursite.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="http://yoursite.com/2020/03/20/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/20/装饰器模式/</id>
    <published>2020-03-20T11:57:10.000Z</published>
    <updated>2020-04-13T08:46:45.443Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="装饰器模式" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板模式</title>
    <link href="http://yoursite.com/2020/03/19/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/19/模板模式/</id>
    <published>2020-03-19T11:57:10.000Z</published>
    <updated>2020-05-06T02:10:20.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板模式优缺点"><a href="#模板模式优缺点" class="headerlink" title="模板模式优缺点"></a>模板模式优缺点</h3><p>优点:<br>使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，封装不变部分，扩展可变部分；例如你装饰房子的方法有很多种，每一种都可能给你带来不一样的体验；<br>提取公共代码，有利于后期的维护；例如每个房间功能明确；<br>行为由父类控制，子类实现；比如定义了厨房这个房间，具体厨房要怎么装修，要看你的做法；<br>缺点:<br>如果算法骨架有修改的话，则需要修改抽象类；(修改整体框架是很困难的)<br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。(这里类似于房间的装修方案)</p><a id="more"></a><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>设计模板类，也就是父类，由父类规定好框架，抽象方法以及父类的功能；<br>具体实现留给继承父类的子类进行实现；这样就实现了父类的重复使用，也就是模板；</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先定义一个模板类，它的非抽象方法需要定为 final, 因为它不希望被子类继承和改写，这个功能是父类特有的；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class House &#123;</span><br><span class="line">    // 子类要实现的方法;</span><br><span class="line">    public abstract void bathroom();</span><br><span class="line">    public abstract void bedroom();</span><br><span class="line">    public abstract void kitchen();</span><br><span class="line"></span><br><span class="line">    // 为了避免子类继承, 一般模板的方法都加上final;</span><br><span class="line">    public final void decorate() &#123;</span><br><span class="line">        // 装修浴室;</span><br><span class="line">        bathroom();</span><br><span class="line"></span><br><span class="line">        // 装修卧室;</span><br><span class="line">        bedroom();</span><br><span class="line"></span><br><span class="line">        // 装修厨房;</span><br><span class="line">        kitchen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是实现子类，这里我们实现两个装修方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class scheme1 extends House &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bathroom() &#123;</span><br><span class="line">        System.out.println(&quot;bathroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bedroom() &#123;</span><br><span class="line">        System.out.println(&quot;bedroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void kitchen() &#123;</span><br><span class="line">        System.out.println(&quot;kitchen scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class scheme1 extends House &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bathroom() &#123;</span><br><span class="line">        System.out.println(&quot;bathroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bedroom() &#123;</span><br><span class="line">        System.out.println(&quot;bedroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void kitchen() &#123;</span><br><span class="line">        System.out.println(&quot;kitchen scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是两个装修方案，接下来来看看测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class demo_house &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args) &#123;</span><br><span class="line">        House house; // 父类引用;</span><br><span class="line">        // 方案1;</span><br><span class="line">        house = new scheme1();</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">        // 方案2;</span><br><span class="line">        house = new scheme2();</span><br><span class="line">        house.decorate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bathroom scheme one!!!</span><br><span class="line">bedroom scheme one!!!</span><br><span class="line">kitchen scheme one!!!</span><br><span class="line">---------------------</span><br><span class="line">bathroom scheme two!!!</span><br><span class="line">bedroom scheme two!!!</span><br><span class="line">kitchen scheme two!!!</span><br></pre></td></tr></table></figure><p>[转载]<a href="https://zhuanlan.zhihu.com/p/40770254" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40770254</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板模式优缺点&quot;&gt;&lt;a href=&quot;#模板模式优缺点&quot; class=&quot;headerlink&quot; title=&quot;模板模式优缺点&quot;&gt;&lt;/a&gt;模板模式优缺点&lt;/h3&gt;&lt;p&gt;优点:&lt;br&gt;使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，封装不变部分，扩展可变部分；例如你装饰房子的方法有很多种，每一种都可能给你带来不一样的体验；&lt;br&gt;提取公共代码，有利于后期的维护；例如每个房间功能明确；&lt;br&gt;行为由父类控制，子类实现；比如定义了厨房这个房间，具体厨房要怎么装修，要看你的做法；&lt;br&gt;缺点:&lt;br&gt;如果算法骨架有修改的话，则需要修改抽象类；(修改整体框架是很困难的)&lt;br&gt;每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。(这里类似于房间的装修方案)&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.7hashmap多线程下成环原因</title>
    <link href="http://yoursite.com/2020/03/18/jdk1.7hashmap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%88%90%E7%8E%AF%E5%8E%9F%E5%9B%A0/"/>
    <id>http://yoursite.com/2020/03/18/jdk1.7hashmap多线程下成环原因/</id>
    <published>2020-03-18T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:26.175Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.7下hashmap的部分源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable)&#123;</span><br><span class="line">        Entry[] src=table;</span><br><span class="line">        int newCapacity=newTable.length;    </span><br><span class="line">        for(int j=0;j&lt;src.length;j++)&#123;</span><br><span class="line">            Entry&lt;K, V&gt; e=src[j];</span><br><span class="line">            if(e!=null)&#123;</span><br><span class="line">                src[j]=null;</span><br><span class="line">                do&#123;</span><br><span class="line">                    Entry&lt;K, V&gt; next=e.next;// 保存下一次循环的 Entry</span><br><span class="line">                    // 在新的 table 中求得适合插入的位置</span><br><span class="line">                    int i=indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next=newTable[i];//  如果 I 位置原来没有值，则直接插入；有值，采用链头插入法</span><br><span class="line">                    newTable[i]=e;</span><br><span class="line">                    // 轮替，下一次循环</span><br><span class="line">                    e=next;</span><br><span class="line">                &#125;while(e!=null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/aaa.png" alt></p><p>假设原来在数组 1 的下标位置有个链表，链表元素是 a-b-null，现在有两个线程同时执行这个方法，我们先来根据线程 1 的执行情况来分别分析下这三行代码：<br>e.next = newTable[i];<br>newTable 表示新的数组，newTable [i] 表示新数组下标为 i 的值，第一次循环的时候为 null，e 表示原来链表位置的头一个元素，是 a，e.next 是 b，<br>e.next = newTable [i] 的意思就是拿出 a 来，并且使 a 的后一个节点是 null;</p><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/bbb.png" alt></p><p>newTable[i] = e;<br>就是把 a 赋值给新数组下标为 1 的地方;</p><p>e = next;<br>next 的值在 while 循环一开始就有了，为：Entrynext = e.next; 在此处 next 的值就是 b，把 b 赋值给 e，接着下一轮循环。</p><p>从 b 开始下一轮循环，重复 1、2、3，注意此时 e 是 b 了，而 newTable [i] 的值已经不是空了，已经是 a 了，所以 1，2，3 行代码执行下来，b 就会插入到 a 的前面，如下图 ;</p><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/ccc.png" alt></p><p>这个就是线程 1 的插入节奏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk1.7下hashmap的部分源码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void transfer(Entry[] newTable)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Entry[] src=table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int newCapacity=newTable.length;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int j=0;j&amp;lt;src.length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Entry&amp;lt;K, V&amp;gt; e=src[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(e!=null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                src[j]=null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Entry&amp;lt;K, V&amp;gt; next=e.next;// 保存下一次循环的 Entry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    // 在新的 table 中求得适合插入的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    int i=indexFor(e.hash, newCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e.next=newTable[i];//  如果 I 位置原来没有值，则直接插入；有值，采用链头插入法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    newTable[i]=e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    // 轮替，下一次循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e=next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;while(e!=null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jar包的执行方式</title>
    <link href="http://yoursite.com/2020/03/17/jar%E5%8C%85%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/17/jar包的执行方式/</id>
    <published>2020-03-17T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:27.696Z</updated>
    
    <content type="html"><![CDATA[<p>System.getProperty(“user.home”);//当前登录用户目录<br>System.getProperty(“user.dir”);//jar包所在目录名</p><p>java -cp执行jar包的时候，可以指定外部依赖<br>java -cp aaa.jar(要执行的jar包):/data/apps/ilb/*(要执行jar包所依赖的jar文件) com.chinacache.Main(jar包运行的主类)</p><a id="more"></a><p>JDK6 支持 java -cp 后面跟通配符 ‘*’，试了一下发现还是需要注意：</p><p>错误方式（Wrong way）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  -cp aaa.jar:/data/apps/lib/*.jar com.chinacache.Main</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  -cp aaa.jar:/data/apps/ilb/ com.chinacache.Main</span><br></pre></td></tr></table></figure><p>正确方式（right way）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp aaa.jar:/data/apps/ilb/* com.chinacache.Main</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;System.getProperty(“user.home”);//当前登录用户目录&lt;br&gt;System.getProperty(“user.dir”);//jar包所在目录名&lt;/p&gt;
&lt;p&gt;java -cp执行jar包的时候，可以指定外部依赖&lt;br&gt;java -cp aaa.jar(要执行的jar包):/data/apps/ilb/*(要执行jar包所依赖的jar文件) com.chinacache.Main(jar包运行的主类)&lt;/p&gt;
    
    </summary>
    
    
      <category term="jar包" scheme="http://yoursite.com/categories/jar%E5%8C%85/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://yoursite.com/2020/03/10/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/10/String源码学习/</id>
    <published>2020-03-10T11:57:10.000Z</published>
    <updated>2020-05-14T01:31:01.897Z</updated>
    
    <content type="html"><![CDATA[<p>调用String stringValue = new String(“asdre”);时，才会调用构造方法执行 value 的赋值操作，值是来自于字符串字面量 “asdre” 这个 String 对象的。<br>比较好奇的是在调用构造之前 “asdre” 是怎么被初始化的，事实上这段字符串是写在 Java 代码里的，编译器遇到这段字符串后会将字符串字面量的内容编译到 class bytecode 二进制文件中。当虚拟机加载这个 class 文件时，这种字符串字面量会被 JVM 初始化成一个 String 对象，存储在字符串常量池中。</p><p>也就是说这个 String 对象是虚拟机进行初始化产生的，而字符串内容的来源是二进制的 class 文件，而二进制文件中的来源就是您在 java 源码文本中写入的值。</p><p>1.直接赋值（String str = “hello”）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p>2.构造方法（String str=  new String (“hello”);）: 会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过 public  String intern (); 方法进行手工入池。</p><p>ew String () 和 new String (“”) 都是申明一个新的空字符串，是空串不是 null；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用String stringValue = new String(“asdre”);时，才会调用构造方法执行 value 的赋值操作，值是来自于字符串字面量 “asdre” 这个 String 对象的。&lt;br&gt;比较好奇的是在调用构造之前 “asdre” 是怎么被初始化的，
      
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hashmap中的干扰函数</title>
    <link href="http://yoursite.com/2020/03/10/hashmap%E4%B8%AD%E7%9A%84%E5%B9%B2%E6%89%B0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/10/hashmap中的干扰函数/</id>
    <published>2020-03-10T11:57:10.000Z</published>
    <updated>2020-03-20T07:42:12.157Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null；<br>jdk1.8中hashmap的代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面代码里的 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。<br>理论上散列值是一个 int 型，如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从 -2147483648 到 2147483648。前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。<br>但问题是一个 40 亿长度的数组，内存是放不下的。你想，HashMap 扩容之前的数组初始大小才 16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算如下<br><img src="/2020/03/10/hashmap中的干扰函数/aaa.png" alt></p><p>那么这也就明白了为什么 HashMap 的数组长度是 2 的整数幂。比如以初始长度为 16 为例，16-1 = 15，15 的二进制数位 00000000 00000000 00001111。可以看出一个基数二进制最后一位必然位 1，当与一个 hash 值进行与运算时，最后一位可能是 0 也可能是 1。但偶数与一个 hash 值进行与运算最后一位必然为 0，造成有些位置永远映射不上值。<br>但是这时，又出现了一个问题，即使散列函数很松散，但只取最后几位碰撞也会很严重。这时候 hash 算法的价值就体现出来了，<br><img src="/2020/03/10/hashmap中的干扰函数/bbb.png" alt><br>hashCode 右移 16 位，正好是 32bit 的一半。与自己本身做异或操作（相同为 0，不同为 1）。就是为了混合哈希值的高位和地位，增加低位的随机性。并且混合后的值也变相保持了高位的特征。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null；&lt;br&gt;jdk1.8中hashmap的代码片段&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static final int hash(Object key) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hbase学习</title>
    <link href="http://yoursite.com/2020/03/09/Idea%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/03/09/Idea编译器使用技巧/</id>
    <published>2020-03-09T11:57:10.000Z</published>
    <updated>2020-03-12T06:07:23.491Z</updated>
    
    <content type="html"><![CDATA[<p>新版idea复制错误信息<br>windows：按着 alt 左键点击错误信息<br>mac：按着 option 左键点击错误信息</p><p>返回上次代码跳转的方向：command+alt+左右方向键</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新版idea复制错误信息&lt;br&gt;windows：按着 alt 左键点击错误信息&lt;br&gt;mac：按着 option 左键点击错误信息&lt;/p&gt;
&lt;p&gt;返回上次代码跳转的方向：command+alt+左右方向键&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="编译器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
      <category term="编译器使用技巧" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>hbase学习</title>
    <link href="http://yoursite.com/2020/03/03/hbase%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/03/hbase学习/</id>
    <published>2020-03-03T11:57:10.000Z</published>
    <updated>2020-04-09T08:08:51.336Z</updated>
    
    <content type="html"><![CDATA[<p>查看某张表全部rowkey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count &apos;表名&apos;, INTETVAL=1&lt;表示rowkey之间的间隔&gt;</span><br><span class="line">count &apos;&lt;tablename&gt;&apos;, CACHE =&gt; 1000&lt;表示rowkey之间的间隔&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>查询服务器状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure><p>查询Hbase版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version</span><br></pre></td></tr></table></figure><p>查看所有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create &lt;table&gt;, &#123;NAME =&gt; &lt;family&gt;, VERSIONS =&gt; &lt;VERSIONS&gt;&#125;</span><br><span class="line">例如：创建表 t1，有两个 family name：f1，f2，且版本数均为 2</span><br><span class="line">create &apos;t1&apos;,&#123;NAME =&gt; &apos;f1&apos;, VERSIONS =&gt; 2&#125;,&#123;NAME =&gt; &apos;f2&apos;, VERSIONS =&gt; 2&#125;</span><br><span class="line">或者 create &apos;t1&apos;, &apos;f1&apos;(默认版本是1)</span><br></pre></td></tr></table></figure><p>获得表的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe &apos;member&apos;</span><br></pre></td></tr></table></figure><p>增加一个列族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;member&apos;, &apos;id&apos;</span><br></pre></td></tr></table></figure><p>删除一个列族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;member&apos;, &#123;NAME =&gt; &apos;member_id&apos;, METHOD =&gt; &apos;delete’&#125;</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 delete 命令，我们可以删除 id 为某个值的‘info:age’字段</span><br><span class="line">delete &apos;member&apos;,&apos;debugo&apos;,&apos;info:age&apos;</span><br></pre></td></tr></table></figure><p>删除整行的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteall &apos;member&apos;,&apos;debugo&apos;</span><br></pre></td></tr></table></figure><p>使用 exists 来检查表是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists &apos;member&apos;</span><br></pre></td></tr></table></figure><p>删除表需要先将表 disable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disable &apos;member&apos;</span><br><span class="line"></span><br><span class="line">drop &apos;member&apos;</span><br></pre></td></tr></table></figure><p>创建表具有mob特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void createTable(String tableName, String columnFamily, boolean bool)&#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        Admin admin = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn = ConnectionFactory.createConnection(conf);</span><br><span class="line">            admin = conn.getAdmin();</span><br><span class="line">            //表描述器构造器</span><br><span class="line">            TableDescriptorBuilder tdb  =TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName))  ;</span><br><span class="line">            //列族描述起构造器</span><br><span class="line">            ColumnFamilyDescriptorBuilder cdb = ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(columnFamily));</span><br><span class="line">            //设置为 true，将这个列存为 MOB.</span><br><span class="line">            cdb.setMobEnabled(bool);</span><br><span class="line">            //超过阈值大小的文件，就被当成 MOB 对待。默认阈值为 100KB。</span><br><span class="line">            cdb.setMobThreshold(102400L);</span><br><span class="line">            //获得列描述器</span><br><span class="line">            ColumnFamilyDescriptor cfd = cdb.build();</span><br><span class="line"></span><br><span class="line">            //添加列族</span><br><span class="line">            tdb.setColumnFamily(cfd);</span><br><span class="line">            //获得表描述器</span><br><span class="line">            TableDescriptor td = tdb.build();</span><br><span class="line">            //创建表</span><br><span class="line">            //admin.addColumnFamily(tableName, cfd);</span><br><span class="line">            admin.createTable(td);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;Method : createTable is failed !&quot;, e);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            closeAdmin(admin, conn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看某张表全部rowkey&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;count &amp;apos;表名&amp;apos;, INTETVAL=1&amp;lt;表示rowkey之间的间隔&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;count &amp;apos;&amp;lt;tablename&amp;gt;&amp;apos;, CACHE =&amp;gt; 1000&amp;lt;表示rowkey之间的间隔&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>二零一九年终总结</title>
    <link href="http://yoursite.com/2019/12/31/%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/31/二零一九年终总结/</id>
    <published>2019-12-31T11:57:10.000Z</published>
    <updated>2019-12-25T01:58:14.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><blockquote><p>2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；<br>这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；<br>年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。</p></blockquote><a id="more"></a><p>这一年下来买了30多个专栏，想想自己还是很可怕的，因为从头看完的估计都不到一半；但是也不是完全没有收获，专栏中有的话是真的很有共鸣的，比如：越早的掌握底层知识，才能越早的享受知识的红利；所以今年一年主要学习的专栏还是都很基础的，比如数据结构，计算机组成原理，计算机网络；操作系统专栏还没看完(留到2020了，要学的专栏一直往后推，这个不是一个好习惯)。虽然要学的还有很多，但是这一年我自己感觉是进步最多的一年。虽然焦虑依然存在，但是消除焦虑的进步速度也在加快。虽然这一年也有一点收获，但是从10月份开始工作的很不舒服，甚至可以说的上是压抑；人在一种压抑中学习或者成长并不快；产生了想走的心；</p><ul><li>极客时间<br><img src="/2019/12/31/二零一九年终总结/ddd.png" alt><br><img src="/2019/12/31/二零一九年终总结/eee.jpg" alt></li><li>LeetCode<br><img src="/2019/12/31/二零一九年终总结/fff.png" alt></li><li>GitHub<br><img src="/2019/12/31/二零一九年终总结/ggg.png" alt><br>忽略了很重要的一点是今年自己搭建了博客，开始陆陆续续的写一些技术博客，虽然质量不是很高，但是贵在开始有写博客的意识了。有了持续的输出，才能有持续的进步；</li></ul><p>今年发现体重问题越来越严重了，体重一直在160上下浮动，最明显后果是买衣服不好买了，体重上来之后信心明显受到了打击(本来就丑，现在还变胖了)，三姐的话变成了真的，工作之后真的会变胖；今年意识到变胖之后，还跑了几天步，结果没坚持下来（我这人果然没有什么耐心）<br><img src="/2019/12/31/二零一九年终总结/aaa.webp" alt></p><p>感情经历依然<br><img src="/2019/12/31/二零一九年终总结/bbb.jpg" alt><br><img src="/2019/12/31/二零一九年终总结/ccc.jpg" alt></p><p>今年玩游戏不是很多了，减少到去年的一半不到，明年估计连今年的一半也不到，游戏渐渐玩的不多了，这是个好现象；</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>我就不去立什么flag，因为我知道我就是立flag也实现不了，还让自己有愧疚感（我倒是很会替自己着想啊）。虽然嘴上说不去立flag，但是心里还是有想法的。我就把想法说一下吧，能不能实现是另外一回事；想到什么就说什么了，减肥还是很有必要的，先定个小目标，先减它一斤试试，今年希望减肥成功；<br>还有就是把计算机基础课程再巩固一下，争取能看到相关知识点的时候可以联想到；LeetCode上还是要刷题的，在精不在多，在持之以恒，不再于某一天的突发奇想；今年要好好用用GitHub；最重要的一点是不要为了工作再压抑了；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；&lt;br&gt;这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；&lt;br&gt;年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
