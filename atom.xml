<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-13T03:48:19.968Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hashmap中hash方法的一些看法</title>
    <link href="http://yoursite.com/2020/07/11/hashmap%E4%B8%ADhash%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/11/hashmap中hash方法的一些看法/</id>
    <published>2020-07-11T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:19.968Z</updated>
    
    <content type="html"><![CDATA[<p>hashcode一般用 int 来表示，32 位。<br>下面两个 hashcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">只有第 32 位（从右到左）不一样;</span><br></pre></td></tr></table></figure><p>在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.</p><a id="more"></a><p>大家又知道，hashcode 对 8 取模，效果等同于 hashcode &amp; (8 - 1)。</p><p>那么，前面的 A 和 （8 - 1）相与的结果如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">结果为 7，也就是，会放进 array [7]。</span><br></pre></td></tr></table></figure><p>大家再看 B 的计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">虽然 B 的第 32 位为 1,前面的高位，全是 0。</span><br></pre></td></tr></table></figure><p>所以，问题明白了吗，我们计算出来的 hashcode，低位相同，高位不同；但是，因为和我们进行与计算的队友太过垃圾，导致我们出现了 hash 冲突。</p><h5 id="怎么来解决这个问题呢？"><a href="#怎么来解决这个问题呢？" class="headerlink" title="怎么来解决这个问题呢？"></a>怎么来解决这个问题呢？</h5><p>我们能不能把高位也参与计算呢？自然，是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hashmap 中如何优化</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">这里，其实分了 3 个步骤：</span><br><span class="line"></span><br><span class="line">&gt;&gt; 计算 hashcode，作为操作数 1</span><br><span class="line"></span><br><span class="line">&gt;&gt; h = key.hashCode()</span><br><span class="line">&gt;&gt; 将第一步的 hashcode，右移 16 位，作为操作数 2</span><br><span class="line"></span><br><span class="line">&gt;&gt; h &gt;&gt;&gt; 16</span><br><span class="line">&gt;&gt; 操作数 1 和 操作数 2 进行异或操作，得到最终的 hashcode</span><br><span class="line"></span><br><span class="line">还是拿前面的来算，</span><br></pre></td></tr></table></figure><p>0111 1111 1111 1111 1111 1111 1111 1111  ——A<br>0000 0000 0000 0000 0111 1111 1111 1111   —– A &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>这里算出来的结果是 2147450880，再去对 7 进行与运算：</p><p>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 8 -1<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  —— 0<br>这里的 A，算出来，依然在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再拿 B 来算一下：</span><br></pre></td></tr></table></figure><p>1111 1111 1111 1111 1111 1111 1111 1111  —— B<br>0000 0000 0000 0000 1111 1111 1111 1111   —– B &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>1111 1111 1111 1111 0000 0000 0000 0000    — -65536<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 7<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  ——- 0<br>最终算出来为 0，所以，应该放在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里两个虽然算出来都是array[0](只是凑巧)</span><br><span class="line"></span><br><span class="line">下边提供下源代码：</span><br></pre></td></tr></table></figure><p>public class BinaryTest {<br>    public static void main(String[] args) {<br>        int a = 0b00001111111111111111111111111011;<br>        int b = 0b10001101111111111111110111111011;</p><pre><code>    int i = tabAt(32, a);    System.out.println(&quot;index for a:&quot; + i);    i = tabAt(32, b);    System.out.println(&quot;index for b:&quot; + i);}static final int tabAt(int  arraySize, int hash) {    int h = hash;    int finalHashCode = h ^ (h &gt;&gt;&gt; 16);    int i = finalHashCode &amp; (arraySize - 1);    return i;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虽然说，我测试了几个数字，还是有些冲突，但是，你把高 16 位弄进来参与计算，总比你不弄进来计算要好吧。</span><br><span class="line"></span><br><span class="line">大家也可以看看 hashmap 中，hash 方法的注释：</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Computes key.hashCode() and spreads (XORs) higher bits of hash</li><li>to lower.  Because the table uses power-of-two masking, sets of</li><li>hashes that vary only in bits above the current mask will</li><li>always collide. (Among known examples are sets of Float keys</li><li>holding consecutive whole numbers in small tables.)  So we</li><li>apply a transform that spreads the impact of higher bits</li><li>downward. There is a tradeoff between speed, utility, and</li><li>quality of bit-spreading. Because many common sets of hashes</li><li>are already reasonably distributed (so don’t benefit from</li><li>spreading), and because we use trees to handle large sets of</li><li>collisions in bins, we just XOR some shifted bits in the</li><li>cheapest possible way to reduce systematic lossage, as well as</li><li>to incorporate impact of the highest bits that would otherwise</li><li>never be used in index calculations because of table bounds.</li><li>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">里面提到了 2 点：</span><br></pre></td></tr></table></figure></li></ul><p>So we apply a transform that spreads the impact of higher bits downward.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，我们进行了一个转换，把高位的作用利用起来。</span><br></pre></td></tr></table></figure><p>we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as<br>to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们仅仅异或了从高位移动下来的二进制位，用最经济的方式，削减系统性能损失，同样，因为数组大小的限制，导致高位在索引计算中一直用不到，我们通过这种转换将其利用起来。</span><br><span class="line"></span><br><span class="line">#### ConcurrentHashMap 如何优化</span><br><span class="line">在 concurrentHashMap 中，其主要是：</span><br></pre></td></tr></table></figure><p>final V putVal(K key, V value, boolean onlyIfAbsent) {<br>    if (key == null || value == null) throw new NullPointerException();<br>    int hash = spread(key.hashCode());</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里主要是使用 spread 方法来计算 hash 值：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家如果要仔细观察每一步的二进制，可以使用下面的 demo：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    // 1<br>    String s = Integer.toBinaryString(h);<br>    System.out.println(“h:” + s);</p><pre><code>// 2String lower16Bits = Integer.toBinaryString(h &gt;&gt;&gt; 16);System.out.println(&quot;lower16Bits:&quot; + lower16Bits);// 3int temp = h ^ (h &gt;&gt;&gt; 16);System.out.println(&quot;h ^ (h &gt;&gt;&gt; 16):&quot; + Integer.toBinaryString(temp));// 4int result = (temp) &amp; HASH_BITS;System.out.println(&quot;final:&quot; + Integer.toBinaryString(result));return result;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里和 HashMap 相比，多了点东西，也就是多出来了：</span><br></pre></td></tr></table></figure><p>&amp; HASH_BITS;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 (h ^ (h &gt;&gt;&gt; 16)) 计算出来的 hashcode，可能是负数。这里，和 HASH_BITS 进行了相与：</span><br></pre></td></tr></table></figure><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash<br>1111 1111 1111 1111 1111 1111 1111 1111   假设计算出来的hashcode为负数，因为第32位为1<br>0111 1111 1111 1111 1111 1111 1111 1111       0x7fffffff<br>    进行相与<br>0111 …………………………….    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​这里，第 32 位，因为 0x7fffffff 的第 32 位，总为 0，所以相与后的结果，第 32 位也总为 0 ，所以，这样的话，hashcode 就总是正数了，不会是负数。</span><br><span class="line"></span><br><span class="line">***concurrentHashMap 中，node 的 hashcode，为啥不能是负数***</span><br><span class="line">当 hashcode 为正数时，表示该哈希桶为正常的链表结构。</span><br><span class="line">当 hashcode 为负数时，有几种情况：</span><br><span class="line"></span><br><span class="line">***ForwardingNode***</span><br><span class="line">此时，其 hash 值为：</span><br></pre></td></tr></table></figure><p>static final int MOVED     = -1; // hash for forwarding nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当节点为 ForwardingNode 类型时（表示哈希表在扩容进行中，该哈希桶已经被迁移到了新的临时 hash 表，此时，要 get 的话，需要去临时 hash 表查找；要 put 的话，是不行的，会帮助扩容）</span><br><span class="line"></span><br><span class="line">***TreeBin***</span><br></pre></td></tr></table></figure><p>static final int TREEBIN   = -2; // hash for roots of trees</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示，该哈希桶，已经转了红黑树。</span><br><span class="line"></span><br><span class="line">***扩容时的位运算***</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Returns the stamp bits for resizing a table of size n.</li><li>Must be negative when shifted left by RESIZE_STAMP_SHIFT.</li><li>/<br>static final int resizeStamp(int n) {<br>   return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这里，假设，n 为 4，即，hashmap 中数组容量为 4.</span><br><span class="line"></span><br><span class="line">+ 下面这句，求 4 的二进制表示中，前面有多少个 0.</span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(n)</span><br><span class="line"></span><br><span class="line">表示为 32 位后，如下</span><br><span class="line"></span><br><span class="line">0000 0000 0000 0000, 0000 0000 0000 0100</span><br><span class="line"></span><br><span class="line">所以，前面有 29 个 0，即，这里的结果为 29.</span><br><span class="line"></span><br><span class="line">+ (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)</span><br><span class="line"></span><br><span class="line">这一句呢，其中 RESIZE_STAMP_BITS 是个常量，为 16. 相当于，把 1 向左移动 15 位。</span><br><span class="line"></span><br><span class="line">二进制为：</span><br></pre></td></tr></table></figure></li></ul><p>1000 0000 0000 0000   – 1 &lt;&lt; 15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 0000 0000 0001 1101   – 29<br>0000 0000 0000 0000 1000 0000 0000 0000   – 1 &lt;&lt; 15<br>进行或运算<br>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以，最终结果是，</span><br><span class="line">![](hashmap中hash方法的一些看法/aaa.png)</span><br><span class="line"></span><br><span class="line">这个数，换算为 10 进制，为 32972，是个正数。</span><br><span class="line">这个数，有啥用呢？</span><br><span class="line">在 addCount 函数中，当整个哈希表的键值对数量，超过 sizeCtl 时（一般为 0.75 * 数组长度），就会触发扩容。</span><br></pre></td></tr></table></figure><p>java.util.concurrent.ConcurrentHashMap#addCount</p><p>int sc =  sizeCtl;<br>boolean bSumExteedSizeControl = newBaseCount &gt;= (long) sc;<br>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1 处，如果扩容条件满足</span><br><span class="line"></span><br><span class="line">+ 2 处，如果 sc 小于 0，这个 sc 是啥，就是前面说的 sizeCtl，此时应该是等于：0.75 * 数组长度，不可能为负数</span><br><span class="line"></span><br><span class="line">+ 3 处，将 sc（此时为正数），cas 修改为：</span><br></pre></td></tr></table></figure><p>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个数有点意思了，rs 就是前面我们的 resizeStamp 得到的结果。</span><br><span class="line"></span><br><span class="line">按照前面的 demo，我们拿到的结果为：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为</span><br></pre></td></tr></table></figure><p>private static int RESIZE_STAMP_BITS = 16;<br>private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;<br>所以，RESIZE_STAMP_SHIFT 为 16.</p><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。<br>1000 0000 0001 1101 0000 0000 0000 0000 —   左移16位，即   rs &lt;&lt; RESIZE_STAMP_SHIFT<br>1000 0000 0001 1101 0000 0000 0000 0010    – (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)<br>最终，这个数，第一位是 1，说明了，这个数，肯定是负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大家如果看过其他人写的资料，也就知道，当 sizeCtl 为负数时，表示正在扩容。</span><br><span class="line"></span><br><span class="line">所以，这里</span><br></pre></td></tr></table></figure><p>if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这句话就是，如果当前线程成功地，利用 cas，将 sizeCtl 从正数，变成负数，就可以进行扩容。</span><br><span class="line"></span><br><span class="line">扩容时，其他线程怎么执行</span><br></pre></td></tr></table></figure><p>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        // 2.1<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        // 2.2<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><pre><code>此时，因为上面的线程触发了扩容，sc 已经变成了负数了，此时，新的线程进来，会判断 2 处。2 处是满足的，会进入 2.1 处判断，这里的部分条件看不懂，大概是：扩容已经结束，就不再执行，直接 break否则，进入 2.2 处，辅助扩容，同时，把 sc 变成 sc + 1，增加扩容线程数。[参考链接]http://iambigboss.top/post/73353_1_1.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashcode一般用 int 来表示，32 位。&lt;br&gt;下面两个 hashcode:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0111 1111 1111 1111 1111 1111 1111 1111  ------A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1111  ------B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;只有第 32 位（从右到左）不一样;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2020/07/10/ConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2020/07/10/ConcurrentHashMap和HashMap的初始化思考/</id>
    <published>2020-07-10T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:21.461Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://yoursite.com/2020/07/09/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/09/ThreadLocal详解/</id>
    <published>2020-07-09T11:57:10.000Z</published>
    <updated>2020-07-09T11:14:41.873Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/07/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/07/ConcurrentHashMap详解/</id>
    <published>2020-07-07T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:16.876Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>ConcurrentHashMap 是 HashMap 的线程安全版本；</li><li>不允许 [key,value] 为 null;</li><li>比 Hashtable 锁粒度更细；</li><li>采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；</li><li>负载因子 0.75;</li><li>默认初始化容量 16;</li><li>put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；</li><li>put 时出现 hash 冲突，则采用 synchronized;</li><li>查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；</li><li>ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;</li></ul><ul><li>什么时候会触发扩容</li></ul><ol><li>链表转换为红黑树时 (链表节点个数达到 8 个可能会转换为红黑树)。如果转换时 map 长度小于 64 则直接扩容一倍，不转化为红黑树。如果此时 map 长度大于 64，则不会扩容，直接进行链表转红黑树的操作。(即链表长度大于等于8且map的长度大于64才会将链表转换为红黑树)</li><li>map 中总节点数大于阈值 (即大于 map 长度的 0.75 倍) 时会进行扩容。</li></ol><ul><li>如何扩容</li></ul><ol><li>创建一个新的 map，是原先 map 的两倍。注意此过程是单线程创建的；</li><li>复制旧的 map 到新的 map 中。注意此过程是多线程并发完成。（将 map 按照线程数量平均划分成多个相等区域，每个线程负责一块区域的复制任务）；</li></ol><h4 id="成员变量解析"><a href="#成员变量解析" class="headerlink" title="成员变量解析"></a>成员变量解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile Node&lt;K,V&gt;[] table</span><br></pre></td></tr></table></figure><p>默认为 null，初始化发生在第一次插入操作，默认大小为 16 的数组，用来存储 Node 节点数据，扩容时大小总是 2 的幂次方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable</span><br></pre></td></tr></table></figure><p>默认为 null，扩容时新生成的数组，其大小为原数组的两倍。</p><ul><li>ForwardingNode<br>一个特殊的 Node 节点，hash 值为 - 1，其中存储 nextTable 的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MOVED = -1</span><br></pre></td></tr></table></figure><p>扩容节点的 hash 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl</span><br></pre></td></tr></table></figure><p>默认为 0，用来控制 table 的初始化和扩容操作，具体应用在后续会体现出来。<br>-1 代表 table 正在初始化<br>-N 表示有 N-1 个线程正在进行扩容操作<br>其余情况：<br>(1) 如果 table 未初始化，表示 table 需要初始化的大小。<br>(2) 如果 table 初始化完成，表示 table 的容量，默认是 table 大小的 0.75 倍，居然用这个公式算 0.75（n - (n &gt;&gt;&gt; 2)）—-(即n-n/4)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe U</span><br></pre></td></tr></table></figure><p>在 ConcurrentHashMap 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层 CMPXCHG 指令实现。CAS (V,O,N) 核心思想为： 若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用 CAS 是通过 sun.misc.Unsafe 类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 java 中的 “指针”。该成员变量的获取是在静态代码块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">.......</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-类相关方法"><a href="#Unsafe-类相关方法" class="headerlink" title="Unsafe 类相关方法"></a>Unsafe 类相关方法</h4><p>ConcurrentHashMap 废弃了分段锁，改用 CAS + Synchronized + valatile 保证线程安全，而 Java 主要通过 Unsafe 类实现 CAS，因此源代码大量使用了 Unsafe 类的三个 CAS 方法，如下：</p><ul><li>compareAndSwapObject(Object o, long offset, Object expected, Object x);</li><li>compareAndSwapInt(Object o, long offset, int expected, int x);</li><li>compareAndSwapLong(Object o, long offset, long expected, long x);<br>这些方法非常相似，区别只是参数 expected 和 x 的类型。它们表达的意思是，如果对象 o 在 offset 位置的值是 expected，则把值修改为 x，否则不修改。其中 o 是给定的对象，offset 表示对象内存偏移量，expected 表示当前位置的期望值，x 表示修改后的新值。<br>此外，ConcurrentHashMap 封装了三个数组元素访问方法，底层依然是调用 Unsafe 类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//从主存获取tab[i]，避免读到脏数据</span><br><span class="line">static final  Node tabAt(Node[] tab, int i) &#123;</span><br><span class="line">    return (Node)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值从c改成v</span><br><span class="line">static final  boolean casTabAt(Node[] tab, int i,</span><br><span class="line">                                    Node c, Node v) &#123;</span><br><span class="line">    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值v写到主存</span><br><span class="line">static final  void setTabAt(Node[] tab, int i, Node v) &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>带有并行度(concurrencyLevel)的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">            initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">        //initialCapacity这是想存储的容量，size类似初始化的容量</span><br><span class="line">        long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method" target="_blank" rel="noopener">https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//onlyIfAbsent表示key不存在才插入，存在则不更新</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap-中，是怎么去初始化底层数组的"><a href="#ConcurrentHashMap-中，是怎么去初始化底层数组的" class="headerlink" title="ConcurrentHashMap 中，是怎么去初始化底层数组的"></a>ConcurrentHashMap 中，是怎么去初始化底层数组的</h4><p>在我们用无参构造函数，去 new 一个 ConcurrentHashMap 时，此时还不会去创建底层数组，这个是一个小优化。什么时候创建数组呢，是在我们第一次去 put 的时候。<br>put 的时候，会调用 putVal。</p><p>其中，putVal 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">     // 1</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">         // 2</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br></pre></td></tr></table></figure><ul><li>1 处，把 field table，赋值给局部变量 tab</li><li>2 处，如果 tab 为 null，则进行 initTable 初始化</li></ul><p><strong><em>这个 2 处，在多线程 put 的时候，是可能多个线程同时进来的。有并发问题。</em></strong></p><p>我们接下来，看看 initTable 是怎么解决这个问题的，毕竟，我们 new 数组，只 new 一次即可，new 那么多次，没用，对性能有损耗。所以，这里面肯定会多线程争夺初始化权利的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl;</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line">    */</span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab;</span><br><span class="line">     int sc;</span><br><span class="line">     </span><br><span class="line">     // 0</span><br><span class="line">       while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">         // 1</span><br><span class="line">           if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); // lost initialization race; just spin</span><br><span class="line">         // 2</span><br><span class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 // 3</span><br><span class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                     // 4</span><br><span class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                 // 5</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">             </span><br><span class="line">           &#125;// end if</span><br><span class="line">         </span><br><span class="line">       &#125;// end while</span><br><span class="line">       return tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，这里把 sizeCtl，赋值给局部变量 sc。这里的 sizeCtl 是一个很重要的 field，当我们 new 完之后，默认这个字段，要么为 0，要么为准备创建的底层数组的长度。<br>这里去判断是否小于 0，那肯定不满足，小于 0，会是什么意思？当某个线程，抢到了这个 initTable 中的底层数组的创建权利时，就会把 sizeCtl 改为 -1。<br>所以，这里的意思是，看看是否已经有其他线程在初始化了，如果已经有了，则直接调用：<br>Thread.yield();<br>这个方法的意思是，暗示操作系统，自己准备放弃 cpu；但操作系统，自有它自己的线程调度规则，所以，这个方法可能没什么效果；我们业务代码，这里一般可以修改为 Thread.sleep。<br>这个方法调用完成后，后续也没有其他代码，所以会直接跳转到循环开始处（0 处代码），判断 table 是否初始化 ok 了，如果没有 ok，则会继续进来。</p></li><li><p>2 处，使用 cas，如果此时，sizeCtl 的值等于 sc 的值，就修改 sizeCtl 为 -1；如果成功，则返回 true，进入 3 处<br>否则，会跳转到 0 处，继续循环。</p></li><li><p>3 处，虽然抢到了控制权，但是这里还是要再判断一下，不然可能出现重复初始化，即，不加这一行，4 处的代码，会被重复执行</p></li><li><p>4 处开始，这里去执行真正的初始化逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">// 1</span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">// 2</span><br><span class="line">table = tab = nt;</span><br><span class="line">sc = n - (n &gt;&gt;&gt; 2);</span><br></pre></td></tr></table></figure></li></ul><p>这里的 1 处，new 数组；2 处，赋值给 field：table；此时，因为 table 这个 field 是 volatile 修饰的，所以其他线程会马上感知到。0 处代码就不会为 true 了，就不会继续循环了。</p><ul><li>5 处，修改 sizeCtl 为正数。</li></ul><p>这里说下，为啥要加 3 处的那个判断。</p><p>现在，假设线程 A，在初始化完成后，走到了 5 处，修改了 sizeCtl 为正数；而线程 B，刚好执行 1 处代码：</p><p>// 1<br>if ((sc = sizeCtl) &lt; 0)<br>那肯定，1 处就不满足了；然后就会进到 2 处，cas 修改成功，进行初始化。没有 3 处判断的话，就会重复初始化。<br>[参考链接]<a href="http://iambigboss.top/post/73849_1_1.html" target="_blank" rel="noopener">http://iambigboss.top/post/73849_1_1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap 是 HashMap 的线程安全版本；&lt;/li&gt;
&lt;li&gt;不允许 [key,value] 为 
      
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务</title>
    <link href="http://yoursite.com/2020/07/06/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/06/quartz定时任务/</id>
    <published>2020-07-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:36:45.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Quartz-API-的关键接口是："><a href="#Quartz-API-的关键接口是：" class="headerlink" title="Quartz API 的关键接口是："></a>Quartz API 的关键接口是：</h4><ul><li>Scheduler - 与调度程序交互的主要 API。</li><li>Job - 由希望由调度程序执行的组件实现的接口。</li><li>JobDetail - 用于定义作业的实例。</li><li>Trigger（即触发器） - 定义执行给定作业的计划的组件。</li><li>JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。</li><li>TriggerBuilder - 用于定义 / 构建触发器实例。</li></ul><a id="more"></a><ul><li><p>定时任务类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void run() throws SchedulerException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;journal&quot;, journalService);//可以保存到JobExecutionContext中</span><br><span class="line">        SchedulerFactory schedFact = new StdSchedulerFactory();</span><br><span class="line">        Scheduler sched = schedFact.getScheduler();</span><br><span class="line">        sched.start();</span><br><span class="line"></span><br><span class="line">        JobDetail job = newJob(SimpleTestJob.class)</span><br><span class="line">                .withIdentity(&quot;myJob&quot;, &quot;group&quot;)</span><br><span class="line">                .usingJobData(new JobDataMap(map))</span><br><span class="line">                .build();</span><br><span class="line">        Trigger trigger = newTrigger()</span><br><span class="line">                .withIdentity(&quot;myTrigger&quot;, &quot;group&quot;)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(simpleSchedule()</span><br><span class="line">                .withIntervalInMinutes(5)//设置定时任务间隔时间</span><br><span class="line">                .repeatForever())</span><br><span class="line">                .build();</span><br><span class="line">        sched.scheduleJob(job, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体执行任务的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTestJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; jobParams = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        for (String string : jobParams.keySet()) &#123;</span><br><span class="line">            Object obj = jobParams.get(string);</span><br><span class="line">            journalService = (JournalService) obj;</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">        String format = dateFormat.format(new Date());</span><br><span class="line">        System.out.println(&quot;----------------------- &quot; + format + &quot; -------------------------&quot;);</span><br><span class="line">        List&lt;Journal&gt; journalList = journalService.selectByOperateDate(format);</span><br><span class="line">        for (Journal journal : journalList) &#123;</span><br><span class="line">            String str = dateFormat.format(journal.getOperateDate());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Quartz-API-的关键接口是：&quot;&gt;&lt;a href=&quot;#Quartz-API-的关键接口是：&quot; class=&quot;headerlink&quot; title=&quot;Quartz API 的关键接口是：&quot;&gt;&lt;/a&gt;Quartz API 的关键接口是：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Scheduler - 与调度程序交互的主要 API。&lt;/li&gt;
&lt;li&gt;Job - 由希望由调度程序执行的组件实现的接口。&lt;/li&gt;
&lt;li&gt;JobDetail - 用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;Trigger（即触发器） - 定义执行给定作业的计划的组件。&lt;/li&gt;
&lt;li&gt;JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;TriggerBuilder - 用于定义 / 构建触发器实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="quartz" scheme="http://yoursite.com/categories/quartz/"/>
    
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>post请求url中https报错问题</title>
    <link href="http://yoursite.com/2020/07/05/post%E8%AF%B7%E6%B1%82url%E4%B8%ADhttps%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/05/post请求url中https报错问题/</id>
    <published>2020-07-05T11:57:10.000Z</published>
    <updated>2020-07-06T09:30:20.093Z</updated>
    
    <content type="html"><![CDATA[<ul><li>异常日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException:</span><br><span class="line">    Caused by: java.security.cert.CertificateException: No subject alternative names present</span><br><span class="line">        at sun.security.util.HostnameChecker.matchIP(Unknown Source)</span><br><span class="line">        at sun.security.util.HostnameChecker.match(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SslHandshakeExc_NsanPresent&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">URL url = new URL(&quot;https://192.168.2.222:8443/wbsystem/login.jsp&quot;);</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sc.init(null, trustAllCerts, null);</span><br><span class="line">HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line"> </span><br><span class="line">HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">conn.setHostnameVerifier(new Servlet_test().new TrustAnyHostnameVerifier());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 定制Trust</span><br><span class="line">static TrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; &#125;;</span><br><span class="line"> </span><br><span class="line">// 定制Verifier</span><br><span class="line">public class TrustAnyHostnameVerifier implements HostnameVerifier &#123;</span><br><span class="line"></span><br><span class="line">public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;异常日志&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;javax.net.ssl.SSLHandshakeException:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Caused by: java.security.cert.CertificateException: No subject alternative names present&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.matchIP(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.match(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http请求" scheme="http://yoursite.com/categories/http%E8%AF%B7%E6%B1%82/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>java中变量初始化</title>
    <link href="http://yoursite.com/2020/07/04/java%E4%B8%AD%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/04/java中变量初始化/</id>
    <published>2020-07-04T11:57:10.000Z</published>
    <updated>2020-07-06T09:48:55.654Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的笔记，今天放到自己的博客中；</p><a id="more"></a><p>1.对于类的成员变量，不管程序有没有显式的进行初始化，Java虚拟机都会先自动给它初始化为默认值；<br>默认值如下：<br>boolean  false<br>char     ‘\u0000’<br>byte     0<br>short    0<br>int      0<br>long     0<br>float    0.0f<br>double   0.0d</p><p>2.局部变量声明之后，Java虚拟机就不会自动给他初始化为默认值，因此局部变量使用之前必须进行显示的初始化。<br>但是需要声明的是：对于只负责接收一个表达式的值的局部变量可以不初始化，参与运算和直接输出等其他的情况的局部变量需要进行初始化</p><p>通过下面这个测试可以看到JVM对哪些数据初始化，哪写数据不初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestStatic &#123;</span><br><span class="line">    static int x; //类的成员变量，JVM负责初始化</span><br><span class="line">    static int method() &#123;</span><br><span class="line">        int y=0;  //此处必须自己初始化，它不属于类成员变量，是个method的局部变量，JVM不负责初始化</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestStatic as=new TestStatic();</span><br><span class="line">        int z=0;  //此处必须自己初始化，它不属于类成员变量，是个主函数里的局部变量，JVM不负责初始化</span><br><span class="line">        int aa=3; //此处aa参与了运算，所以必须初始化</span><br><span class="line">        aa=aa+2;</span><br><span class="line">        int a=1,b=2,max; //max只是负责接收表达式的值，不需要初始化</span><br><span class="line">        max=a&gt;b?2:1; </span><br><span class="line">        System.out.println(max); //1</span><br><span class="line">        System.out.println(aa); //5</span><br><span class="line">        System.out.println(&quot;z=&quot;+z); //z=0</span><br><span class="line">        System.out.println(&quot;x=&quot;+as.x); //x=0  </span><br><span class="line">        System.out.println(&quot;y=&quot;+as.method()); //y=0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结为一句话便是：类里定义的数据成员称为属性，属性可不赋初值，若不赋初值则JAVA会按上表为其添加默认值；方法里定义的数据成员称为变量，变量在参与运算之前必须赋初值。</p></blockquote><p>[参考链接]<a href="http://www.jb51.net/article/90743.htm" target="_blank" rel="noopener">http://www.jb51.net/article/90743.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前的笔记，今天放到自己的博客中；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java是按值传递还是按引用传递</title>
    <link href="http://yoursite.com/2020/07/03/Java%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/07/03/Java是按值传递还是按引用传递/</id>
    <published>2020-07-03T11:57:10.000Z</published>
    <updated>2020-07-03T08:16:15.263Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在开始之前，我们先理解按值传递、按引用传递的概念。</li></ul><p>1、什么是值传递？<br>指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。</p><p>2、什么是引用传递<br>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><a id="more"></a><p>明确地说，java都是按值传递的！java的世界里，都是按值传递。其实按值、按引用都只是个概念，关键是我们如何去理解java传参的本质。</p><p>下面就结合一个例子来说，有些情况下，所传参数的值，是个“引用”，这一点容易让人产生困惑。</p><p>请看下面的例子<br>首先有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog = new Dog(&quot;Rover&quot;);</span><br><span class="line">foo(myDog);</span><br></pre></td></tr></table></figure><p>这时，你传给了foo函数一个参数，这个参数值，是个引用，也就是Rover这只dog的内存地址（这只是粗略的说明，因为在java中，这个地址并非是真正的地址）<br>假设这时候Rover的地址是42，那么，我们就是传了42这个地址给foo方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Dog someDog) &#123;</span><br><span class="line">    someDog.setName(&quot;Max&quot;);     // AAA</span><br><span class="line">    someDog = new Dog(&quot;Fifi&quot;);  // BBB</span><br><span class="line">    someDog.setName(&quot;Rowlf&quot;);   // CCC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步解析foo方法</p><p>1.参数 someDog的值是一个地址（42）</p><p>2.在AAA这一行：<br>someDog，也就是函数外声明的myDog，name从Rover被改成了Max</p><p>3.在BBB这一行：<br>这就是关键的地方了，又new了一只dog，new 意味着又在新的地址空间放上了一只Dog，我们假设其地址是74。这时，someDog的值，会从42变成了74</p><p>4.在CCC这一行：<br>这时候的修改，是对内存地址为74的那只狗的修改，而非原先的42</p><p>从这个例子，我们可以看到，foo方法的参数someDog，它是一个值，而非引用。如果它是引用，那么在foo方法内部的修改（包括BBB、CCC这两行），都应该会对42地址空间的dog产生影响，也就是方法外的参数，mydog也会指向新的地址空间。</p><p>不细究概念了，再总结下Java初学者容易犯错的地方：<br>假如你想像例子一样，传递一个对象到一个方法中，并由该方法修改对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Object();</span><br><span class="line">foo(a);//在方法内部修改a的属性值</span><br><span class="line">return a;//希望此时的a已经是修改后的值</span><br></pre></td></tr></table></figure><p>要切记，这个Objct一定要在调用方法前，就初始化好（new一个），然后再作为参数传进去，并且在方法中不能再初始化这个参数。这样，在方法中对该参数的修改，才会有效。</p><p>[stackoverflow链接]<br><a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在开始之前，我们先理解按值传递、按引用传递的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、什么是值传递？&lt;br&gt;指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。&lt;/p&gt;
&lt;p&gt;2、什么是引用传递&lt;br&gt;指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java时间转换</title>
    <link href="http://yoursite.com/2020/06/30/Java%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/Java时间转换/</id>
    <published>2020-06-30T11:57:10.000Z</published>
    <updated>2020-07-09T06:47:12.987Z</updated>
    
    <content type="html"><![CDATA[<ul><li>时间字符串和时间转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 把时间转换为字符串</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">Date date = new Date(136464513123L);</span><br><span class="line">String string = dateFormat.format(date);</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">// 把字符串转化为时间</span><br><span class="line">String string = &quot;2018-07-19&quot;;</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);// 这里要与时间字符串的格式一样即可，否则报错</span><br><span class="line">Date date = dateFormat.parse(string);</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//转换成时间格式12小时制</span><br><span class="line">SimpleDateFormat 12 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">//转换成时间格式24小时制</span><br><span class="line">SimpleDateFormat 24 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">12小时制与24小时制制需要把HH变换大小写就可以了</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//默认输出格式</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date);//Fri Oct 27 16:56:37 CST 2017</span><br><span class="line">//日期格式化显示，首先定义格式</span><br><span class="line">SimpleDateFormat sdf1=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//显示20171027格式</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//显示2017-10-27格式</span><br><span class="line">SimpleDateFormat sdf3=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//显示2017-10-27 10:00:00格式</span><br><span class="line">SimpleDateFormat sdf4=new SimpleDateFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;);//显示2017年10月27日10时00分00秒格式</span><br><span class="line">//将格式应用于日期</span><br><span class="line">System.out.println(sdf1.format(date));//20171027</span><br><span class="line">System.out.println(sdf2.format(date));//2017-10-27</span><br><span class="line">System.out.println(sdf3.format(date));//2017-10-27 17:11:13</span><br><span class="line">System.out.println(sdf4.format(date));//2017年10月27日17时11分13秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;时间字符串和时间转换&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 把时间转换为字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = new Date(136464513123L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = dateFormat.format(date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--------------------------------------------------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 把字符串转化为时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = &amp;quot;2018-07-19&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat (&amp;quot;yyyy-MM-dd&amp;quot;);// 这里要与时间字符串的格式一样即可，否则报错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = dateFormat.parse(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转换成时间格式12小时制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SimpleDateFormat 12 = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转换成时间格式24小时制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SimpleDateFormat 24 = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12小时制与24小时制制需要把HH变换大小写就可以了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2020/06/12/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/12/HashMap详解/</id>
    <published>2020-06-12T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:23.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hash-计算原理"><a href="#hash-计算原理" class="headerlink" title="hash()计算原理"></a>hash()计算原理</h4><p>前面 put 方法中说到，需要先把当前 key 进行哈希处理，我们看下这个方法是怎么实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，会先判断 key 是否为空，若为空则返回 0。这也说明了 hashMap 是支持 key 传 null 的。若非空，则先计算 key 的 hashCode 值，赋值给 h，然后把 h 右移 16 位，并与原来的 h 进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>我们知道，hashCode () 方法继承自父类 Object，它返回的是一个 int 类型的数值，可以保证同一个应用单次执行的每次调用，返回结果都是相同的（这个说明可以在 hashCode 源码上找到），这就保证了 hash 的确定性。在此基础上，再进行某些固定的运算，肯定结果也是可以确定的。</p><p>我随便运行一段程序，把它的 hashCode 的二进制打印出来，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    int hash = o.hashCode();</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">    System.out.println(Integer.toBinaryString(hash));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//1836019240</span><br><span class="line">//1101101011011110110111000101000</span><br></pre></td></tr></table></figure><p>然后，进行 (h = key.hashCode ()) ^ (h &gt;&gt;&gt; 16) 这一段运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//h原来的值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//无符号右移16位，其实相当于把低位16位舍去，只保留高16位</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">//然后高16位和原 h进行异或运算</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">^</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">=</span><br><span class="line">0110 1101 0110 1111 0000 0011 0100 0111</span><br></pre></td></tr></table></figure><p>可以看到，其实相当于，我们把高 16 位值和当前 h 的低 16 位进行了混合，这样可以尽量保留高 16 位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p><strong>(n-1) &amp; hash 作用</strong><br>//②<br>//这是 put 方法中用来根据hash()值寻找在数组中的下标的逻辑，<br>//n为数组长度， hash为调用 hash()方法混合处理之后的hash值。<br>i = (n - 1) &amp; hash<br>我们知道，如果给定某个数值，去找它在某个数组中的下标位置时，直接用模运算就可以了（假设数组值从 0 开始递增）。如，我找 14 在数组长度为 16 的数组中的下标，即为 14 % 16，等于 14 。 18 的位置即为 18%16，等于 2。</p><p>而②中，就是取模运算的位运算形式。以 18%16 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//18的二进制</span><br><span class="line">0001 0010</span><br><span class="line">//16 -1 即 15的二进制</span><br><span class="line">0000 1111</span><br><span class="line">//与运算之后的结果为</span><br><span class="line">0000 0010</span><br><span class="line">// 可以看到，上边的结果转化为十进制就是 2 。</span><br><span class="line">//其实我们会发现一个规律，因为n是2的n次幂，因此它的二进制表现形式肯定是类似于</span><br><span class="line">0001 0000</span><br><span class="line">//这样的形式，只有一个位是1，其他位都是0。而它减 1 之后的形式就是类似于</span><br><span class="line">0000 1111 </span><br><span class="line">//这样的形式，高位都是0，低位都是1，因此它和任意值进行与运算，结果值肯定在这个区间内</span><br><span class="line">0000 0000  ~  0000 1111</span><br><span class="line">//也就是0到15之间，（以n为16为例）</span><br><span class="line">//因此，这个运算就可以实现取模运算，而且位运算还有个好处，就是速度比较快。</span><br></pre></td></tr></table></figure><p><strong>为什么高低位异或运算可以减少哈希碰撞</strong></p><p>我们想象一下，假如用 key 原来的 hashCode 值，直接和 (n-1) 进行与运算来求数组下标，而不进行高低位混合运算，会产生什么样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//例如我有另外一个h2，和原来的 h相比较，高16位有很大的不同，但是低16位相似度很高，甚至相同的话。</span><br><span class="line">//原h值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//另外一个h2值</span><br><span class="line">0100 0101 1110 1011 0110 0110 0010 1000</span><br><span class="line">// n -1 ,即 15 的二进制</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">//可以发现 h2 和 h 的高位不相同，但是低位相似度非常高。</span><br><span class="line">//他们分别和 n -1 进行与运算时，得到的结果却是相同的。（此处n假设为16）</span><br><span class="line">//因为 n-1 的高16位都是0，不管 h 的高 16 位是什么，与运算之后，都不影响最终结果，高位一定全是 0</span><br><span class="line">//因此，哈希碰撞的概率就大大增加了，并且 h 的高16 位特征全都丢失了。</span><br></pre></td></tr></table></figure><p>有同学可能就会有疑问了，我进行高低 16 位混合运算，是可以的，这样可以保证尽量减少高区位的特征。那么，为什么选择用异或运算呢，我用与、或、非运算不行吗？</p><p>这是有一定的道理的。我们看一个表格，就能明白了。</p><ul><li><p>与运算，0和1的比例3：1<br>0 1 0 1<br>&amp; 1 0 1 0<br>0 0 0 1</p></li><li><p>或运算，0和1的比例1：3<br>0 1 0 1<br>| 1 0 1 0<br>1 1 0 1</p></li><li><p>异或运算，0和1的比例1：1<br>0 1 0 1<br>^ 1 0 0 1<br>1 1 0 0</p></li></ul><p>可以看到两个值进行与运算，结果会趋向于 0；或运算，结果会趋向于 1；而只有异或运算，0 和 1 的比例可以达到 1:1 的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</p><p>所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了。</p><p>以上，就是为什么要对一个 hash 值进行高低位混合，并且选择异或运算来混合的原因。</p><h4 id="tableSizeFor-源码："><a href="#tableSizeFor-源码：" class="headerlink" title="tableSizeFor()源码："></a>tableSizeFor()源码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">/**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> */</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法被调用的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">   </span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 都是 2 的幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂（initialCapacity 如果就是 2 的幂，则返回的还是这个数）。</p><h5 id="下面分析这个算法："><a href="#下面分析这个算法：" class="headerlink" title="下面分析这个算法："></a>下面分析这个算法：</h5><p>首先，为什么要对 cap 做减 1 操作。int n = cap - 1;<br>这是为了防止，cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 又没有执行这个减 1 操作，则执行完后面的几条无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。</p><h5 id="下面看看这几个无符号右移操作："><a href="#下面看看这几个无符号右移操作：" class="headerlink" title="下面看看这几个无符号右移操作："></a>下面看看这几个无符号右移操作：</h5><p>如果 n 这时为 0 了（经过了 cap-1 之后），则经过后面的几次无符号右移依然是 0，最后返回的 capacity 是 1（最后有个 n+1 的操作）。<br>这里只讨论 n 不等于 0 的情况。</p><h6 id="第一次右移"><a href="#第一次右移" class="headerlink" title="第一次右移"></a>第一次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 1;</span><br></pre></td></tr></table></figure><p>由于 n 不等于 0，则 n 的二进制表示中总会有一 bit 为 1，这时考虑最高位的 1。通过无符号右移 1 位，则将最高位的 1 右移了 1 位，再做或操作，使得 n 的二进制表示中与最高位的 1 紧邻的右边一位也为 1，如 000011xxxxxx。</p><h6 id="第二次右移"><a href="#第二次右移" class="headerlink" title="第二次右移"></a>第二次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 2;</span><br></pre></td></tr></table></figure><p>注意，这个 n 已经经过了 n |= n &gt;&gt;&gt; 1; 操作。假设此时 n 为 000011xxxxxx ，则 n 无符号右移两位，会将最高位两个连续的 1 右移两位，然后再与原来的 n 做或操作，这样 n 的二进制表示的高位中会有 4 个连续的 1。如 00001111xxxxxx 。</p><h6 id="第三次右移"><a href="#第三次右移" class="headerlink" title="第三次右移"></a>第三次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 4;</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的 4 个 1，右移 4 位，再做或操作，这样 n 的二进制表示的高位中会有 8 个连续的 1。如 00001111 1111xxxxxx 。</p><h6 id="以此类推"><a href="#以此类推" class="headerlink" title="以此类推"></a>以此类推</h6><p>注意，容量最大也就是 32bit 的正数，因此最后 n |= n &gt;&gt;&gt; 16; ，最多也就 32 个 1（但是这已经是负数了。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY (2 ^ 30)，则取 MAXIMUM_CAPACITY。如果等于 MAXIMUM_CAPACITY (2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大 30 个 1，不会大于等于 MAXIMUM_CAPACITY。30 个 1，加 1 之后得 2 ^ 30） 。</p><h5 id="举一个例子说明下吧。"><a href="#举一个例子说明下吧。" class="headerlink" title="举一个例子说明下吧。"></a>举一个例子说明下吧。</h5><p><img src="/2020/06/12/HashMap详解/aaa.png" alt></p><p>注意，得到的这个 capacity 却被赋值给了 threshold。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>开始以为这个是个 Bug，感觉应该这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span><br></pre></td></tr></table></figure><p>这样才符合 threshold 的意思（当 HashMap 的 size 到达 threshold 这个阈值时会扩容）。<br>但是，请注意，在构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算.</p><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/129724004" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/129724004</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hash-计算原理&quot;&gt;&lt;a href=&quot;#hash-计算原理&quot; class=&quot;headerlink&quot; title=&quot;hash()计算原理&quot;&gt;&lt;/a&gt;hash()计算原理&lt;/h4&gt;&lt;p&gt;前面 put 方法中说到，需要先把当前 key 进行哈希处理，我们看下这个方法是
      
    
    </summary>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java空字符串和null的区别</title>
    <link href="http://yoursite.com/2020/06/11/Java%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/06/11/Java空字符串和null的区别/</id>
    <published>2020-06-11T11:57:10.000Z</published>
    <updated>2020-07-07T06:42:16.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java空字符串与null的区别："><a href="#Java空字符串与null的区别：" class="headerlink" title="Java空字符串与null的区别："></a>Java空字符串与null的区别：</h3><ul><li>类型<br>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）<br>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）</li><li>内存分配<br>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；<br>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：<br>就如下：<br>String str = new String(“abc”) ;<br>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<a id="more"></a></li><li>示例程序：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 = new String() ;</span><br><span class="line">        String str2 = null ;</span><br><span class="line">        String str3 = &quot;&quot; ;</span><br><span class="line">        System.out.println(str1==str2);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str2==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str1==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         //值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;&quot;; //str1对应一个空串，声明对象的引用</span><br><span class="line">String str2 = null; //str2引用为空</span><br><span class="line">String str3 = new String(); //str3将指向具体的String实例，默认值为“”</span><br><span class="line">注意：str1和str3被实例化，而str2没有实例化，但str1和str3所指的地址不同，但值一样，都为空。</span><br></pre></td></tr></table></figure><p>有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (str != null &amp;&amp; str.length() != 0)</span><br></pre></td></tr></table></figure><p>注意：首先要检查 str 不为 null。如果在一个 null 值上调用方法，会出现错误。</p><p>通过如上的程序可以得出如下结论：<br>字符串对象与null的值不相等，且内存地址也不相等；<br>空字符串对象与null的值不相等，且内存地址也不相等；<br>new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null）</p><p>以下是java 判断字符串是否为空的四种方法:<br>方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:<br>                     if(s == null || s.equals(“”));<br>方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:<br>                     if(s == null || s.length() == 0);<br>方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.<br>                     if(s == null || s.isEmpty());<br>方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:<br>                     if (s == null || s == “”);</p><p>注意:s == null 是有必要存在的.<br>　　“如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException.<br>　　并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException.”<br>　　如下Java代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　String str = null;</span><br><span class="line">　　if(str.equals(&quot;&quot;) || str == null)&#123;//会抛出异常</span><br><span class="line">　　          System.out.println(&quot;success&quot;);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.cnblogs.com/qiuting/p/5373571.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiuting/p/5373571.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java空字符串与null的区别：&quot;&gt;&lt;a href=&quot;#Java空字符串与null的区别：&quot; class=&quot;headerlink&quot; title=&quot;Java空字符串与null的区别：&quot;&gt;&lt;/a&gt;Java空字符串与null的区别：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类型&lt;br&gt;null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）&lt;br&gt;“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）&lt;/li&gt;
&lt;li&gt;内存分配&lt;br&gt;String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；&lt;br&gt;String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；&lt;br&gt;在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：&lt;br&gt;就如下：&lt;br&gt;String str = new String(“abc”) ;&lt;br&gt;ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>properties转yml配置文件</title>
    <link href="http://yoursite.com/2020/06/10/properties%E8%BD%ACyml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/10/properties转yml配置文件/</id>
    <published>2020-06-10T11:57:10.000Z</published>
    <updated>2020-07-07T02:35:13.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用在线问答转换 将各自properties文件转成yml文件类型<a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">https://www.toyaml.com/index.html</a></li><li>因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author yuezp</span><br><span class="line"> * @Date 2020/5/9 5:29 下午</span><br><span class="line"> * @Version v1.0</span><br><span class="line"> */</span><br><span class="line">public class YmlResourceFactory extends DefaultPropertySourceFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        String sourceName = (name == null) ? resource.getResource().getFilename() : name;</span><br><span class="line">        assert sourceName != null;</span><br><span class="line">        if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) &#123;</span><br><span class="line">            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();</span><br><span class="line">            factory.setResources(resource.getResource());</span><br><span class="line">            factory.afterPropertiesSet();</span><br><span class="line">            Properties properties = factory.getObject();</span><br><span class="line">            assert properties != null;</span><br><span class="line">            return new PropertiesPropertySource(sourceName, properties);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.createPropertySource(name, resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>APP启动类中的@PropertySource  修改为@PropertySource(value = {“classpath:application-服务名.yml”,”application-bdev.yml”},encoding = “UTF-8”, factory = YmlResourceFactory.class)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用在线问答转换 将各自properties文件转成yml文件类型&lt;a href=&quot;https://www.toyaml.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.toyaml.com/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举使用</title>
    <link href="http://yoursite.com/2020/06/09/%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/09/枚举使用/</id>
    <published>2020-06-09T11:57:10.000Z</published>
    <updated>2020-07-07T02:31:32.632Z</updated>
    
    <content type="html"><![CDATA[<p>枚举例子如下 ：<br>普通java类定义常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Operation &#123;  </span><br><span class="line">    private String operType;</span><br><span class="line">    </span><br><span class="line">    private Operation(String operType)&#123; </span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static final Operation ADD = new Operation(&quot;add&quot;);</span><br><span class="line">    public static final Operation DELETE = new Operation(&quot;delete&quot;);</span><br><span class="line">    public static final Operation MODIFY= new Operation(&quot;modify&quot;);</span><br><span class="line">    public static final Operation SELECT = new Operation(&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">    public String getOperType() &#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>枚举定义常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum OperationByEnum&#123;</span><br><span class="line">    ADD(&quot;add&quot;), DELETE(&quot;delete&quot;), MODIFY(&quot;modify&quot;), SELECT(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看上述两个类的 class 文件可以看出两种方式可以认为是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap OperationByEnum.class</span><br><span class="line">Compiled from &quot;OperationByEnum.java&quot;</span><br><span class="line">public final class OperationByEnum extends java.lang.Enum&lt;OperationByEnum&gt; &#123;</span><br><span class="line">  public static final OperationByEnum ADD;</span><br><span class="line">  public static final OperationByEnum DELETE;</span><br><span class="line">  public static final OperationByEnum MODIFY;</span><br><span class="line">  public static final OperationByEnum SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">  public static OperationByEnum[] values();</span><br><span class="line">  public static OperationByEnum valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap Operation.class</span><br><span class="line">Compiled from &quot;Operation.java&quot;</span><br><span class="line">public class Operation &#123;</span><br><span class="line">  public static final Operation ADD;</span><br><span class="line">  public static final Operation DELETE;</span><br><span class="line">  public static final Operation MODIFY;</span><br><span class="line">  public static final Operation SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public enum  ClusterType &#123;</span><br><span class="line"></span><br><span class="line">    kafka,</span><br><span class="line">    storm,</span><br><span class="line"></span><br><span class="line">    hdfs (&quot;hello&quot;,&quot;world&quot;),</span><br><span class="line"></span><br><span class="line">    yarn (&quot;nihao&quot;, &quot;haode&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String key;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    ClusterType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClusterType(String key, String value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ClusterType&#123;&quot; +</span><br><span class="line">                &quot;key=&apos;&quot; + key + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, value=&apos;&quot; + value + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;&#125; &quot; + super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;111 = &quot; + ClusterType.kafka);</span><br><span class="line">        ClusterType.kafka.setKey(&quot;hello&quot;);</span><br><span class="line">        String key = ClusterType.kafka.getKey();</span><br><span class="line">        System.out.println(&quot;222 = &quot; + key);</span><br><span class="line"></span><br><span class="line">        ClusterType.kafka.setValue(&quot;world&quot;);</span><br><span class="line">        String value = ClusterType.kafka.getValue();</span><br><span class="line">        System.out.println(&quot;333 = &quot; + value);</span><br><span class="line"></span><br><span class="line">        ClusterType hdfs = ClusterType.hdfs;</span><br><span class="line">        System.out.println(&quot;444 = &quot; + hdfs);</span><br><span class="line">        String s = ClusterType.hdfs.getKey();</span><br><span class="line">        System.out.println(&quot;555 = &quot; + s);</span><br><span class="line">        String value1 = ClusterType.hdfs.getValue();</span><br><span class="line">        System.out.println(&quot;666 = &quot; + value1);</span><br><span class="line">        ClusterType[] values = ClusterType.values();</span><br><span class="line">        for (ClusterType clusterType : values) &#123;</span><br><span class="line">            System.out.println(clusterType);</span><br><span class="line">        &#125;</span><br><span class="line">        ClusterType hdfs1 = ClusterType.valueOf(&quot;hdfs&quot;);</span><br><span class="line">        System.out.println(hdfs1);</span><br><span class="line">        String s1 = ClusterType.class.toString();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举中valueof用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   String str = &quot;ADD&quot;;</span><br><span class="line">OperationByEnum ob = OperationByEnum.valueOf(str);</span><br><span class="line">System.out.println(ob == OperationByEnum.ADD);//TRUE</span><br><span class="line"></span><br><span class="line">String str2=&quot;add&quot;;</span><br><span class="line">OperationByEnum ob1 = OperationByEnum.valueOf(str2);</span><br></pre></td></tr></table></figure><p>枚举类是一种特殊的 JAVA 类，枚举类中每声明一个枚举值就代表枚举类的一个实例对象。<br>与 JAVA 普通类一样，声明枚举类时也可以声明类的属性、方法、构造函数，但构造函数必须为私有。<br>枚举类也可以实现接口，继承抽象类。可以作为 switch 语句的参数。<br>若枚举类只有一个枚举值，则可以当做单例设计模式使用。<br>注意：为什么要对weekend 构造函数进行私有化， 答：保证外界无法通过调用构造函数再实例化出一个非法的枚举<br>同理 string 也要进行私有化，防止外界的非法更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> * 带抽象方法的枚举</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public enum OperationByEnum &#123;</span><br><span class="line">    ADD(&quot;add&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;增&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    DELETE(&quot;delete&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;删&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    MODIFY(&quot;modify&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;改&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    SELECT(&quot;select&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;查&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">        this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract String getChineseName();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        print(OperationByEnum.ADD);</span><br><span class="line">        String chineseName = OperationByEnum.ADD.getChineseName();</span><br><span class="line">        System.out.println(chineseName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print(OperationByEnum arg)&#123;</span><br><span class="line">        System.out.println(arg.getOperType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接：<a href="http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6" target="_blank" rel="noopener">http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6</a></p><p>常量的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public class ResultCode &#123;</span><br><span class="line"></span><br><span class="line">    public String code;</span><br><span class="line">    public String message;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSystemError() &#123;</span><br><span class="line">        return SYSTEM_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSUCCESS() &#123;</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ResultCode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultCode(String code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final ResultCode SUCCESS// 编译错误，常量需要初始化</span><br><span class="line">    public static final ResultCode SUCCESS = new ResultCode();</span><br><span class="line">    public static final ResultCode SYSTEM_ERROR = new ResultCode(&quot;E00001&quot;,&quot;系统错误&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ResultCode&#123;&quot; +</span><br><span class="line">                &quot;code=&apos;&quot; + code + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, message=&apos;&quot; + message + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ResultCode.SUCCESS.toString());</span><br><span class="line">        ResultCode.SUCCESS = new ResultCode(&quot;123&quot;, &quot;234&quot;);//报编译错误因为SUCCESS是常量</span><br><span class="line">        SUCCESS.setCode(&quot;nihao&quot;);//但是可以给常量赋值属性   &lt;--------------------</span><br><span class="line">        System.out.println(SUCCESS.getCode()); // 输出nihao                   -</span><br><span class="line">        System.out.println(ResultCode.SYSTEM_ERROR.toString());               -</span><br><span class="line">    &#125;                                                                         -</span><br><span class="line">                                                                              -</span><br><span class="line">                                                                              -</span><br><span class="line">&#125;                                                                             -</span><br><span class="line">```                                                                           -</span><br><span class="line">final修饰的变量一般用于常量的定义上，因为一旦定义就无法改变了                      -</span><br><span class="line">（基础数据类型的话，无法改变的是值；引用数据类型的话，无法改变的是引用              -</span><br><span class="line">&lt;引用不能改变即存在变量中的地址无法改变，但是引用的值是可以通过方法来改变的&gt;）。-----&gt;</span><br><span class="line">PS：本质上基础数据类型跟引用数据类型在内存中的都是值，</span><br><span class="line">只不过这个值对于用户的含义不同，一个存储的就是值本身，一个存储的值是引用地址。</span><br><span class="line">常量可以在定义时不初始化，但是必须在静态代码块中初始化。如下例子：</span><br></pre></td></tr></table></figure><p>package bonc.cn.com;</p><p>/**</p><ul><li><p>Created by yzp on 2017/11/6.</p></li><li><p>/<br>public class StringStudy {</p><p>  public static final String STR;<br>  public static final A a;<br>  static {</p><pre><code>STR = &quot;INIT&quot;;a = new A();a.a = &quot;abc&quot;;//常量可以在静态代码块中初始化，但是不允许修改引用，不过引用的对象中的属性是可以随意修改的。</code></pre><p>  }</p></li></ul><p>}</p><p>class A {<br>    String a;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">常量的三种动态初始化：</span><br></pre></td></tr></table></figure><p>public class Configuration {</p><p>public static final String CONFIG = “你想要指定的一些配置项”;</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">当我们需要给Configuration类中的CONFIG常量第一次使用时动态指定一个值时，而此时我们又不想去修改源代码，那我们有三种方法去实现这种需求。</span><br><span class="line"></span><br><span class="line">第一种：使用一个static静态代码块来指定，然后在静态代码块中，我们去动态读取外部的一个Properties文件的值。（最推荐）</span><br></pre></td></tr></table></figure><p>import java.util.Properties;</p><p>/**</p><ul><li><p>第一种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>Properties properties = new Properties();//把一个properties读进来CONFIG = &quot;properties.getConfig&quot;;//通过properties的配置项config来初始化我们的常量config</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二种：我们可以配置Java的运行时配置，来指定一个-Dname=value的参数，这样也可以在类内部动态的接受到运行时指定的一个参数。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第二种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getProperty(&quot;CONFIG&quot;);//通过系统的-D配置参数name=value形式来拿到这个配置值//如果是eclipse，右键-&gt;RUN AS-&gt;Run Configurations-&gt;arguments-&gt;VMarguments 里输入（-DCONFIG=我们想要加入的配置）</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三种：我们还可以读的到系统配置的PATH或者CLASSPATH里面的值，同理，我们也可以配置自己的环境变量，然后在程序中一样也能读到这些配置的环境变量。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第三种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getenv(&quot;PATH&quot;);//通过System.getenv()方法可以拿到系统环境变量，但我自己指定的环境变量没有取得成功，如果有知道原因的给我留言哈谢谢</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p></li></ul><p>final double PI=3.1415926</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原先很多书上说常量的初始化只有在定义的时候才可以，</span><br><span class="line">像上边的代码一样。其实常量的初始化也可以在构造函数中定义，但要注意必须要在所有重载的构造函数中都要定义一遍。</span><br><span class="line">常量在JAVA中经常定义成静态的static，这是为了节省内存，也是因为他是不能改变的。</span><br><span class="line">于是变成了：</span><br></pre></td></tr></table></figure><p>statis final double PI=3.1415926</p><pre><code>当定义静态常量的时候，就不能使用构造函数初始化常量了，这是因为我们经常直接使用类名调用静态成员，而构造函数的第一次运行，是在第一次new这个类的对象的时候。我们如果不去new，那么常量就永远不能初始化。所以，这个时候必须用上边的代码直接初始化。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举例子如下 ：&lt;br&gt;普通java类定义常量&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Operation &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Operation(String operType)&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this.operType = operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation ADD = new Operation(&amp;quot;add&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation DELETE = new Operation(&amp;quot;delete&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation MODIFY= new Operation(&amp;quot;modify&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation SELECT = new Operation(&amp;quot;select&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getOperType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://yoursite.com/2020/06/06/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/06/06/Java泛型/</id>
    <published>2020-06-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:49:06.874Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lt-extends-T-gt-和-lt-super-T-gt-的区别"><a href="#lt-extends-T-gt-和-lt-super-T-gt-的区别" class="headerlink" title="&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别"></a>&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别</h4><ul><li>&lt;? extends T&gt; 表示该通配符所代表的类型是 T 类型的子类。</li><li>&lt;? super T&gt; 表示该通配符所代表的类型是 T 类型的父类。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fun():</span><br><span class="line">&lt;T&gt;是用来规范T的，例如&lt;T extends Object&gt;就规定了边界，</span><br><span class="line">即规定了所有出现T的地方，T类型必须是Object的子类。</span><br><span class="line"></span><br><span class="line">Box 类定义为一个泛型类:</span><br><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T object;</span><br><span class="line"></span><br><span class="line">    public void set(T object) &#123; this.object = object; &#125;</span><br><span class="line">    public T get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建一个 Box 对象，不带泛型参数，发现获取对象的时候需要强制转换</span><br><span class="line"></span><br><span class="line">Box box2 = new Box();</span><br><span class="line">box2.set(new Apple());</span><br><span class="line">Apple apple = (Apple) box2.get();</span><br><span class="line">创建一个 Box 对象，带泛型参数，获取对象的时候就不需要强制转换</span><br><span class="line"></span><br><span class="line">Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();</span><br><span class="line">box.set(new Apple());</span><br><span class="line">Apple apple = box.get();</span><br><span class="line">总结下泛型的好处就是</span><br><span class="line">省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上;</span><br></pre></td></tr></table></figure><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 element(即元素)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Test&lt;T&gt; &#123;    </span><br><span class="line">    public List&lt;T&gt; list = new ArrayList&lt;T&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">和</span><br><span class="line">public class Test&lt;A&gt; &#123;    </span><br><span class="line">    public List&lt;A&gt; list = new ArrayList&lt;A&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 T 换成了 A，在执行效果上是没有任何区别的，只不过我们约定好了 T 代表 type，<br>所以还是按照约定规范来比较好，增加了代码的可读性；</p><p>如果要定义多个泛型参数，比如说两个泛型参数<br>很典型的一个栗子是 Map 的 key,value 泛型，我们也可以定义一个这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Mymap&lt;K, V&gt; &#123;</span><br><span class="line">    public K getKey();</span><br><span class="line">    public V getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MymapImpl&lt;K, V&gt; implements Mymap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public MymapImpl(K key, V value) &#123;</span><br><span class="line">       this.key = key;</span><br><span class="line">       this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey()    &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来就可以传入任意类型，创建实例了，不用转化类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mymap&lt;String, Integer&gt; mp1= new MymapImpl&lt;String, Integer&gt;(&quot;Even&quot;, 8);</span><br><span class="line">Mymap&lt;String, String&gt;  mp2= new MymapImpl&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">Mymap&lt;Integer, Integer&gt; mp3= new MymapImpl&lt;Integer, Integer&gt;(888, 888);</span><br></pre></td></tr></table></figure><h4 id="List，List，List-lt-gt-区别"><a href="#List，List，List-lt-gt-区别" class="headerlink" title="List，List，List&lt;?&gt; 区别"></a>List<t>，List<object>，List&lt;?&gt; 区别</object></t></h4><ul><li>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是 T 类型</t></t></li><li>ArrayList<?> al=new ArrayList<?>(); 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</li><li>ArrayList&lt;? extends E&gt; al=new ArrayList&lt;? extends E&gt;();<br>泛型的限定：<br>? extends E: 接收 E 类型或者 E 的子类型。<br>? super E: 接收 E 类型或者 E 的父类型<br>? 和 T 区别是？是一个不确定类，？和 T 都表示不确定的类型 ，<br>但如果是 T 的话，函数里面可以对 T 进行操作，比方 T car = getCar()，而不能用？ car = getCar()。</li></ul><p>[参考链接]<a href="http://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">http://www.jianshu.com/p/95f349258afb</a><br>[参考链接]<a href="http://frankco.iteye.com/blog/1668466" target="_blank" rel="noopener">http://frankco.iteye.com/blog/1668466</a></p><h4 id="最后来说说-T，Class，Class-lt-gt-区别："><a href="#最后来说说-T，Class，Class-lt-gt-区别：" class="headerlink" title="最后来说说 T，Class，Class&lt;?&gt; 区别："></a>最后来说说 T，Class<t>，Class&lt;?&gt; 区别：</t></h4><p>T 是一种具体的类，例如 String,List,Map…… 等等，这些都是属于具体的类，这个比较好理解<br>Class 是什么呢，Class 也是一个类，但 Class 是存放上面 String,List,Map…… 类信息的一个类，有点抽象，我们一步一步来看 。</p><p>如何获取到 Class 类呢，有三种方式：</p><ol><li>调用 Object 类的 getClass() 方法来得到 Class 对象，这也是最常见的产生 Class 对象的方法。<br>例如：</li></ol><p>List list = null;<br>Class clazz = list.getClass();</p><ol start="2"><li>使用 Class 类的中静态 forName() 方法获得与字符串对应的 Class 对象。<br>例如：Class clazz = Class.forName(“com.lyang.demo.fanxing.People”);</li><li>获取 Class 类型对象的第三个方法非常简单。如果 T 是一个 Java 类型，那么 T.class 就代表了匹配的类对象。<br>Class clazz = List.class;<br>那么问题来了，Class 类是创建出来了，但是 Class<t> 和 Class&lt;?&gt; 适用于什么时候呢？</t></li></ol><p>使用 Class<t> 和 Class&lt;?&gt; 多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。<br>People people = (People) Class.forName(“com.lyang.demo.fanxing.People”).newInstance();<br>看到了么，需要强转，如果反射的类型不是 People 类，就会报<br>java.lang.ClassCastException 错误。</t></p><p>使用 Class<t> 泛型后，不用强转了</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        return clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  throws IllegalAccessException, InstantiationException  &#123;</span><br><span class="line">            Fruit fruit= createInstance(Fruit .class);</span><br><span class="line">            People people= createInstance(People.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 Class<t> 和 Class<?> 有什么区别呢？Class<t> 在实例化的时候，T 要替换成具体类Class<?> 它是个通配泛型，? 可以代表任何类型，主要用于声明时的限制情况<br>例如可以声明一个<br>public Class<?> clazz;但是你不能声明一个public Class<t> clazz;因为 T 需要指定类型所以当不知道定声明什么类型的 Class 的时候可以定义一个 Class<?>,Class&lt;?&gt; 可以用于参数类型定义，方法返回值定义等。</t></t></t></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;lt-extends-T-gt-和-lt-super-T-gt-的区别&quot;&gt;&lt;a href=&quot;#lt-extends-T-gt-和-lt-super-T-gt-的区别&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&quot;&gt;&lt;/a&gt;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;? extends T&amp;gt; 表示该通配符所代表的类型是 T 类型的子类。&lt;/li&gt;
&lt;li&gt;&amp;lt;? super T&amp;gt; 表示该通配符所代表的类型是 T 类型的父类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>方法中参数前有final修饰</title>
    <link href="http://yoursite.com/2020/06/05/%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0%E5%89%8D%E6%9C%89final%E4%BF%AE%E9%A5%B0/"/>
    <id>http://yoursite.com/2020/06/05/方法中参数前有final修饰/</id>
    <published>2020-06-05T11:57:10.000Z</published>
    <updated>2020-07-07T01:05:31.892Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；</p><p>如下基本数据类型的代码例子：</p><pre><code>/** * final修饰的基本数据类型的值是不能够改变的 * @param i */public static void setValue(final int i) {    //编译通不过，基本数据类型不能够改变    i = 10;}</code></pre><p>如下引用数据类型的代码例子：</p><pre><code>/** * 对应final修饰的基本数据类型方法内部是不可以变得，但是引用数据类型是引用不可以变，但是值可以变 * @param user */public static void setUser(final User user) {    //引用的数据类型的值是可以改变的，但是指向的引用是不能够变的    user.setPassword(&quot;sdf&quot;);    //引用的数据类型引用是不可以变得，否则编译是不能够通过的    user = new User();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；&lt;/p&gt;
&lt;p&gt;如下基本数据类型的代码例子：&lt;/
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2020/06/04/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/04/Java异常处理/</id>
    <published>2020-06-04T11:57:10.000Z</published>
    <updated>2020-07-07T00:43:09.223Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，<br>在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、<br>IndexOutOfBoundsException 等），这些异常类分为两大类：Error 和 Exception。</p><p>Error 是无法处理的异常，比如 OutOfMemoryError，一般发生这种异常，<br>JVM 会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>Exception，也就是我们经常见到的一些异常情况，<br>比如 NullPointerException、IndexOutOfBoundsException，这些异常是我们可以处理的异常。</p><p>Exception 类的异常包括 checked exception 和 unchecked exception<br>（unchecked exception 也称运行时异常 RuntimeException，<br>当然这里的运行时异常并不是前面我所说的运行期间的异常，<br>只是 Java 中用运行时异常这个术语来表示，Exception 类的异常都是在运行期间发生的）。</p><p>unchecked exception（非检查异常），也称运行时异常（RuntimeException），<br>比如常见的 NullPointerException、IndexOutOfBoundsException。对于运行时异常，<br>java 编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。<br>　　<br>checked exception（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<br>java 编译器强制程序员必须进行捕获处理，比如常见的 IOExeption 和 SQLException。<br>对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><p>在 Java 中，所有异常类的父类是 Throwable 类，Error 类是 error 类型异常的父类，<br>Exception 类是 exception 类型异常的父类，RuntimeException 类是所有运行时异常的父类，<br>RuntimeException 以外的并且继承 Exception 的类是非运行时异常。<br>　　<br>典型的 RuntimeException 包括 NullPointerException、IndexOutOfBoundsException、<br>IllegalArgumentException 等。<br>　　<br>典型的非 RuntimeException 包括 IOException、SQLException 等。</p><p>在Java中什么是内存不足错误？<br>答：在Java中，OutOfMemoryError是 java.lang.VirtualMachineError的一个子类，<br>当堆内存耗尽时会被JVM抛出。我们能通过设置Java选项来提供更大的内存供应用使用来达到修复的目的。<br>$&gt;java MyProgram -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=256m</p><p>引发Exception in thread main的各种不同情形？<br>答：通常的一些主线程异常情形主要有以下几种：<br>Exception in thread main java.lang.UnsupportedClassVersionError:当编译和运行Java类的JDK版本不同的时出现这种异常。<br>Exception in thread main java.lang.NoClassDefFoundError:这种异常出现的原因有两种：第一种是提供类全名时附带有.class；第二种是指定类未找到。<br>Exception in thread main java.lang.NoSuchMethodError: main:当试图运行一个没main方法的类时会出现这种异常。<br>Exception in thread main java.lang.NoSuchMethodError: main:无论何时main方法任何异常，它打印异常到控制台。其第一部分是陈述main方法抛出的异常，第二部分打印异常类名，后接异常类信息。</p><p>Java中final,finally,finalize的区别？<br>答：final和finally在Java中是关键字，而finalize则是一个方法。<br>final关键字使得类变量不可变，避免类被其它类继承或方法被重写。finally跟try-catch块一起使用，即使是出现了异常，其子句总会被执行，通常，finally子句用来关闭相关资源。finally方法中的对象被销毁之前会被垃圾回收。<br>综上三者，只有finally用于异常处理。</p><p>在main方法抛出异常时发生了什么？<br>答：当main方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><p>catch子句能为空吗？<br>答：可以有空的catch子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的catch子句。Catch子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><p>链接：<a href="http://www.jianshu.com/p/f6865c97cd52" target="_blank" rel="noopener">http://www.jianshu.com/p/f6865c97cd52</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，&lt;br&gt;在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、&lt;br&gt;IndexOutOfBoundsException 等
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>值传递</title>
    <link href="http://yoursite.com/2020/06/03/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/06/03/值传递/</id>
    <published>2020-06-03T11:57:10.000Z</published>
    <updated>2020-07-07T00:41:03.767Z</updated>
    
    <content type="html"><![CDATA[<p>首先举例如下：<br>public class Employee {  </p><pre><code>public String name=null;  public Employee(String n){      this.name=n;  }  //将两个Employee对象交换  public static void swap(Employee e1,Employee e2){      Employee temp=e1;      e1=e2;      e2=temp;              System.out.println(e1.name+&quot; &quot;+e2.name); //打印结果：李四 张三  }  //主函数  public static void main(String[] args) {      Employee worker=new Employee(&quot;张三&quot;);      Employee manager=new Employee(&quot;李四&quot;);      swap(worker,manager);      System.out.println(worker.name+&quot; &quot;+manager.name); //打印结果仍然是： 张三 李四  }  </code></pre><p>}<br>上面的结果让人很失望，虽然形参对象 e1,e2 的内容交换了，<br>但实参对象 worker,manager 并没有互换内容。<br>这里面最重要的原因就在于形参 e1,e2 是实参 worker,manager 的地址拷贝。</p><p>传值：<br>传递的是值的副本。方法中对副本的修改，不会影响到调用方法<br>传引用：<br>传递的是引用的副本，共用一个内存，会影响到调用方法。<br>此时，形参和实参指向同一个内存地址。<br>对引用副本本身（对象地址）的修改，如设置为 null，重新指向其他对象，不会影响到调用方法。</p><p>链接：<a href="http://6924918.blog.51cto.com/6914918/1283761" target="_blank" rel="noopener">http://6924918.blog.51cto.com/6914918/1283761</a></p><p>String简单介绍：<br>两种方式是有区别的，这和 java 的内存管理有关，前面已经说过，string 创建之后是不可变的，<br>所以按照第一种方式创建的字符串会放在栈里，更确切的是常量池中，<br>常量池就是用来保存在编译阶段确定好了大小的数据，<br>一般我们定义的 int 等基本数据类型就保存在这里。<br>其具体的一个流程就是，编译器首先检查常量池，看看有没有一个 “string”，如果没有则创建。<br>如果有的话，则则直接把 str1 指向那个位置。<br>第二种创建字符串的方法是通过 new 关键字，还是 java 的内存分配，<br>java 会将 new 的对象放在堆中，这一部分对象是在运行时创建的对象。<br>所以我们每一次 new 的时候，都会创建不同的对象，即便是堆中已经有了一个一模一样的。<br>写一个小例子</p><pre><code>String str1 = &quot;string&quot;;String str4 = &quot;string&quot;;String str2 = new String(&quot;string&quot;);String str3 = new String(&quot;string&quot;);/*用于测试两种创建字符串方式的区别*/System.out.println(str1 == str4);System.out.println(str2 == str3);System.out.println(str3 == str1);str3 = str3.intern(); //一个不常见的方法System.out.println(str3 == str1);</code></pre><p>这个的运行结果是<br>true // 解释：两个字符串的内容完全相同，因而指向常量池中的同一个区域<br>false // 解释：每一次 new 都会创建一个新的对象<br>false // 解释： 注意 == 比较的是地址，不仅仅是内容<br>true // 介绍一下 intern 方法，这个方法会返回一个字符串在常量池中的一个地址，<br>如果常量池中有与 str3 内容相同的 string 则返回那个地址，如果没有，<br>则在常量池中创建一个 string 后再返回。实际上，str3 现在指向了 str1 的地址。</p><p>string 是不变的，那么为什么 str1 + “some” 是合法的，<br>其实，每次对 string 进行修改，都会创建一个新的对象。<br>所以如果需要对一个字符串不断的修改的话，效率是非常的低的，<br>因为堆的好处是可以动态的增加空间，劣势就是分配新的空间消耗是很大的</p><p>String 字符串常量：<br>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，<br>则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。<br>因此，每次在对 String 类型的对象进行改变的时候其实都等同于<br>生成了一个新的 String 对象，然后将指针指向新的 String 对象，<br>所以经常改变内容的字符串最好不要用 String，因为每次生成对象<br>都会对系统性能产生影响。</p><p>StringBuffer 字符串变量 (线程安全）：<br>所谓变量，即是可以随时变化的量。如果对 StringBuffer 对象进<br>行改变，每次结果都会对 StringBuffer 对象进行操作，而不是生<br>成新的对象。所以一般字符串要经常变化的话使用 StringBuffer。</p><p>StringBuilder 字符串变量（非线程安全）：<br>StringBuilder 和 StringBuffer 类功能基本相似，方法也差不多，<br>主要区别在于 StringBuffer 类的方法是多线程安全的，<br>而 StringBuilder 不是线程安全的，相比而言 StringBuilder 类会略微快一点。</p><p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>    （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中<br>    （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。<br>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量<br>    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。<br>         引用变量名和对应的对象仍然存储在相应的堆中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先举例如下：&lt;br&gt;public class Employee {  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String name=null;  

public Employee(String n){  
    this.name=n;  
}  
//将两个
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>kafka基础笔记</title>
    <link href="http://yoursite.com/2020/06/02/kafka%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/02/kafka基础笔记/</id>
    <published>2020-06-02T11:57:10.000Z</published>
    <updated>2020-07-06T09:59:10.073Z</updated>
    
    <content type="html"><![CDATA[<p>consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）<br>一种是topic-partition粒度（用户自己去管理）；</p><a id="more"></a><p>// 订阅指定的 topic 列表,并且会自动进行动态 partition 订阅<br>// 当发生以下情况时,会进行 rebalance: 1.订阅的 topic 列表改变; 2.topic 被创建或删除; 3.consumer 线程 die; 4. 加一个新的 consumer 线程<br>// 当发生 rebalance 时，会唤醒 ConsumerRebalanceListener 线程<br>public void subscribe(Collection topics, ConsumerRebalanceListener listener){}<br>// 同上，但是这里没有设置 listener<br>public void subscribe(Collection topics){}<br>//note: 订阅那些满足一定规则(pattern)的 topic<br>public void subscribe(Pattern pattern, ConsumerRebalanceListener listener){}</p><p>以上三种 API 都是按照 topic 级别去订阅，可以动态地获取其分配的 topic-partition，这是使用 Group 动态管理 ，它不能与手动 partition 管理一起使用。当监控到发生下面的事件时，Group 将会触发 rebalance 操作：</p><ul><li>订阅的 topic 列表变化；</li><li>topic 被创建或删除；</li><li>consumer group 的某个 consumer 实例挂掉；</li><li>一个新的 consumer 实例通过 join 方法加入到一个 group 中。</li></ul><p>consumer的两种commit实现，commitAsync()和commitSync()，即同步commit和异步commit；</p><p>kafka常用命令：<br>列出所有topic：kafka-topics.sh –zookeeper localhost:2181 –list<br>创建topic：kafka-topics.sh –zookeeper localhost:2181<br>                            –create<br>                            –topic earth<br>                            –partitions 1<br>                            –replication-factor 1</p><p>生产数据：kafka-console-producer.sh<br>                    –broker-list localhost:9092<br>                    –topic earth</p><p>消费数据：kafka-console-consumer.sh –zookeeper localhost:2181<br>                                      –topic earth<br>                                      –from-beginning</p><p>获取offset的最大最小值：kafka-run-class.sh kafka.tools.GetOffsetShell<br>                                 –broker-list localhost:9092<br>                                 –topic earth<br>                                 –time -1</p><p>最后的参数-1表示显示获取最大值，-2表示获取最小值；</p><p>查看具体某个partition数据内容：kafka-simple-consumer-shell.sh –broker-list localhost:9092<br>                                       –topic earth<br>                                       –partition 1<br>                                       –print-offsets<br>                                       –offset 18<br>                                       –clientId test<br>                                       –property print.key=true</p><p>1).System.exit(0)是将你的整个虚拟机里的内容都停掉了 ，而dispose()只是关闭这个窗口，但是并没有停止整个application exit() 。无论如何，内存都释放了！也就是说连JVM都关闭了，内存里根本不可能还有什么东西<br>2).System.exit(0)是正常退出程序，而System.exit(1)或者说非0表示非正常退出程序<br>3).System.exit(status)不管status为何值都会退出程序。和return 相比有以下不同点：return是回到上一层，而System.exit(status)是回到最上层<br>示例:<br>在一个if-else判断中，如果我们程序是按照我们预想的执行，到最后我们需要停止程序，那么我们使用System.exit(0)，而System.exit(1)一般放在catch块中，当捕获到异常，需要停止程序，我们使用System.exit(1)。这个status=1是用来表示这个程序是非正常退出。</p><p>自动关机命令：<br>表示600秒后自动关机：shutdown -s -t 600<br>取消定时关机：shutdown -a<br>表示600秒后自动重启：shutdown -r -t 600<br>rononce -p：15秒关机</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）&lt;br&gt;一种是topic-partition粒度（用户自己去管理）；&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka、大数据" scheme="http://yoursite.com/tags/kafka%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>java中内存结构</title>
    <link href="http://yoursite.com/2020/06/01/java%E4%B8%AD%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/06/01/java中内存结构/</id>
    <published>2020-06-01T11:57:10.000Z</published>
    <updated>2020-07-06T09:55:30.293Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的笔记，今天记录到自己的博客中；</p><ul><li>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   </li></ul><p>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   </p><ul><li>堆内存用来存放由new创建的对象和数组。<br>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。<br>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。<br>引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   </li></ul><a id="more"></a><h4 id="java中变量在内存中的分配"><a href="#java中变量在内存中的分配" class="headerlink" title="java中变量在内存中的分配"></a>java中变量在内存中的分配</h4><p>1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭</p><p>2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</p><p>3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</p><p>附：java的内存机制</p><p>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。<br>　　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。<br>　　这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！</p><p>[参考链接]<a href="http://blog.csdn.net/emira_j/article/details/51232611" target="_blank" rel="noopener">http://blog.csdn.net/emira_j/article/details/51232611</a><br>[参考链接]<a href="http://blog.csdn.net/fuckluy/article/details/50614983" target="_blank" rel="noopener">http://blog.csdn.net/fuckluy/article/details/50614983</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前的笔记，今天记录到自己的博客中；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆内存用来存放由new创建的对象和数组。&lt;br&gt;在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。&lt;br&gt;在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。&lt;br&gt;引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>tiny-spring笔记一</title>
    <link href="http://yoursite.com/2020/05/29/tiny-spring%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/05/29/tiny-spring笔记一/</id>
    <published>2020-05-29T11:57:10.000Z</published>
    <updated>2020-06-01T01:33:33.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-step1-最基本的容器"><a href="#1-step1-最基本的容器" class="headerlink" title="1.step1 - 最基本的容器"></a>1.step1 - 最基本的容器</h4><p>使用如下命令在idea中查看最开始的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-1-container-register-and-get</span><br></pre></td></tr></table></figure><p>代码结构如下图所示<br><img src="/2020/05/29/tiny-spring笔记一/aaa.png" alt><br>IoC 最基本的角色有两个：容器 (BeanFactory) 和 Bean 本身。这里使用 BeanDefinition 来封装了 bean 对象(当前之后bean属性)，这样可以保存一些额外的元信息。</p><a id="more"></a><h4 id="2-step2-将-bean-创建放入工厂"><a href="#2-step2-将-bean-创建放入工厂" class="headerlink" title="2.step2 - 将 bean 创建放入工厂"></a>2.step2 - 将 bean 创建放入工厂</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-2-abstract-beanfactory-and-do-bean-initilizing-in-it</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/bbb.png" alt><br>step1 中的 bean 是初始化好之后再 set 进去的，实际使用中，我们希望容器来管理 bean 的创建。于是我们将 bean 的初始化放入 BeanFactory 中。为了保证扩展性，我们使用 Extract Interface 的方法，将 BeanFactory 替换成接口，而使用 AbstractBeanFactory 和 AutowireCapableBeanFactory 作为其实现。”AutowireCapable” 的意思是 “可自动装配的”，为我们后面注入属性做准备。step2和step1创建bean的方式不同，step2的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">注意newInstance和new的区别</span><br></pre></td></tr></table></figure><h4 id="3-step3-为-bean-注入属性"><a href="#3-step3-为-bean-注入属性" class="headerlink" title="3.step3 - 为 bean 注入属性"></a>3.step3 - 为 bean 注入属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-3-inject-bean-with-property</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/ccc.png" alt><br><img src="/2020/05/29/tiny-spring笔记一/ddd.png" alt><br>这一步，我们想要为 bean 注入属性。我们选择将属性注入信息保存成 PropertyValue 对象，并且保存到 BeanDefinition 中。这样在初始化 bean 的时候，我们就可以根据 PropertyValue 来进行 bean 属性的注入。Spring 本身使用了 setter 来进行注入，这里为了代码简洁，我们使用 Field 的形式来注入。</p><h4 id="4-step4-读取-xml-配置来初始化-bean"><a href="#4-step4-读取-xml-配置来初始化-bean" class="headerlink" title="4.step4 - 读取 xml 配置来初始化 bean"></a>4.step4 - 读取 xml 配置来初始化 bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-4-config-beanfactory-with-xml</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/eee.png" alt></p><h4 id="5-step5-为-bean-注入-bean"><a href="#5-step5-为-bean-注入-bean" class="headerlink" title="5.step5 - 为 bean 注入 bean"></a>5.step5 - 为 bean 注入 bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-5-inject-bean-to-bean</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-step1-最基本的容器&quot;&gt;&lt;a href=&quot;#1-step1-最基本的容器&quot; class=&quot;headerlink&quot; title=&quot;1.step1 - 最基本的容器&quot;&gt;&lt;/a&gt;1.step1 - 最基本的容器&lt;/h4&gt;&lt;p&gt;使用如下命令在idea中查看最开始的版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout step-1-container-register-and-get&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;代码结构如下图所示&lt;br&gt;&lt;img src=&quot;/2020/05/29/tiny-spring笔记一/aaa.png&quot; alt&gt;&lt;br&gt;IoC 最基本的角色有两个：容器 (BeanFactory) 和 Bean 本身。这里使用 BeanDefinition 来封装了 bean 对象(当前之后bean属性)，这样可以保存一些额外的元信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring、Java" scheme="http://yoursite.com/categories/Spring%E3%80%81Java/"/>
    
    
      <category term="Spring、Java、Ioc" scheme="http://yoursite.com/tags/Spring%E3%80%81Java%E3%80%81Ioc/"/>
    
  </entry>
  
</feed>
