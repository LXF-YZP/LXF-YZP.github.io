<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-11T07:06:29.091Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kill掉多个进程</title>
    <link href="http://yoursite.com/2020/08/11/kill%E6%8E%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/kill掉多个进程/</id>
    <published>2020-08-11T11:57:10.000Z</published>
    <updated>2020-08-11T07:06:29.091Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep beh-oss-minio-test-1.0-SNAPSHOT.jar | grep -v grep| awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux、进程" scheme="http://yoursite.com/tags/Linux%E3%80%81%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>grep命令使用</title>
    <link href="http://yoursite.com/2020/08/09/grep%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/09/grep命令使用/</id>
    <published>2020-08-09T11:57:10.000Z</published>
    <updated>2020-08-11T08:30:15.162Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、grep" scheme="http://yoursite.com/categories/Linux%E3%80%81grep/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux下定时任务命令</title>
    <link href="http://yoursite.com/2020/08/08/linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/08/08/linux下定时任务命令/</id>
    <published>2020-08-08T11:57:10.000Z</published>
    <updated>2020-08-11T08:33:11.792Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、定时任务" scheme="http://yoursite.com/categories/Linux%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>sed命令使用</title>
    <link href="http://yoursite.com/2020/08/08/sed%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/08/sed命令使用/</id>
    <published>2020-08-08T11:57:10.000Z</published>
    <updated>2020-08-11T08:28:58.506Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、sed" scheme="http://yoursite.com/categories/Linux%E3%80%81sed/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>awk命令使用</title>
    <link href="http://yoursite.com/2020/08/07/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/07/awk命令使用/</id>
    <published>2020-08-07T11:57:10.000Z</published>
    <updated>2020-08-11T08:28:06.143Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、awk" scheme="http://yoursite.com/categories/Linux%E3%80%81awk/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux上CPU内存使用查看</title>
    <link href="http://yoursite.com/2020/08/06/linux%E4%B8%8ACPU%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2020/08/06/linux上CPU内存使用查看/</id>
    <published>2020-08-06T11:57:10.000Z</published>
    <updated>2020-08-07T01:16:16.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top 命令的显示结果如下所示：</span><br><span class="line"></span><br><span class="line">top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 </span><br><span class="line">Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie </span><br><span class="line">Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si </span><br><span class="line">Mem: 191272k total, 173656k used, 17616k free, 22052k buffers </span><br><span class="line">Swap: 192772k total, 0k used, 192772k free, 123988k cached </span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </span><br><span class="line">1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd </span><br><span class="line">14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top </span><br><span class="line">1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init </span><br><span class="line">2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 </span><br><span class="line">3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>统计信息区</strong></p><p>前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p><table><thead><tr><th>01:06:48</th><th>当前时间</th></tr></thead><tbody><tr><td>up 1:22</td><td>系统运行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值。</td></tr></tbody></table><p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用 CPU 百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用 CPU 百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>98.7% id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><p>最后两行为内存信息。内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。 相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><p><strong><em>free [选项]</em></strong></p><p><strong>默认情况下，即在没有选项的情况下，\</strong>“*<em>free”命令显示内存的使用信息。默认按照k（b）的计数单位统计。*</em></p><ul><li>total：表示 总计物理内存的大小。</li><li>used：表示 已使用多少。</li><li>free：表示 可用内存多少。</li><li>Shared：表示多个进程共享的内存总额。</li><li>Buffers/cached：表示 磁盘缓存的大小。</li></ul><p><strong>注意：free命令的选项区分大小写，请认真对照上图中是大写还是小写</strong></p><ol><li>free -b：以bytes为单位来显示内存的信息。</li><li>free -k：以kb为单位来显示内存的信息。</li><li>free -m：以m为单位来显示内存的信息。</li><li>free -g：以G为单位来显示内存的信息。</li><li>free -h：以适于人类可读方式显示内存信息。-h与其他命令最大不同是<strong>-h</strong>选项会在数字后面加上适于人类可读的单位</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;top命令&quot;&gt;&lt;a href=&quot;#top命令&quot; class=&quot;headerlink&quot; title=&quot;top命令&quot;&gt;&lt;/a&gt;top命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;top 命令的显示结果如下所示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mem: 191272k total, 173656k used, 17616k free, 22052k buffers &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swap: 192772k total, 0k used, 192772k free, 123988k cached &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>NERDTree快捷键</title>
    <link href="http://yoursite.com/2020/07/23/NERDTree%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/23/NERDTree快捷键/</id>
    <published>2020-07-23T11:57:10.000Z</published>
    <updated>2020-08-04T09:35:20.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换工作台和目录"><a href="#切换工作台和目录" class="headerlink" title="切换工作台和目录"></a>切换工作台和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><h3 id="NerdTree-在-vimrc-中的常用配置"><a href="#NerdTree-在-vimrc-中的常用配置" class="headerlink" title="NerdTree 在 .vimrc 中的常用配置"></a>NerdTree 在 .vimrc 中的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="line">autocmd VimEnter * NERDTree</span><br><span class="line"></span><br><span class="line">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class="line">map  :silent! NERDTreeToggle</span><br><span class="line"></span><br><span class="line">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;切换工作台和目录&quot;&gt;&lt;a href=&quot;#切换工作台和目录&quot; class=&quot;headerlink&quot; title=&quot;切换工作台和目录&quot;&gt;&lt;/a&gt;切换工作台和目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + h    光标 focus 左侧树形目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + l    光标 focus 右侧文件显示窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + w    光标自动在左右侧窗口切换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + r    移动当前窗口的布局位置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>MacVim编辑器使用</title>
    <link href="http://yoursite.com/2020/07/22/MacVim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/22/MacVim编辑器使用/</id>
    <published>2020-07-22T11:57:10.000Z</published>
    <updated>2020-07-22T03:30:53.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式区分"><a href="#Vim-模式区分" class="headerlink" title="Vim 模式区分"></a>Vim 模式区分</h3><h5 id="普通模式-Normal-mode"><a href="#普通模式-Normal-mode" class="headerlink" title="普通模式 (Normal mode)"></a>普通模式 (Normal mode)</h5><ul><li>Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑</li></ul><h5 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h5><ul><li>该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.</li></ul><h5 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h5><ul><li>与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式</li></ul><h5 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h5><ul><li>新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)</li></ul><h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><ul><li>在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启</li></ul><a id="more"></a><h3 id="元字符的存在"><a href="#元字符的存在" class="headerlink" title="元字符的存在"></a>元字符的存在</h3><p>元字符是 Vim 对模糊匹配的一个附加属性，通过元字符可以快速找出目标字段.</p><ul><li><code>.</code>: 表示匹配任意 <strong>一个</strong> 字符。例: <code>c..l</code> 表示任意以 c 开头，中间有两个任意字符，l 结尾的字段.</li><li><code>.*</code>: 表示匹配 <strong>任意多个</strong> 字符。例: <code>c.*l</code> 表示任意以 c 开头 l 结尾的字段 (不会将一个字段进行跨行处理，因此非常智能，很频繁使用)</li><li><code>$</code>: 匹配行尾。例: <code>/d.*$</code> 表示匹配到以 d 开头到行尾中的所有内容，<code>/123$</code> 表示以 123 结尾的所有字段</li><li><code>^</code>: 匹配行首。例: <code>^.*d</code> 表示匹配到行首到 d 的所有内容，<code>/^123</code> 表示以 123 开头的字段</li><li><code>\&lt;</code> : 匹配单词词首</li><li><code>\&gt;</code>: 匹配单词词尾。例: <code>/\&lt;f\&gt;</code> 表示只匹配 <code>f</code> 单词，如果其前有任何字符它就不是单词，不会被匹配到.</li><li><code>\( \)</code>: 括号内的内容可以在后面被引用，引用方式为 <code>\1</code>, <code>\2</code></li><li><code>*</code>: 表示其前字符可以重复 0~ 无数 次。如 <code>/be*</code> 会匹配到 <code>b</code>, <code>be</code>, <code>bee</code> …, 因为 e 重复零次就是没有，所以会返回 b</li><li><code>\+</code>: 表示其前字符必须重复 1~ 无数 次，如 <code>/be\+</code> 会匹配到 <code>be</code>, <code>bee</code>, <code>beee</code> …</li><li><code>\=</code>: 代表其前字符必须重复 0 或者 1 次.</li><li><code>\{n,m}</code> : 其前字符必须重复 n 到 m 次</li><li><code>[adz]</code>: 匹配 <code>a</code>, <code>d</code>, <code>z</code> 中的任意 <strong>一个</strong> , 括号内也可是数字，如 <code>[2-5]</code> 表示匹配 <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> 中的任意一个数字</li><li><code>\|</code>; 或的意思，表示只要符合其前或其后任意一个字符即可。例: <code>/one\|two\|three</code> 表示匹配 one, two, three 中的任意一个. <code>end\(if\|while\|for\)</code> 表示会查找到 endif, endwhile, endfor 中的任意一个.</li><li><code>[^a]</code>: 匹配除 <code>a</code> 以外的任意 <strong>字符</strong></li><li><code>[a-c]</code>: 匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个，递增的顺序</li><li><code>\d</code>: 匹配十进制数字中的任意一个，等同于 <code>[0-9]</code>. 例: <code>/\d\d:\d\d:\d\d</code> 表示查找如 <code>17:31:00</code> 格式的字符</li><li><code>\D</code>: 匹配除十进制数字外的任意一个字符，等同于 <code>[^0-9]</code></li><li><code>\x</code>: 匹配十六进制数字中的任意一个，等同于 <code>[0-9A-Fa-f]</code></li><li><code>\X</code>: 匹配除十六进制数字外的任意一个字符，等同于 <code>[^0-9A-Fa-f]</code></li><li><code>\w</code>: 匹配一个单词 (对中文来说非常鸡肋，因为只有 Vim 判定是单词的才会进行匹配，与 <code>w</code>, <code>b</code>, <code>e</code> , 的匹配规则相同)</li><li><code>\W</code>: 匹配除单词外的所有字符。因为在 vim 中中文全部不被认为是单词，因此，此匹配会选中所有中文字段.</li><li><code>\t</code>: 匹配 tab , 可使用此方法将所有 tab 替换为空格</li><li><code>\s</code>: 匹配空白字段，包含 tab 与空格，在 pattern 中使用此查找空白，在 string 中就可以直接使用空格或者 tab 来输入以替换了</li><li><code>\S</code>: 匹配非空白字段，等同于 <code>[^\s]</code></li><li><code>\n</code>: 匹配换行符</li><li><code>\r</code>: 换行，在 pattern 中使用 <code>\n</code> 作为搜索串，在 string 中使用 <code>\r</code> 作为换行命令 (如果在 string 中仍然使用 \n 的话会出错)</li><li><code>\_s</code>: 匹配换行或空白</li><li><code>\_a</code>: 匹配换行或单词 (因为是单词，vim 不会匹配中文)</li><li><code>\C</code>: 区分大小写地查找或替换，例: <code>/\CText</code> 表示只会查找 <code>Text</code>, 不会查找 <code>text</code> 或 <code>tExt</code> 等</li><li><code>\c</code>: 不区分大小写地查找替换 (已经在 vim 中设置了默认不区分了)</li></ul><p>如上所述，<code>.</code>, <code>*</code>, <code>[</code>, <code>]</code>, <code>^</code>, <code>%</code>, <code>/</code>, <code>?</code>, <code>~</code>, <code>$</code> 这十个字符有特殊含义，如果对这十个字符进行匹配，需要添加 <code>\</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h5 id="查找逻辑"><a href="#查找逻辑" class="headerlink" title="查找逻辑"></a>查找逻辑</h5><ul><li><code>/单词</code>: 全文查找 view 关键字 (n 为向下方向)</li><li><code>/\c单词</code>: 全文查找 view 关键字 (大小写不敏感)</li><li><code>?单词</code>: 全文查找 view 关键字 (n 为向上方向)</li><li><code>:noh</code> : 退出查找模式</li><li><code>*</code>: 全文查找光标处词组 (n 为向下方向)</li><li><code>#</code>: 全文查找光标处词组 (n 为向上方向)</li><li><code>n</code>: 下一个列出的关键字</li><li><code>N</code>: 上一个列出的关键字</li></ul><h5 id="查找实例"><a href="#查找实例" class="headerlink" title="查找实例"></a>查找实例</h5><p><code>/\&lt;单词\&gt;</code>: 查找只为 <code>单词</code> 的字符</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>假如有这么一行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thee best time to see thee flowers is in thee spring.</span><br></pre></td></tr></table></figure><ul><li>当我键入<code>:s/thee/the &lt;回车&gt;</code>，那么该行的第一 <code>thee</code> 就被我替换成了 <code>the</code></li><li>如果想将所有的 <code>thee</code> 替换，可以键入<code>:s/thee/the/g</code></li><li>要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :% s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :% s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li></ul><h2 id="文本编辑之删除"><a href="#文本编辑之删除" class="headerlink" title="文本编辑之删除"></a>文本编辑之删除</h2><p>只需要将光标移动到你想要删除的文本位置，按下 <code>x</code> 键即可</p><blockquote><p>提示：当我对某个操作不满意，想要撤回的时候，只要键入 u 即可</p></blockquote><h2 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h2><p>简单来说，如果我想要删除一个单词只需要键入 <code>dw</code>，如果我键入 <code>d$</code>，那么这一整行的内容都被我删了(dd也可以达到相同的效果)</p><h2 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h2><p><strong><em>假如 vim 打开的文件中某一个行有这样一句的内容</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is just a line with words you can move around in.</span><br></pre></td></tr></table></figure><p>我的光标在开头的 T 位置</p><ul><li>键入一次 e，我的光标位置就会出现在 This 这个单词的末尾 s 处，键入两次，就会出现在下一个单词的末尾。</li><li>键入 w，就会出现在下一个单词的开头，多次键入与 e 的效果雷同。</li><li>键入 0(数字0)，能使我的光标出现在行首。</li><li>键入 $，能使我的光标出现在行末。</li></ul><h2 id="使用计数已删除更多"><a href="#使用计数已删除更多" class="headerlink" title="使用计数已删除更多"></a>使用计数已删除更多</h2><p>上面已经提到过删除操作符和动作的组合，你可以在组合中动作之前插入一个数字以删除更多</p><p> d number (数字) motion</p><p>比如键入 <code>d2w</code>，我们就可以删除光标所在位置起的两个单词</p><h2 id="操作整行"><a href="#操作整行" class="headerlink" title="操作整行"></a>操作整行</h2><ul><li>之前用 <code>d$</code> 命令删除整行内容后，我们会发现这一行变成了一个空行，所以可能用清除整行内容来称呼它更加合适</li><li>如果我们要删除当前行，可以键入 <code>dd</code> 命令</li><li>你也可以键入 <code>2dd</code>，来删除当前行起的两行(向下)</li></ul><h2 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h2><ul><li>之前有提到过，如果你操作失误，可以键入 <code>u</code> 来撤销最后一次执行的命令</li><li>如果你嫌一次一次的撤销太麻烦，你可以键入 <code>U</code>，来使当前行恢复到初始状态</li></ul><h2 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h2><p>之前所说的 <code>dd</code> 命令删除了一整行内容，其实呢，并没有消失，而是保存在了 vim 的寄存器中。</p><ul><li>当使用 <code>dd</code> 命令删除了某一行内容后，光标移到某一行，键入 <code>p</code>，刚刚删除掉的那一行内容就会粘贴到当前行的下一行了</li></ul><h2 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h2><ul><li>键入 <code>cw</code>，然后输入正确的内容，我们就可以更改整个单词了。</li></ul><h2 id="复制一行"><a href="#复制一行" class="headerlink" title="复制一行"></a>复制一行</h2><ul><li><code>yy</code> 复制光标所在位置的一行， <code>yw</code>复制光标所在的单词， 使用<code>p</code>进行粘贴；</li></ul><h2 id="在-vim-内执行外部命令的方法"><a href="#在-vim-内执行外部命令的方法" class="headerlink" title="在 vim 内执行外部命令的方法"></a>在 vim 内执行外部命令的方法</h2><p>再用 vim 编程的时候，如果我想输入一个外部命令怎么办，难道我还需要新建个终端窗口吗？当然不需要</p><p>1、 按下我们所熟悉的 <code>:</code> 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。</p><p>2、 接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3、 我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样</p><p>[参考链接]<a href="https://juejin.im/post/5aed4b0651882567127868df#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5aed4b0651882567127868df#heading-14</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vim-模式区分&quot;&gt;&lt;a href=&quot;#Vim-模式区分&quot; class=&quot;headerlink&quot; title=&quot;Vim 模式区分&quot;&gt;&lt;/a&gt;Vim 模式区分&lt;/h3&gt;&lt;h5 id=&quot;普通模式-Normal-mode&quot;&gt;&lt;a href=&quot;#普通模式-Normal-mode&quot; class=&quot;headerlink&quot; title=&quot;普通模式 (Normal mode)&quot;&gt;&lt;/a&gt;普通模式 (Normal mode)&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;插入模式&quot;&gt;&lt;a href=&quot;#插入模式&quot; class=&quot;headerlink&quot; title=&quot;插入模式&quot;&gt;&lt;/a&gt;插入模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;可视模式&quot;&gt;&lt;a href=&quot;#可视模式&quot; class=&quot;headerlink&quot; title=&quot;可视模式&quot;&gt;&lt;/a&gt;可视模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;替换模式&quot;&gt;&lt;a href=&quot;#替换模式&quot; class=&quot;headerlink&quot; title=&quot;替换模式&quot;&gt;&lt;/a&gt;替换模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;命令行模式&quot;&gt;&lt;a href=&quot;#命令行模式&quot; class=&quot;headerlink&quot; title=&quot;命令行模式&quot;&gt;&lt;/a&gt;命令行模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>使用VIM打开文件报错”******^M“</title>
    <link href="http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8VIM%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E2%80%9D******%5EM%E2%80%9C/"/>
    <id>http://yoursite.com/2020/07/21/使用VIM打开文件报错”******^M“/</id>
    <published>2020-07-21T11:57:10.000Z</published>
    <updated>2020-07-21T09:47:00.629Z</updated>
    
    <content type="html"><![CDATA[<p>下载完vim的主题之后打开文件报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /Users/luxiaofeng/.vim/colors/molokai.vim</span><br><span class="line">Error detected while processing /Users/luxiaofeng/.vim/colors/molokai.vim:</span><br><span class="line">line   10:</span><br><span class="line">E411: highlight group not found: clear^M</span><br><span class="line">line   11:</span><br><span class="line">E15: Invalid expression: version &gt; 580^M</span><br><span class="line">line  275:</span><br><span class="line">E171: Missing :endif</span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开那个文件后：</span><br><span class="line">:set ff=unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载完vim的主题之后打开文件报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="linux、vim" scheme="http://yoursite.com/tags/linux%E3%80%81vim/"/>
    
  </entry>
  
  <entry>
    <title>vim安装插件之后的各种报错</title>
    <link href="http://yoursite.com/2020/07/20/vim%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/20/vim安装插件之后的各种报错/</id>
    <published>2020-07-20T11:57:10.000Z</published>
    <updated>2020-07-28T09:13:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件nerdtree"><a href="#安装插件nerdtree" class="headerlink" title="安装插件nerdtree"></a>安装插件nerdtree</h2><p>启动MacVim报错<code>Error detected while processing function &lt;SNR&gt;2_lod_cmd</code>或者<code>Error detected while processing function &lt;SNR&gt;3_lod_cmd</code></p><p>原因是在<code>.vimrc</code>中配置的插件为<code>Plug &#39;scrooloose/nerdtree&#39;, { &#39;on&#39;: &#39;NERDTreeToggle&#39; }</code>. 改为 <code>Plug &#39;scrooloose/nerdtree&#39;</code>之后报错消失；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装插件nerdtree&quot;&gt;&lt;a href=&quot;#安装插件nerdtree&quot; class=&quot;headerlink&quot; title=&quot;安装插件nerdtree&quot;&gt;&lt;/a&gt;安装插件nerdtree&lt;/h2&gt;&lt;p&gt;启动MacVim报错&lt;code&gt;Error detected
      
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim插件安装</title>
    <link href="http://yoursite.com/2020/07/19/Vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/07/19/Vim插件安装/</id>
    <published>2020-07-19T11:57:10.000Z</published>
    <updated>2020-08-05T01:36:27.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装vim-plug插件"><a href="#安装vim-plug插件" class="headerlink" title="安装vim-plug插件"></a>安装vim-plug插件</h2><ul><li><p>首先下载插件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:junegunn/vim-plug.git</span><br></pre></td></tr></table></figure></li><li><p>下载 plug.vim(<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a>) 并将其放在 “自动加载” 目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；</a></p></li><li><p>在<code>~/.vimrc</code>中添加一个 vim-plug 部分</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&apos;data&apos;) . &apos;/plugged&apos;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &apos;plugin&apos;</span><br><span class="line">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class="line"></span><br><span class="line">&quot; Make sure you use single quotes</span><br><span class="line"></span><br><span class="line">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br><span class="line">Plug &apos;junegunn/vim-easy-align&apos;</span><br><span class="line"></span><br><span class="line">&quot; Any valid git URL is allowed</span><br><span class="line">Plug &apos;https://github.com/junegunn/vim-github-dashboard.git&apos;</span><br><span class="line"></span><br><span class="line">&quot; Multiple Plug commands can be written in a single line using | separators</span><br><span class="line">Plug &apos;SirVer/ultisnips&apos; | Plug &apos;honza/vim-snippets&apos;</span><br><span class="line"></span><br><span class="line">&quot; On-demand loading</span><br><span class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;:  &apos;NERDTreeToggle&apos; &#125;</span><br><span class="line">Plug &apos;tpope/vim-fireplace&apos;, &#123; &apos;for&apos;: &apos;clojure&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a non-master branch</span><br><span class="line">Plug &apos;rdnetto/YCM-Generator&apos;, &#123; &apos;branch&apos;: &apos;stable&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br><span class="line">Plug &apos;fatih/vim-go&apos;, &#123; &apos;tag&apos;: &apos;*&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin options</span><br><span class="line">Plug &apos;nsf/gocode&apos;, &#123; &apos;tag&apos;: &apos;v.20150303&apos;, &apos;rtp&apos;: &apos;vim&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br><span class="line">Plug &apos;junegunn/fzf&apos;, &#123; &apos;dir&apos;: &apos;~/.fzf&apos;, &apos;do&apos;: &apos;./install --all&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Unmanaged plugin (manually installed and updated)</span><br><span class="line">Plug &apos;~/my-prototype-plugin&apos;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>重新加载.vimrc 并<code>:PlugInstall</code>安装插件,执行完成之后，使用vim打开文件有报错的话，一般是因为Windows下的换行符和Linux下的换行符不一样导致的，那个文件报错就使用vim打开那个文件，使用命令:set ff=unix修改换行符；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装vim-plug插件&quot;&gt;&lt;a href=&quot;#安装vim-plug插件&quot; class=&quot;headerlink&quot; title=&quot;安装vim-plug插件&quot;&gt;&lt;/a&gt;安装vim-plug插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载插件 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:junegunn/vim-plug.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载 plug.vim(&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/a&gt;) 并将其放在 “自动加载” 目录中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;~/.vimrc&lt;/code&gt;中添加一个 vim-plug 部分&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap1.7源码详解</title>
    <link href="http://yoursite.com/2020/07/18/ConcurrentHashMap1.7%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/18/ConcurrentHashMap1.7源码详解/</id>
    <published>2020-07-18T11:57:10.000Z</published>
    <updated>2020-07-21T09:47:02.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.</span><br></pre></td></tr></table></figure><p>大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。</p><a id="more"></a><h4 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h4><p>HashEntry 是 ConcurrentHashMap 的基础单元 (节点)，是实际数据的载体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Sets next field with volatile write semantics.  (See above</span><br><span class="line">         * about use of putOrderedObject.)</span><br><span class="line">         */</span><br><span class="line">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">            UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Unsafe mechanics</span><br><span class="line">        static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        static final long nextOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class k = HashEntry.class;</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(&quot;next&quot;));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>Segment 继承 ReentrantLock 锁，用于存放数组 HashEntry[]。在这里可以看出，无论 1.7 还是 1.8 版本，ConcurrentHashMap 底层并不是对 HashMap 的扩展，而是同样从底层基于数组 + 链表进行功能实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = 2249069246763182397L;</span><br><span class="line"></span><br><span class="line">        static final int MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line"></span><br><span class="line">        // 数据节点存储在这里(基础单元是数组)</span><br><span class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        transient int count;</span><br><span class="line"></span><br><span class="line">        transient int modCount;</span><br><span class="line"></span><br><span class="line">        transient int threshold;</span><br><span class="line"></span><br><span class="line">        final float loadFactor;</span><br><span class="line"></span><br><span class="line">        Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            this.loadFactor = lf;</span><br><span class="line">            this.threshold = threshold;</span><br><span class="line">            this.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Creates a new, empty map with a default initial capacity (16),</span><br><span class="line">* load factor (0.75) and concurrencyLevel (16).</span><br><span class="line">*/</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line">//static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 对于concurrencyLevel的理解, 可以理解为segments数组的长度，即理论上多线程并发数(分段锁), 默认16</span><br><span class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        // Find power-of-two sizes best matching arguments</span><br><span class="line">        int sshift = 0;</span><br><span class="line">        int ssize = 1;</span><br><span class="line">        // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span><br><span class="line">        // ssize = 2^sshift 即 ssize = 1 &lt;&lt; sshift</span><br><span class="line">        while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 段偏移量，32是因为hash是int值，int值32位，默认值情况下此时segmentShift = 28</span><br><span class="line">        this.segmentShift = 32 - sshift;</span><br><span class="line">        // 散列算法的掩码，默认值情况下segmentMask = 15, 定位segment的时候需要根据segment[]长度取模, 即hash(key)&amp;(ssize - 1)</span><br><span class="line">        this.segmentMask = ssize - 1;</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        // 计算每个segment中table的容量, 初始容量=16, 并发数=16。</span><br><span class="line">        int c = initialCapacity / ssize;</span><br><span class="line">        // 处理无法整除的情况，取上限</span><br><span class="line">        if (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        // MIN_SEGMENT_TABLE_CAPACITY默认时2，cap必须是2的n次方</span><br><span class="line">        int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        // 确保cap是2^n</span><br><span class="line">        while (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= 1;</span><br><span class="line">        // create segments and segments[0]</span><br><span class="line">        // 创建segments并初始化第一个segment数组,其余的segment延迟初始化</span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">        // 默认并发数=16</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br><span class="line">        this.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h4><p>put 方法实际上只有两步：1. 根据键的值定位键值对在那个 segment 片段 2. 调用 Segment 的 put 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s;</span><br><span class="line">      if (value == null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">//计算键的hash值</span><br><span class="line">      int hash = hash(key);</span><br><span class="line">//通过hash值运算把键值对定位到segment[j]片段上</span><br><span class="line">      int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">//检查segment[j]是否已经初始化了，没有的话调用ensureSegment初始化segment[j]</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br><span class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br><span class="line">          s = ensureSegment(j);</span><br><span class="line">//向片段中插入键值对</span><br><span class="line">      return s.put(key, hash, value, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;</span><br><span class="line">    int h = hashSeed;       // 这个 hashSeed 是和 虚拟机的参数有关.. 在不配置的情况下 默认为 0 . 我们就是用默认的分析吧</span><br><span class="line"></span><br><span class="line">    if ((0 != h) &amp;&amp; (k instanceof String)) &#123;    // 如果配置了参数.. 且是 String 类型的，就使用 hash32</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //k.hashCode ... 这里可以看出.. 虽然 key 没有明确判断不能为 null .. 但是 一旦是 null</span><br><span class="line">    // 这里就会空指针了...</span><br><span class="line">    h ^= k.hashCode ();      //hashmap 一样的操作..</span><br><span class="line"></span><br><span class="line">    // Spread bits to regularize both segment and index locations,</span><br><span class="line">    // using variant of single-word Wang/Jenkins hash.</span><br><span class="line">    </span><br><span class="line">    h += (h &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 10);</span><br><span class="line">    h += (h &lt;&lt;   3);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  6);</span><br><span class="line">    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ensureSegment(int k)<br>  我们从 ConcurrentHashMap 的构造函数可以发现 Segment 数组只初始化了 Segment [0], 其余的 Segment 是用到了再初始化，用了延迟加载的策略，而延迟加载调用的就是 ensureSegment 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">      final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">      long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">      Segment&lt;K,V&gt; seg;</span><br><span class="line">//按照segment[0]的HashEntry数组长度和加载因子初始化Segment[k]</span><br><span class="line">      if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</span><br><span class="line">          int cap = proto.table.length;</span><br><span class="line">          float lf = proto.loadFactor;</span><br><span class="line">          int threshold = (int)(cap * lf);</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">          if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">              == null) &#123; // recheck</span><br><span class="line">              Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">              while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                     == null) &#123;</span><br><span class="line">                  if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                      break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return seg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="put(K key, int hash, V value, boolean onlyIfAbsent)"></a>put(K key, int hash, V value, boolean onlyIfAbsent)</h4><p>调用 Segment 的 put 方法插入键值对到 Segment 的 HashEntry 数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">//Segment继承ReentrantLock，尝试获取独占锁</span><br><span class="line">      HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">              scanAndLockForPut(key, hash, value);</span><br><span class="line">      V oldValue;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">//定位键值对在HashEntry数组上的位置</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">//获取这个位置的第一个键值对</span><br><span class="line">          HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">              if (e != null) &#123;//此处有链表结构，一直循环到e==null</span><br><span class="line">                  K k;</span><br><span class="line">//存在与待插入键值对相同的键，则替换value</span><br><span class="line">                  if ((k = e.key) == key ||</span><br><span class="line">                          (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                      oldValue = e.value;</span><br><span class="line">                      if (!onlyIfAbsent) &#123;//onlyIfAbsent默认为false</span><br><span class="line">                          e.value = value;</span><br><span class="line">                          ++modCount;</span><br><span class="line">                      &#125;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">                  e = e.next;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">//node不为null,设置node的next为first，node为当前链表的头节点</span><br><span class="line">                  if (node != null)</span><br><span class="line">                      node.setNext(first);</span><br><span class="line">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span><br><span class="line">                  else</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                  int c = count + 1;</span><br><span class="line">//扩容条件 (1)entry数量大于阈值 (2) 当前数组tab长度小于最大容量。满足以上条件就扩容</span><br><span class="line">                  if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">//扩容</span><br><span class="line">                      rehash(node);</span><br><span class="line">                  else</span><br><span class="line">//tab的index位置设置为node,</span><br><span class="line">                      setEntryAt(tab, index, node);</span><br><span class="line">                  ++modCount;</span><br><span class="line">                  count = c;</span><br><span class="line">                  oldValue = null;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">场景：线程 A 和线程 B 同时执行相同 Segment 对象的 put 方法;</span><br><span class="line">线程 A 执行 tryLock () 方法成功获取锁，则把 HashEntry 对象插入到相应的位置;</span><br><span class="line">线程 B 获取锁失败，则执行 scanAndLockForPut () 方法，在 scanAndLockForPut 方法中，会通过重复执行 tryLock () 方法尝试获取锁，在多处理器环境下，重复次数为 64，单处理器重复次数为 1，当执行 tryLock () 方法的次数超过上限时，则执行 lock () 方法挂起线程 B;</span><br><span class="line">当线程 A 执行完插入操作时，会通过 unlock () 方法释放锁，接着唤醒线程 B 继续执行;</span><br></pre></td></tr></table></figure><ul><li><p>scanAndLockForPut(K key, int hash, V value)<br>在不超过最大重试次数 MAX_SCAN_RETRIES 通过 CAS 尝试获取锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">//first,e:键值对的hash值定位到数组tab的第一个键值对</span><br><span class="line">      HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">      HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">      HashEntry&lt;K,V&gt; node = null;</span><br><span class="line">      int retries = -1; // negative while locating node</span><br><span class="line">//线程尝试通过CAS获取锁</span><br><span class="line">      while (!tryLock()) &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt; f; // to recheck first below</span><br><span class="line">          if (retries &lt; 0) &#123;</span><br><span class="line">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span><br><span class="line">              if (e == null) &#123;</span><br><span class="line">                  if (node == null) // speculatively create node</span><br><span class="line">//初始化键值对，next指向null</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                  retries = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              else if (key.equals(e.key))</span><br><span class="line">                  retries = 0;</span><br><span class="line">              else</span><br><span class="line">                  e = e.next;</span><br><span class="line">          &#125;</span><br><span class="line">//超过最大自旋次数，阻塞</span><br><span class="line">          else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">              lock();</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">//头节点发生变化，重新遍历</span><br><span class="line">          else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                  (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">              e = first = f; // re-traverse if entry changed</span><br><span class="line">              retries = -1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>rehash(HashEntry&lt;K,V&gt; node)<br>用于对 Segment 的 table 数组进行扩容，扩容后的数组长度是原数组的两倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">//扩容前的旧tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">//扩容前数组长度</span><br><span class="line">      int oldCapacity = oldTable.length;</span><br><span class="line">//扩容后数组长度（扩容前两倍）</span><br><span class="line">      int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">//计算新的阈值</span><br><span class="line">      threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">//新的tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">              (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">//新的掩码</span><br><span class="line">      int sizeMask = newCapacity - 1;</span><br><span class="line">//遍历旧的数组</span><br><span class="line">      for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">//遍历数组的每一个元素</span><br><span class="line">          HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">//元素e指向的下一个节点，如果存在hash冲突那么e不为空</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//计算元素在新数组的索引</span><br><span class="line">              int idx = e.hash &amp; sizeMask;</span><br><span class="line">// 桶中只有一个元素，把当前的e设置给新的table</span><br><span class="line">              if (next == null)   //  Single node on list</span><br><span class="line">                  newTable[idx] = e;</span><br><span class="line">//桶中有布置一个元素的链表</span><br><span class="line">              else &#123; // Reuse consecutive sequence at same slot</span><br><span class="line">                  HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">// idx 是当前链表的头结点 e 的新位置</span><br><span class="line">                  int lastIdx = idx;</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                       last != null;</span><br><span class="line">                       last = last.next) &#123;</span><br><span class="line">//k是单链表元素在新数组的位置</span><br><span class="line">                      int k = last.hash &amp; sizeMask;</span><br><span class="line">                      //lastRun是最后一个扩容后不在原桶处的Entry</span><br><span class="line">                      if (k != lastIdx) &#123;</span><br><span class="line">                          lastIdx = k;</span><br><span class="line">                          lastRun = last;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">//lastRun以及它后面的元素都在一个桶中</span><br><span class="line">                  newTable[lastIdx] = lastRun;</span><br><span class="line">                  // Clone remaining nodes</span><br><span class="line">                  //遍历到lastRun即可</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                      V v = p.value;</span><br><span class="line">                      int h = p.hash;</span><br><span class="line">                      int k = h &amp; sizeMask;</span><br><span class="line">                      HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                      newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//处理引起扩容的那个待添加的节点</span><br><span class="line">      int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br><span class="line">      node.setNext(newTable[nodeIndex]);</span><br><span class="line">      newTable[nodeIndex] = node;</span><br><span class="line">//把Segment的table指向扩容后的table</span><br><span class="line">      table = newTable;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h4><p> get 获取元素不需要加锁，效率高，获取 key 定位到的 segment 片段还是遍历 table 数组的 HashEntry 元素时使用了 UNSAFE.getObjectVolatile 保证了能够无锁且获取到最新的 volatile 变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public V get(Object key) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</span><br><span class="line">      HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">//计算key的hash值</span><br><span class="line">      int h = hash(key);</span><br><span class="line">//根据hash值计算key在哪个segment片段</span><br><span class="line">      long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">//获取segments[u]的table数组</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">          (tab = s.table) != null) &#123;</span><br><span class="line">//遍历table中的HashEntry元素</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                   (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">               e != null; e = e.next) &#123;</span><br><span class="line">              K k;</span><br><span class="line">//找到相同的key，返回value</span><br><span class="line">              if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                  return e.value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>size 方法用来计算 ConcurrentHashMap 中储存元素的个数。那么在统计所有的 segment 元素的个数是否都需要上锁呢？如果不上锁在统计的过程中可能存在其他线程并发存储 / 删除元素，而如果上锁又会降低读写效率。ConcurrentHashMap 在实现时使用了折中的方法，它会无锁遍历三次把所有的 segment 的 modCount 加到 sum 里面，如果与前一次遍历结果相比 sum 没有改变那么说明这两次遍历没有其他线程修改 ConcurrentHashMap, 返回 segment 的 count 的和；如果每次遍历与上一次相比都不一样那就上锁进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> public int size() &#123;</span><br><span class="line">     // Try a few times to get accurate count. On failure due to</span><br><span class="line">     // continuous async changes in table, resort to locking.</span><br><span class="line">     final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">     int size;</span><br><span class="line">     boolean overflow; // true if size overflows 32 bits</span><br><span class="line">     long sum;         // sum of modCounts</span><br><span class="line">     long last = 0L;   // previous sum</span><br><span class="line">     int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">     try &#123;</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">//达到RETRIES_BEFORE_LOCK，也就是三次</span><br><span class="line">             if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                 for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                     ensureSegment(j).lock(); // force creation</span><br><span class="line">             &#125;</span><br><span class="line">             sum = 0L;</span><br><span class="line">             size = 0;</span><br><span class="line">             overflow = false;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                 Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">//遍历计算segment的modCount和count的和</span><br><span class="line">                 if (seg != null) &#123;</span><br><span class="line">                     sum += seg.modCount;</span><br><span class="line">                     int c = seg.count;</span><br><span class="line">//是否溢出int范围</span><br><span class="line">                     if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                         overflow = true;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">//last是上一次的sum值，相等跳出循环</span><br><span class="line">             if (sum == last)</span><br><span class="line">                 break;</span><br><span class="line">             last = sum;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">//解锁</span><br><span class="line">         if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                 segmentAt(segments, j).unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h4><p>调用 Segment 的 remove 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    return s == null ? null : s.remove(key, hash, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key-int-hash-Object-value"><a href="#remove-Object-key-int-hash-Object-value" class="headerlink" title="remove(Object key, int hash, Object value)"></a>remove(Object key, int hash, Object value)</h4><p>获取同步锁，移除指定的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  final V remove(Object key, int hash, Object value) &#123;</span><br><span class="line">//获取同步锁</span><br><span class="line">      if (!tryLock())</span><br><span class="line">          scanAndLock(key, hash);</span><br><span class="line">      V oldValue = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">          HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">//遍历链表用来保存当前链表节点的前一个节点</span><br><span class="line">          HashEntry&lt;K,V&gt; pred = null;</span><br><span class="line">          while (e != null) &#123;</span><br><span class="line">              K k;</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//找到key对应的键值对</span><br><span class="line">              if ((k = e.key) == key ||</span><br><span class="line">                      (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                  V v = e.value;</span><br><span class="line">//键值对的值与传入的value相等</span><br><span class="line">                  if (value == null || value == v || value.equals(v)) &#123;</span><br><span class="line">//当前元素为头节点，把当前元素的下一个节点设为头节点</span><br><span class="line">                      if (pred == null)</span><br><span class="line">                          setEntryAt(tab, index, next);</span><br><span class="line">//不是头节点，把当前链表节点的前一个节点的next指向当前节点的下一个节点</span><br><span class="line">                      else</span><br><span class="line">                          pred.setNext(next);</span><br><span class="line">                      ++modCount;</span><br><span class="line">                      --count;</span><br><span class="line">                      oldValue = v;</span><br><span class="line">                  &#125;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              pred = e;</span><br><span class="line">              e = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>scanAndLock(Object key, int hash)<br>扫描是否含有指定的 key 并且获取同步锁，当方法执行完毕也就是跳出循环肯定成功获取到同步锁，跳出循环有两种方式：1.tryLock 方法尝试获取独占锁成功 2. 尝试获取超过最大自旋次数 MAX_SCAN_RETRIES 线程堵塞，当线程从等待队列中被唤醒获取到锁跳出循环。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p>检查 ConcurrentHashMap 是否为空。同样没有使用同步锁，通过两次遍历：1. 确定每个 segment 是否为 0, 其中任何一个 segment 的 count 不为 0, 就返回，都为 0, 就累加 modCount 为 sum.2. 第一个循环执行完还没有推出，map 可能为空，再做一次遍历，如果在这个过程中任何一个 segment 的 count 不为 0 返回 false，同时 sum 减去每个 segment 的 modCount，若循环执行完程序还没有退出，比较 sum 是否为 0，为 0 表示两次检查没有元素插入，map 确实为空，否则 map 不为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">//累计segment的modCount值</span><br><span class="line">      long sum = 0L;</span><br><span class="line">      final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">      for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">          if (seg != null) &#123;</span><br><span class="line">              if (seg.count != 0)</span><br><span class="line">                  return false;</span><br><span class="line">              sum += seg.modCount;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//再次检查</span><br><span class="line">      if (sum != 0L) &#123; // recheck unless no modifications</span><br><span class="line">          for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">              Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">              if (seg != null) &#123;</span><br><span class="line">                  if (seg.count != 0)</span><br><span class="line">                      return false;</span><br><span class="line">                  sum -= seg.modCount;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (sum != 0L)</span><br><span class="line">              return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ConcurrentHashMap 引入分段锁的概念提高了并发量，每当线程要修改哈希表时并不是锁住整个表，而是去操作某一个 segment 片段，只对 segment 做同步，通过细化锁的粒度提高了效率，相对与 HashTable 对整个哈希表做同步处理更实用与多线程环境</p><p>segments 数组的大小仅在上述初始化创建代码中确定，一旦 map 创建成功后分段个数不会改变，每次扩容也只针对某个分段内的桶进行扩容。</p><p>[参考链接]<a href="https://www.cnblogs.com/rain4j/p/10972090.html" target="_blank" rel="noopener">https://www.cnblogs.com/rain4j/p/10972090.html</a></p><p>“$VIM/vimrc”<br>     user vimrc file: “$HOME/.vimrc”<br> 2nd user vimrc file: “<del>/.vim/vimrc”<br>      user exrc file: “$HOME/.exrc”<br>  system gvimrc file: “$VIM/gvimrc”<br>    user gvimrc file: “$HOME/.gvimrc”<br>2nd user gvimrc file: “</del>/.vim/gvimrc”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/16/jdk%E6%BA%90%E7%A0%81%E5%8C%85/"/>
    <id>http://yoursite.com/2020/07/16/jdk源码包/</id>
    <published>2020-07-16T11:57:10.000Z</published>
    <updated>2020-07-17T01:42:22.411Z</updated>
    
    <content type="html"><![CDATA[<h5 id="需要阅读的源码包"><a href="#需要阅读的源码包" class="headerlink" title="需要阅读的源码包"></a>需要阅读的源码包</h5><ul><li>1、java.lang<br>这里面其实就是Java的基本语法，比如各种基本包装类型（Integer、Long、Double等）、基本类（Object，Class，Enum，Exception，Thread）等等…</li><li>2、java.lang.annotation<br>包含Java注解基本元素相关的源码</li><li>3、java.lang.reflect<br>包含Java反射基本元素相关的代码</li><li>4、java.util<br>这里面放的都是Java的基本工具，最典型和常用的就是各种容器和集合（List、Map、Set）</li><li>5、java.util.concurrent<br>大名鼎鼎的JUC包，里面包含了Java并发和多线程编程相关的代码</li><li>6、java.util.function +java.util.stream<br>包含Java函数式编程的常见接口和代码</li><li>7、java.io<br>包含Java传统I/O相关的源码，主要是面向字节和流的I/O</li><li>8、java.nio<br>包含Java非阻塞I/O相关的源码，主要是面向缓冲、通道以及选择器的I/O</li><li>9、java.time<br>包含Java新日期和期间相关的代码，最典型的当属LocalDateTime、DateTimeFormatter等</li><li>10、java.math<br>主要包含一些高精度运算的支持数据类</li><li>11、java.math<br>主要包含一些高精度运算的支持数据类</li><li>12、java.net<br>主要包含Java网络通信（典型的如：Socket通信）相关的源代码。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;需要阅读的源码包&quot;&gt;&lt;a href=&quot;#需要阅读的源码包&quot; class=&quot;headerlink&quot; title=&quot;需要阅读的源码包&quot;&gt;&lt;/a&gt;需要阅读的源码包&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、java.lang&lt;br&gt;这里面其实就是Java的基本语法，比如各种基本包装
      
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别</title>
    <link href="http://yoursite.com/2020/07/13/jdk1.7%E5%92%8C1.8%E4%B8%ADConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/13/jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别/</id>
    <published>2020-07-13T11:57:10.000Z</published>
    <updated>2020-07-15T02:55:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-在-JDK8-与-JDK7-中的区别"><a href="#HashMap-在-JDK8-与-JDK7-中的区别" class="headerlink" title="HashMap 在 JDK8 与 JDK7 中的区别"></a>HashMap 在 JDK8 与 JDK7 中的区别</h3><ul><li>插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。</li><li>JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）</li><li>扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。</li><li>JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移</li></ul><a id="more"></a><h3 id="ConcurrentHashMap-在-JDK7-与-JDK8-中的区别"><a href="#ConcurrentHashMap-在-JDK7-与-JDK8-中的区别" class="headerlink" title="ConcurrentHashMap 在 JDK7 与 JDK8 中的区别"></a>ConcurrentHashMap 在 JDK7 与 JDK8 中的区别</h3><ul><li><p>ConcurrentHashMap 在 jdk8 中初始化采用了延迟初始化策略，他会在第一次执行 put 的时候初始化 table。</p></li><li><p>JDK7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK8 采用 CAS (读)+Synchronized (写) 保证线程安全。</p></li><li><p>锁的粒度：原来是对需要进行数据操作的 Segment 加锁，JDK8 调整为对每个数组元素加锁（Node）。</p></li><li><p>链表转化为红黑树：定位结点的 hash 算法简化会带来弊端，Hash 冲突加剧，因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。</p></li><li><p>查询时间复杂度：从原来的遍历链表 O (n)，变成遍历红黑树 O (logN)。</p></li><li><p>JDK8 推荐使用 mappingCount 方法而不是 size 方法获取当前 map 表的大小，因为这个方法的返回值是 long 类型，size 方法是返回值类型是 int</p></li></ul><h3 id="ConcurrentHashMap-与-HashMap-相比，有以下不同点"><a href="#ConcurrentHashMap-与-HashMap-相比，有以下不同点" class="headerlink" title="ConcurrentHashMap 与 HashMap 相比，有以下不同点"></a>ConcurrentHashMap 与 HashMap 相比，有以下不同点</h3><ul><li>ConcurrentHashMap 线程安全，而 HashMap 非线程安全;</li><li>HashMap 允许 Key 和 Value 为 null，而 ConcurrentHashMap 不允许;</li><li>HashMap 迭代器是强一致性，ConcurrentHashMap 迭代器是弱一致性，HashMap 不允许通过 Iterator 遍历的同时通过 HashMap 修改，而 ConcurrentHashMap 允许该行为，并且该更新对后续的遍历可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-在-JDK8-与-JDK7-中的区别&quot;&gt;&lt;a href=&quot;#HashMap-在-JDK8-与-JDK7-中的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap 在 JDK8 与 JDK7 中的区别&quot;&gt;&lt;/a&gt;HashMap 在 JDK8 与 JDK7 中的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。&lt;/li&gt;
&lt;li&gt;JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）&lt;/li&gt;
&lt;li&gt;扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。&lt;/li&gt;
&lt;li&gt;JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hashmap扩容浅谈</title>
    <link href="http://yoursite.com/2020/07/12/hashmap%E6%89%A9%E5%AE%B9%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/07/12/hashmap扩容浅谈/</id>
    <published>2020-07-12T11:57:10.000Z</published>
    <updated>2020-07-13T09:57:16.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-7-中Hashmap扩容机制"><a href="#Java-7-中Hashmap扩容机制" class="headerlink" title="Java 7 中Hashmap扩容机制"></a>Java 7 中Hashmap扩容机制</h3><h5 id="一、什么时候扩容："><a href="#一、什么时候扩容：" class="headerlink" title="一、什么时候扩容："></a>一、什么时候扩容：</h5><p>扩容必须满足两个条件：<br>1、 存放新值的时候当前已有元素的个数必须大于等于阈值<br>2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</p><a id="more"></a><h5 id="二、下面我们看源码，如下："><a href="#二、下面我们看源码，如下：" class="headerlink" title="二、下面我们看源码，如下："></a>二、下面我们看源码，如下：</h5><p>首先是put()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　　　//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span><br><span class="line">　　　　if (table == EMPTY_TABLE) &#123;</span><br><span class="line">　　　　　　inflateTable(threshold);//如果为空，则初始化</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　//判断key是否为空</span><br><span class="line">　　　　if (key == null)</span><br><span class="line">　　　　　　return putForNullKey(value);//hashmap允许key为空</span><br><span class="line">　　　　</span><br><span class="line">　　　　//计算当前key的哈希值　　　　</span><br><span class="line">　　　　int hash = hash(key);</span><br><span class="line">　　　　//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span><br><span class="line">　　　　int i = indexFor(hash, table.length);</span><br><span class="line">　　　　for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">　　　　　　Object k;</span><br><span class="line">　　　　　　//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span><br><span class="line">　　　　　　if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">　　　　　　　　V oldValue = e.value;</span><br><span class="line">　　　　　　　　e.value = value;</span><br><span class="line">　　　　　　　　e.recordAccess(this);</span><br><span class="line">　　　　　　　　return oldValue;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　modCount++;</span><br><span class="line">　　　　//存放值的具体方法</span><br><span class="line">　　　　addEntry(hash, key, value, i);</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在put()方法中有调用addEntry()方法，这个方法里面是具体的存值，在存值之前还要判断是否需要扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">　　　　//1、判断当前个数是否大于等于阈值</span><br><span class="line">　　　　//2、当前存放是否发生哈希碰撞</span><br><span class="line">　　　　//如果上面两个条件否发生，那么就扩容</span><br><span class="line">　　　　if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　//扩容，并且把原来数组中的元素重新放到新数组中</span><br><span class="line">　　　　　　resize(2 * table.length);</span><br><span class="line">　　　　　　hash = (null != key) ? hash(key) : 0;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">如果需要扩容，调用扩容的方法resize()</span><br></pre></td></tr></table></figure><p>void resize(int newCapacity) {<br>　　　　Entry[] oldTable = table;<br>　　　　int oldCapacity = oldTable.length;<br>　　　　//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作<br>　　　　if (oldCapacity == MAXIMUM_CAPACITY) {<br>　　　　　　threshold = Integer.MAX_VALUE;<br>　　　　　　return;<br>　　　　}</p><p>　　　　Entry[] newTable = new Entry[newCapacity];<br>　　　　// transfer()方法把原数组中的值放到新数组中<br>　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>　　　　//设置hashmap扩容后为新的数组引用<br>　　　　table = newTable;<br>　　　　//设置hashmap扩容新的阈值<br>　　　　threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer()在实际扩容时候把原来数组中的元素放入新的数组中</span><br></pre></td></tr></table></figure><p>void transfer(Entry[] newTable, boolean rehash) {<br>　　　　int newCapacity = newTable.length;<br>　　　　for (Entry&lt;K,V&gt; e : table) {<br>　　　　　　while(null != e) {<br>　　　　　　　　Entry&lt;K,V&gt; next = e.next;<br>　　　　　　　　if (rehash) {<br>　　　　　　　　　　e.hash = null == e.key ? 0 : hash(e.key);<br>　　　　　　　　}<br>　　　　　　　　//通过key值的hash值和新数组的大小算出在当前数组中的存放位置<br>　　　　　　　　int i = indexFor(e.hash, newCapacity);<br>　　　　　　　　e.next = newTable[i];<br>　　　　　　　　newTable[i] = e;<br>　　　　　　　　e = next;<br>　　　　　　}<br>　　　　}<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 三、总结：</span><br><span class="line"></span><br><span class="line">Hashmap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</span><br><span class="line">因为上面这两个条件，所以存在下面这些情况</span><br><span class="line">&gt;&gt; 就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</span><br><span class="line"></span><br><span class="line">&gt;&gt; 当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（虽然hash冲突，但是这时元素个数小于阈值12，并没有同时满足扩容的两个条件。所以不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，也没有同时满足扩容的两个条件，所以叶不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java 8 中Hashmap扩容机制</span><br><span class="line"></span><br><span class="line">##### 一、Java8的扩容机制：</span><br><span class="line">Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：当前存放新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">&gt;&gt;（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,&quot;zhangsan&quot;），而map里面原有数据&lt;&quot;name&quot;,&quot;lisi&quot;&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</span><br><span class="line"></span><br><span class="line">&gt;&gt;（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</span><br><span class="line">##### 二、背景知识：</span><br><span class="line"></span><br><span class="line">　　Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key/value值，还存了后一个Entry对的地址。</span><br><span class="line"></span><br><span class="line">　　Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但是数组的对象以前是Entry对，现在换成了Node对象（可以理解是Entry对，结构一样，存储时也会存key/value键值对、后一个Node的地址），以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树。</span><br><span class="line"></span><br><span class="line">##### 三、源码：</span><br><span class="line"></span><br><span class="line">　　在jdk7中，当new Hashmap()的时候会对对象进行初始化，而jdk8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。</span><br></pre></td></tr></table></figure><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><p>复制代码<br>    /**<br>     * Implements Map.put and related methods<br>     *<br>     * @param hash key值计算传来的下标<br>     * @param key<br>     * @param value<br>     * @param onlyIfAbsent true只是在值为空的时候存储数据，false都存储数据<br>     * @param evict<br>     * @return 返回被覆盖的值，如果没有覆盖则返回null<br>     */<br>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        // 申明entry数组对象tab[]:当前Entry[]对象<br>        Node&lt;K,V&gt;[] tab;<br>        // 申明entry对象p:这里表示存放的单个节点<br>        Node&lt;K,V&gt; p;<br>        // n:为当前Entry对象长度<br>　　　　 // i:为当前存放对象节点的位置下标<br>        int n, i;</p><pre><code>    /**     * 流程判断     * 1、如果当前Node数组(tab)为空，则直接创建(通过resize()创建)，并将当前创建后的长度设置给n     * 2、如果要存放对象所在位置的Node节点为空，则直接将对象存放位置创建新Node，并将值直接存入     * 3、存放的Node数组不为空，且存放的下标节点Node不为空（该Node节点为链表的首节点）     *   1）比较链表的首节点存放的对象和当前存放对象是否为同一个对象，如果是则直接覆盖并将原来的值返回     *   2）如果不是分两种情况     *      （1）存储处节点为红黑树node结构，调用方法putTreeVal()直接将数据插入     *      （2）不是红黑树，则表示为链表，则进行遍历     *          A.如果存入的链表下一个位置为空，则先将值直接存入，存入后检查当前存入位置是否已经大于链表的第8个位置     *              a.如果大于,调用treeifyBin方法判断是扩容 还是 需要将该链表转红黑树（大于8且总数据量大于64则转红黑色，否则对数组进行扩容）     *              b.当前存入位置链表长度没有大于8，则存入成功，终端循环操作。     *          B.如果存入链表的下一个位置有值，且该值和存入对象“一样”，则直接覆盖，并将原来的值返回     *          上面AB两种情况执行完成后，判断返回的原对象是否为空，如果不为空，则将原对象的原始value返回     * 上面123三种情况下，如果没有覆盖原值，则表示新增存入数据，存储数据完成后，size+1,然后判断当前数据量是否大于阈值，     * 如果大于阈值，则进行扩容。     */    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            // 按照红黑树直接将数据存入            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);//该方法判断是扩容还是需要将该链表转红黑树                    break;                }                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 如果不是替换数据存入，而是新增位置存入后，则将map的size进行加1，然后判断容量是否超过阈值，超过则扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treeifyBin()方法判断是扩容还是将当前链表转红黑树</span><br></pre></td></tr></table></figure><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * 从指定hash位置处的链表nodes头部开始，全部替换成红黑树结构。 * 除非整个数组对象（Map集合）数据量很小（小于64），该情况下则通过resize()对这个Map进行扩容，而代替将链表转红黑树的操作。 */final void treeifyBin(HashMap.Node&lt;K,V&gt;[] tab, int hash) {    int n, index; HashMap.Node&lt;K,V&gt; e;    // 如果Map为空或者当前存入数据n（可以理解为map的size()）的数量小于64便进行扩容    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    // 如果size()大于64则将正在存入的该值所在链表转化成红黑树    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        HashMap.TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            HashMap.TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><p>```</p><h5 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h5><p>1）Java 8 在新增数据存入成功后进行扩容<br>2）扩容会发生在两种情况下（满足任意一种条件即发生扩容）：<br>   a 当前存入数据大于阈值即发生扩容<br>   b 存入数据到某一条链表上，此时数据大于8，且总数量小于64即发生扩容<br>3）此外需要注意一点java7是在存入数据前进行判断是否扩容，而java8是在存入数据库在进行扩容的判断。</p><p>ConcurrentHashMap知识参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html" target="_blank" rel="noopener">https://www.cnblogs.com/zerotomax/p/8687425.html</a></p><p>Java8 HashMap扩容可参考：<a href="https://blog.csdn.net/goosson/article/details/81029729" target="_blank" rel="noopener">https://blog.csdn.net/goosson/article/details/81029729</a> （注：该文章中关于Java8 底层数据结构描述不准确，只有当数据量大于64才会有红黑树+链表）</p><p>这里补充一下jdk8关于红黑树和链表的知识：</p><p>　　第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;=7,从0开始，及第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p><p>[参考链接]<a href="https://www.cnblogs.com/yanzige/p/8392142.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanzige/p/8392142.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-7-中Hashmap扩容机制&quot;&gt;&lt;a href=&quot;#Java-7-中Hashmap扩容机制&quot; class=&quot;headerlink&quot; title=&quot;Java 7 中Hashmap扩容机制&quot;&gt;&lt;/a&gt;Java 7 中Hashmap扩容机制&lt;/h3&gt;&lt;h5 id=&quot;一、什么时候扩容：&quot;&gt;&lt;a href=&quot;#一、什么时候扩容：&quot; class=&quot;headerlink&quot; title=&quot;一、什么时候扩容：&quot;&gt;&lt;/a&gt;一、什么时候扩容：&lt;/h5&gt;&lt;p&gt;扩容必须满足两个条件：&lt;br&gt;1、 存放新值的时候当前已有元素的个数必须大于等于阈值&lt;br&gt;2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hashmap中hash方法的一些看法</title>
    <link href="http://yoursite.com/2020/07/11/hashmap%E4%B8%ADhash%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/11/hashmap中hash方法的一些看法/</id>
    <published>2020-07-11T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:19.968Z</updated>
    
    <content type="html"><![CDATA[<p>hashcode一般用 int 来表示，32 位。<br>下面两个 hashcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">只有第 32 位（从右到左）不一样;</span><br></pre></td></tr></table></figure><p>在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.</p><a id="more"></a><p>大家又知道，hashcode 对 8 取模，效果等同于 hashcode &amp; (8 - 1)。</p><p>那么，前面的 A 和 （8 - 1）相与的结果如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">结果为 7，也就是，会放进 array [7]。</span><br></pre></td></tr></table></figure><p>大家再看 B 的计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">虽然 B 的第 32 位为 1,前面的高位，全是 0。</span><br></pre></td></tr></table></figure><p>所以，问题明白了吗，我们计算出来的 hashcode，低位相同，高位不同；但是，因为和我们进行与计算的队友太过垃圾，导致我们出现了 hash 冲突。</p><h5 id="怎么来解决这个问题呢？"><a href="#怎么来解决这个问题呢？" class="headerlink" title="怎么来解决这个问题呢？"></a>怎么来解决这个问题呢？</h5><p>我们能不能把高位也参与计算呢？自然，是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hashmap 中如何优化</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">这里，其实分了 3 个步骤：</span><br><span class="line"></span><br><span class="line">&gt;&gt; 计算 hashcode，作为操作数 1</span><br><span class="line"></span><br><span class="line">&gt;&gt; h = key.hashCode()</span><br><span class="line">&gt;&gt; 将第一步的 hashcode，右移 16 位，作为操作数 2</span><br><span class="line"></span><br><span class="line">&gt;&gt; h &gt;&gt;&gt; 16</span><br><span class="line">&gt;&gt; 操作数 1 和 操作数 2 进行异或操作，得到最终的 hashcode</span><br><span class="line"></span><br><span class="line">还是拿前面的来算，</span><br></pre></td></tr></table></figure><p>0111 1111 1111 1111 1111 1111 1111 1111  ——A<br>0000 0000 0000 0000 0111 1111 1111 1111   —– A &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>这里算出来的结果是 2147450880，再去对 7 进行与运算：</p><p>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 8 -1<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  —— 0<br>这里的 A，算出来，依然在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再拿 B 来算一下：</span><br></pre></td></tr></table></figure><p>1111 1111 1111 1111 1111 1111 1111 1111  —— B<br>0000 0000 0000 0000 1111 1111 1111 1111   —– B &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>1111 1111 1111 1111 0000 0000 0000 0000    — -65536<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 7<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  ——- 0<br>最终算出来为 0，所以，应该放在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里两个虽然算出来都是array[0](只是凑巧)</span><br><span class="line"></span><br><span class="line">下边提供下源代码：</span><br></pre></td></tr></table></figure><p>public class BinaryTest {<br>    public static void main(String[] args) {<br>        int a = 0b00001111111111111111111111111011;<br>        int b = 0b10001101111111111111110111111011;</p><pre><code>    int i = tabAt(32, a);    System.out.println(&quot;index for a:&quot; + i);    i = tabAt(32, b);    System.out.println(&quot;index for b:&quot; + i);}static final int tabAt(int  arraySize, int hash) {    int h = hash;    int finalHashCode = h ^ (h &gt;&gt;&gt; 16);    int i = finalHashCode &amp; (arraySize - 1);    return i;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虽然说，我测试了几个数字，还是有些冲突，但是，你把高 16 位弄进来参与计算，总比你不弄进来计算要好吧。</span><br><span class="line"></span><br><span class="line">大家也可以看看 hashmap 中，hash 方法的注释：</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Computes key.hashCode() and spreads (XORs) higher bits of hash</li><li>to lower.  Because the table uses power-of-two masking, sets of</li><li>hashes that vary only in bits above the current mask will</li><li>always collide. (Among known examples are sets of Float keys</li><li>holding consecutive whole numbers in small tables.)  So we</li><li>apply a transform that spreads the impact of higher bits</li><li>downward. There is a tradeoff between speed, utility, and</li><li>quality of bit-spreading. Because many common sets of hashes</li><li>are already reasonably distributed (so don’t benefit from</li><li>spreading), and because we use trees to handle large sets of</li><li>collisions in bins, we just XOR some shifted bits in the</li><li>cheapest possible way to reduce systematic lossage, as well as</li><li>to incorporate impact of the highest bits that would otherwise</li><li>never be used in index calculations because of table bounds.</li><li>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">里面提到了 2 点：</span><br></pre></td></tr></table></figure></li></ul><p>So we apply a transform that spreads the impact of higher bits downward.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，我们进行了一个转换，把高位的作用利用起来。</span><br></pre></td></tr></table></figure><p>we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as<br>to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们仅仅异或了从高位移动下来的二进制位，用最经济的方式，削减系统性能损失，同样，因为数组大小的限制，导致高位在索引计算中一直用不到，我们通过这种转换将其利用起来。</span><br><span class="line"></span><br><span class="line">#### ConcurrentHashMap 如何优化</span><br><span class="line">在 concurrentHashMap 中，其主要是：</span><br></pre></td></tr></table></figure><p>final V putVal(K key, V value, boolean onlyIfAbsent) {<br>    if (key == null || value == null) throw new NullPointerException();<br>    int hash = spread(key.hashCode());</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里主要是使用 spread 方法来计算 hash 值：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家如果要仔细观察每一步的二进制，可以使用下面的 demo：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    // 1<br>    String s = Integer.toBinaryString(h);<br>    System.out.println(“h:” + s);</p><pre><code>// 2String lower16Bits = Integer.toBinaryString(h &gt;&gt;&gt; 16);System.out.println(&quot;lower16Bits:&quot; + lower16Bits);// 3int temp = h ^ (h &gt;&gt;&gt; 16);System.out.println(&quot;h ^ (h &gt;&gt;&gt; 16):&quot; + Integer.toBinaryString(temp));// 4int result = (temp) &amp; HASH_BITS;System.out.println(&quot;final:&quot; + Integer.toBinaryString(result));return result;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里和 HashMap 相比，多了点东西，也就是多出来了：</span><br></pre></td></tr></table></figure><p>&amp; HASH_BITS;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 (h ^ (h &gt;&gt;&gt; 16)) 计算出来的 hashcode，可能是负数。这里，和 HASH_BITS 进行了相与：</span><br></pre></td></tr></table></figure><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash<br>1111 1111 1111 1111 1111 1111 1111 1111   假设计算出来的hashcode为负数，因为第32位为1<br>0111 1111 1111 1111 1111 1111 1111 1111       0x7fffffff<br>    进行相与<br>0111 …………………………….    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​这里，第 32 位，因为 0x7fffffff 的第 32 位，总为 0，所以相与后的结果，第 32 位也总为 0 ，所以，这样的话，hashcode 就总是正数了，不会是负数。</span><br><span class="line"></span><br><span class="line">***concurrentHashMap 中，node 的 hashcode，为啥不能是负数***</span><br><span class="line">当 hashcode 为正数时，表示该哈希桶为正常的链表结构。</span><br><span class="line">当 hashcode 为负数时，有几种情况：</span><br><span class="line"></span><br><span class="line">***ForwardingNode***</span><br><span class="line">此时，其 hash 值为：</span><br></pre></td></tr></table></figure><p>static final int MOVED     = -1; // hash for forwarding nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当节点为 ForwardingNode 类型时（表示哈希表在扩容进行中，该哈希桶已经被迁移到了新的临时 hash 表，此时，要 get 的话，需要去临时 hash 表查找；要 put 的话，是不行的，会帮助扩容）</span><br><span class="line"></span><br><span class="line">***TreeBin***</span><br></pre></td></tr></table></figure><p>static final int TREEBIN   = -2; // hash for roots of trees</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示，该哈希桶，已经转了红黑树。</span><br><span class="line"></span><br><span class="line">***扩容时的位运算***</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Returns the stamp bits for resizing a table of size n.</li><li>Must be negative when shifted left by RESIZE_STAMP_SHIFT.</li><li>/<br>static final int resizeStamp(int n) {<br>   return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这里，假设，n 为 4，即，hashmap 中数组容量为 4.</span><br><span class="line"></span><br><span class="line">+ 下面这句，求 4 的二进制表示中，前面有多少个 0.</span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(n)</span><br><span class="line"></span><br><span class="line">表示为 32 位后，如下</span><br><span class="line"></span><br><span class="line">0000 0000 0000 0000, 0000 0000 0000 0100</span><br><span class="line"></span><br><span class="line">所以，前面有 29 个 0，即，这里的结果为 29.</span><br><span class="line"></span><br><span class="line">+ (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)</span><br><span class="line"></span><br><span class="line">这一句呢，其中 RESIZE_STAMP_BITS 是个常量，为 16. 相当于，把 1 向左移动 15 位。</span><br><span class="line"></span><br><span class="line">二进制为：</span><br></pre></td></tr></table></figure></li></ul><p>1000 0000 0000 0000   – 1 &lt;&lt; 15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 0000 0000 0001 1101   – 29<br>0000 0000 0000 0000 1000 0000 0000 0000   – 1 &lt;&lt; 15<br>进行或运算<br>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以，最终结果是，</span><br><span class="line">![](hashmap中hash方法的一些看法/aaa.png)</span><br><span class="line"></span><br><span class="line">这个数，换算为 10 进制，为 32972，是个正数。</span><br><span class="line">这个数，有啥用呢？</span><br><span class="line">在 addCount 函数中，当整个哈希表的键值对数量，超过 sizeCtl 时（一般为 0.75 * 数组长度），就会触发扩容。</span><br></pre></td></tr></table></figure><p>java.util.concurrent.ConcurrentHashMap#addCount</p><p>int sc =  sizeCtl;<br>boolean bSumExteedSizeControl = newBaseCount &gt;= (long) sc;<br>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1 处，如果扩容条件满足</span><br><span class="line"></span><br><span class="line">+ 2 处，如果 sc 小于 0，这个 sc 是啥，就是前面说的 sizeCtl，此时应该是等于：0.75 * 数组长度，不可能为负数</span><br><span class="line"></span><br><span class="line">+ 3 处，将 sc（此时为正数），cas 修改为：</span><br></pre></td></tr></table></figure><p>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个数有点意思了，rs 就是前面我们的 resizeStamp 得到的结果。</span><br><span class="line"></span><br><span class="line">按照前面的 demo，我们拿到的结果为：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为</span><br></pre></td></tr></table></figure><p>private static int RESIZE_STAMP_BITS = 16;<br>private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;<br>所以，RESIZE_STAMP_SHIFT 为 16.</p><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。<br>1000 0000 0001 1101 0000 0000 0000 0000 —   左移16位，即   rs &lt;&lt; RESIZE_STAMP_SHIFT<br>1000 0000 0001 1101 0000 0000 0000 0010    – (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)<br>最终，这个数，第一位是 1，说明了，这个数，肯定是负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大家如果看过其他人写的资料，也就知道，当 sizeCtl 为负数时，表示正在扩容。</span><br><span class="line"></span><br><span class="line">所以，这里</span><br></pre></td></tr></table></figure><p>if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这句话就是，如果当前线程成功地，利用 cas，将 sizeCtl 从正数，变成负数，就可以进行扩容。</span><br><span class="line"></span><br><span class="line">扩容时，其他线程怎么执行</span><br></pre></td></tr></table></figure><p>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        // 2.1<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        // 2.2<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><pre><code>此时，因为上面的线程触发了扩容，sc 已经变成了负数了，此时，新的线程进来，会判断 2 处。2 处是满足的，会进入 2.1 处判断，这里的部分条件看不懂，大概是：扩容已经结束，就不再执行，直接 break否则，进入 2.2 处，辅助扩容，同时，把 sc 变成 sc + 1，增加扩容线程数。[参考链接]http://iambigboss.top/post/73353_1_1.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashcode一般用 int 来表示，32 位。&lt;br&gt;下面两个 hashcode:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0111 1111 1111 1111 1111 1111 1111 1111  ------A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1111  ------B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;只有第 32 位（从右到左）不一样;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2020/07/10/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/10/HashMap详解/</id>
    <published>2020-07-10T11:57:10.000Z</published>
    <updated>2020-07-15T02:45:13.929Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//默认的初始化容量为16，必须是2的n次幂</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">//最大容量为 2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。</span><br><span class="line">//为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。</span><br><span class="line">//若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，</span><br><span class="line">//若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">//当红黑树上的元素个数，减少到6个时，就退化为链表</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。</span><br><span class="line">//这是为了避免，数组扩容和树化阈值之间的冲突。</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">//存放所有Node节点的数组</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">//存放所有的键值对</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">//map中的实际键值对个数，即数组中元素个数</span><br><span class="line">transient int size;</span><br><span class="line">//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。</span><br><span class="line">//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。</span><br><span class="line">transient int modCount;</span><br><span class="line">//数组扩容阈值</span><br><span class="line">int threshold;</span><br><span class="line">//加载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line">//普通单向链表节点类</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span><br><span class="line">final int hash;</span><br><span class="line">final K key;</span><br><span class="line">V value;</span><br><span class="line">//指向单链表的下一个节点</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">this.hash = hash;</span><br><span class="line">this.key = key;</span><br><span class="line">this.value = value;</span><br><span class="line">this.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//转化为红黑树的节点类</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">//当前节点的父节点</span><br><span class="line">TreeNode&lt;K,V&gt; parent;  </span><br><span class="line">//左孩子节点</span><br><span class="line">TreeNode&lt;K,V&gt; left;</span><br><span class="line">//右孩子节点</span><br><span class="line">TreeNode&lt;K,V&gt; right;</span><br><span class="line">//指向前一个节点</span><br><span class="line">TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">//当前节点是红色或者黑色的标识</span><br><span class="line">boolean red;</span><br><span class="line">TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">super(hash, key, val, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="hash-计算原理"><a href="#hash-计算原理" class="headerlink" title="hash()计算原理"></a>hash()计算原理</h4><p>前面 put 方法中说到，需要先把当前 key 进行哈希处理，我们看下这个方法是怎么实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，会先判断 key 是否为空，若为空则返回 0。这也说明了 hashMap 是支持 key 传 null 的。若非空，则先计算 key 的 hashCode 值，赋值给 h，然后把 h 右移 16 位，并与原来的 h 进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>我们知道，hashCode () 方法继承自父类 Object，它返回的是一个 int 类型的数值，可以保证同一个应用单次执行的每次调用，返回结果都是相同的（这个说明可以在 hashCode 源码上找到），这就保证了 hash 的确定性。在此基础上，再进行某些固定的运算，肯定结果也是可以确定的。</p><p>我随便运行一段程序，把它的 hashCode 的二进制打印出来，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object o = new Object();</span><br><span class="line">    int hash = o.hashCode();</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">    System.out.println(Integer.toBinaryString(hash));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//1836019240</span><br><span class="line">//1101101011011110110111000101000</span><br></pre></td></tr></table></figure><p>然后，进行 (h = key.hashCode ()) ^ (h &gt;&gt;&gt; 16) 这一段运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//h原来的值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//无符号右移16位，其实相当于把低位16位舍去，只保留高16位</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">//然后高16位和原 h进行异或运算</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">^</span><br><span class="line">0000 0000 0000 0000 0110 1101 0110 1111</span><br><span class="line">=</span><br><span class="line">0110 1101 0110 1111 0000 0011 0100 0111</span><br></pre></td></tr></table></figure><p>可以看到，其实相当于，我们把高 16 位值和当前 h 的低 16 位进行了混合，这样可以尽量保留高 16 位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p><strong>(n-1) &amp; hash 作用</strong><br>//②<br>//这是 put 方法中用来根据hash()值寻找在数组中的下标的逻辑，<br>//n为数组长度， hash为调用 hash()方法混合处理之后的hash值。<br>i = (n - 1) &amp; hash<br>我们知道，如果给定某个数值，去找它在某个数组中的下标位置时，直接用模运算就可以了（假设数组值从 0 开始递增）。如，我找 14 在数组长度为 16 的数组中的下标，即为 14 % 16，等于 14 。 18 的位置即为 18%16，等于 2。</p><p>而②中，就是取模运算的位运算形式。以 18%16 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//18的二进制</span><br><span class="line">0001 0010</span><br><span class="line">//16 -1 即 15的二进制</span><br><span class="line">0000 1111</span><br><span class="line">//与运算之后的结果为</span><br><span class="line">0000 0010</span><br><span class="line">// 可以看到，上边的结果转化为十进制就是 2 。</span><br><span class="line">//其实我们会发现一个规律，因为n是2的n次幂，因此它的二进制表现形式肯定是类似于</span><br><span class="line">0001 0000</span><br><span class="line">//这样的形式，只有一个位是1，其他位都是0。而它减 1 之后的形式就是类似于</span><br><span class="line">0000 1111 </span><br><span class="line">//这样的形式，高位都是0，低位都是1，因此它和任意值进行与运算，结果值肯定在这个区间内</span><br><span class="line">0000 0000  ~  0000 1111</span><br><span class="line">//也就是0到15之间，（以n为16为例）</span><br><span class="line">//因此，这个运算就可以实现取模运算，而且位运算还有个好处，就是速度比较快。</span><br></pre></td></tr></table></figure><p><strong>为什么高低位异或运算可以减少哈希碰撞</strong></p><p>我们想象一下，假如用 key 原来的 hashCode 值，直接和 (n-1) 进行与运算来求数组下标，而不进行高低位混合运算，会产生什么样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//例如我有另外一个h2，和原来的 h相比较，高16位有很大的不同，但是低16位相似度很高，甚至相同的话。</span><br><span class="line">//原h值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 1000</span><br><span class="line">//另外一个h2值</span><br><span class="line">0100 0101 1110 1011 0110 0110 0010 1000</span><br><span class="line">// n -1 ,即 15 的二进制</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">//可以发现 h2 和 h 的高位不相同，但是低位相似度非常高。</span><br><span class="line">//他们分别和 n -1 进行与运算时，得到的结果却是相同的。（此处n假设为16）</span><br><span class="line">//因为 n-1 的高16位都是0，不管 h 的高 16 位是什么，与运算之后，都不影响最终结果，高位一定全是 0</span><br><span class="line">//因此，哈希碰撞的概率就大大增加了，并且 h 的高16 位特征全都丢失了。</span><br></pre></td></tr></table></figure><p>有同学可能就会有疑问了，我进行高低 16 位混合运算，是可以的，这样可以保证尽量减少高区位的特征。那么，为什么选择用异或运算呢，我用与、或、非运算不行吗？</p><p>这是有一定的道理的。我们看一个表格，就能明白了。</p><ul><li><p>与运算，0和1的比例3：1<br>0 1 0 1<br>&amp; 1 0 1 0<br>0 0 0 1</p></li><li><p>或运算，0和1的比例1：3<br>0 1 0 1<br>| 1 0 1 0<br>1 1 0 1</p></li><li><p>异或运算，0和1的比例1：1<br>0 1 0 1<br>^ 1 0 0 1<br>1 1 0 0</p></li></ul><p>可以看到两个值进行与运算，结果会趋向于 0；或运算，结果会趋向于 1；而只有异或运算，0 和 1 的比例可以达到 1:1 的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</p><p>所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了。</p><p>以上，就是为什么要对一个 hash 值进行高低位混合，并且选择异或运算来混合的原因。</p><h4 id="如何确保-key-的唯一性"><a href="#如何确保-key-的唯一性" class="headerlink" title="如何确保 key 的唯一性"></a>如何确保 key 的唯一性</h4><p>HashMap 中不允许存在相同的 key 的，那怎么保证 key 的唯一性呢，判断的代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure><p>首先通过 hash 算法算出的值必须相等，算出的结果是 int，所以可以用 == 符号判断。只是这个条件可不行，要知道哈希碰撞是什么意思，有可能两个不一样的 key 最后产生的 hash 值是相同的。</p><p>并且待插入的 key == 当前索引已存在的 key，或者 待插入的 key.equals (当前索引已存在的 key)，注意 == 和 equals 是或的关系。== 符号意味着这是同一个对象， equals 用来确定两个对象内容相同。</p><p>如果 key 是基本数据类型，比如 int，那相同的值肯定是相等的，并且产生的 hashCode 也是一致的。</p><p>String 类型算是最常用的 key 类型了，我们都知道相同的字符串产生的 hashCode 也是一样的，并且字符串可以用 equals 判断相等。</p><p>但是如果用引用类型当做 key 呢，比如我定义了一个 MoonKey 作为 key 值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MoonKey &#123;</span><br><span class="line"></span><br><span class="line">    private String keyTile;</span><br><span class="line"></span><br><span class="line">    public String getKeyTile() &#123;</span><br><span class="line">        return keyTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyTile(String keyTile) &#123;</span><br><span class="line">        this.keyTile = keyTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        MoonKey moonKey = (MoonKey) o;</span><br><span class="line">        return Objects.equals(keyTile, moonKey.keyTile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用下面的代码进行两次添加，你说 size 的长度是 1 还是 2 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MoonKey, String&gt; m = new HashMap&lt;&gt;();</span><br><span class="line">MoonKey moonKey = new MoonKey();</span><br><span class="line">moonKey.setKeyTile(&quot;1&quot;);</span><br><span class="line">MoonKey moonKey1 = new MoonKey();</span><br><span class="line">moonKey1.setKeyTile(&quot;1&quot;);</span><br><span class="line">m.put(moonKey, &quot;1&quot;);</span><br><span class="line">m.put(moonKey1, &quot;2&quot;);</span><br><span class="line">System.out.println(hash(moonKey));</span><br><span class="line">System.out.println(hash(moonKey1));</span><br><span class="line">System.out.println(m.size());</span><br></pre></td></tr></table></figure><p>答案是 2 ，为什么呢，因为 MoonKey 没有重写 hashCode 方法，导致 moonkey 和 moonKey1 的 hash 值不可能一样，当不重写 hashCode 方法时，默认继承自 Object 的 hashCode 方法，而每个 Object 对象的 hash 值都是独一无二的。</p><p>划重点，正确的做法应该是加上 hashCode 的重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">  return Objects.hash(keyTile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是为什么要求重写 equals 方法的同时，也必须重写 hashCode 方法的原因之一。 如果两个对象通过调用 equals 方法是相等的，那么这两个对象调用 hashCode 方法必须返回相同的整数。有了这个基础才能保证 HashMap 或者 HashSet 的 key 唯一。</p><p>[参考链接]<a href="https://www.cnblogs.com/fengzheng/p/13180526.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengzheng/p/13180526.html</a></p><h4 id="tableSizeFor-源码："><a href="#tableSizeFor-源码：" class="headerlink" title="tableSizeFor()源码："></a>tableSizeFor()源码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">/**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> */</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法被调用的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">   </span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 都是 2 的幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂（initialCapacity 如果就是 2 的幂，则返回的还是这个数）。</p><h5 id="下面分析这个算法："><a href="#下面分析这个算法：" class="headerlink" title="下面分析这个算法："></a>下面分析这个算法：</h5><p>首先，为什么要对 cap 做减 1 操作。int n = cap - 1;<br>这是为了防止，cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 又没有执行这个减 1 操作，则执行完后面的几条无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。</p><h5 id="下面看看这几个无符号右移操作："><a href="#下面看看这几个无符号右移操作：" class="headerlink" title="下面看看这几个无符号右移操作："></a>下面看看这几个无符号右移操作：</h5><p>如果 n 这时为 0 了（经过了 cap-1 之后），则经过后面的几次无符号右移依然是 0，最后返回的 capacity 是 1（最后有个 n+1 的操作）。<br>这里只讨论 n 不等于 0 的情况。</p><h6 id="第一次右移"><a href="#第一次右移" class="headerlink" title="第一次右移"></a>第一次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 1;</span><br></pre></td></tr></table></figure><p>由于 n 不等于 0，则 n 的二进制表示中总会有一 bit 为 1，这时考虑最高位的 1。通过无符号右移 1 位，则将最高位的 1 右移了 1 位，再做或操作，使得 n 的二进制表示中与最高位的 1 紧邻的右边一位也为 1，如 000011xxxxxx。</p><h6 id="第二次右移"><a href="#第二次右移" class="headerlink" title="第二次右移"></a>第二次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 2;</span><br></pre></td></tr></table></figure><p>注意，这个 n 已经经过了 n |= n &gt;&gt;&gt; 1; 操作。假设此时 n 为 000011xxxxxx ，则 n 无符号右移两位，会将最高位两个连续的 1 右移两位，然后再与原来的 n 做或操作，这样 n 的二进制表示的高位中会有 4 个连续的 1。如 00001111xxxxxx 。</p><h6 id="第三次右移"><a href="#第三次右移" class="headerlink" title="第三次右移"></a>第三次右移</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 4;</span><br></pre></td></tr></table></figure><p>这次把已经有的高位中的连续的 4 个 1，右移 4 位，再做或操作，这样 n 的二进制表示的高位中会有 8 个连续的 1。如 00001111 1111xxxxxx 。</p><h6 id="以此类推"><a href="#以此类推" class="headerlink" title="以此类推"></a>以此类推</h6><p>注意，容量最大也就是 32bit 的正数，因此最后 n |= n &gt;&gt;&gt; 16; ，最多也就 32 个 1（但是这已经是负数了。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY (2 ^ 30)，则取 MAXIMUM_CAPACITY。如果等于 MAXIMUM_CAPACITY (2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大 30 个 1，不会大于等于 MAXIMUM_CAPACITY。30 个 1，加 1 之后得 2 ^ 30） 。</p><h5 id="举一个例子说明下吧。"><a href="#举一个例子说明下吧。" class="headerlink" title="举一个例子说明下吧。"></a>举一个例子说明下吧。</h5><p><img src="/2020/07/10/HashMap详解/aaa.png" alt></p><p>注意，得到的这个 capacity 却被赋值给了 threshold。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>开始以为这个是个 Bug，感觉应该这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span><br></pre></td></tr></table></figure><p>这样才符合 threshold 的意思（当 HashMap 的 size 到达 threshold 这个阈值时会扩容）。<br>但是，请注意，在构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算.</p><h4 id="resize-扩容机制"><a href="#resize-扩容机制" class="headerlink" title="resize() 扩容机制"></a>resize() 扩容机制</h4><p>在上边 put 方法中，我们会发现，当数组为空的时候，会调用 resize 方法，当数组的 size 大于阈值的时候，也会调用 resize方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">//旧数组</span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">//旧数组的容量</span><br><span class="line">int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">//旧数组的扩容阈值，注意看，这里取的是当前对象的 threshold 值，下边的第2种情况会用到。</span><br><span class="line">int oldThr = threshold;</span><br><span class="line">//初始化新数组的容量和阈值，分三种情况讨论。</span><br><span class="line">int newCap, newThr = 0;</span><br><span class="line">//1.当旧数组的容量大于0时，说明在这之前肯定调用过 resize扩容过一次，才会导致旧容量不为0。</span><br><span class="line">//为什么这样说呢，之前我在 tableSizeFor 卖了个关子，需要注意的是，它返回的值是赋给了 threshold 而不是 capacity。</span><br><span class="line">//我们在这之前，压根就没有在任何地方看到过，它给 capacity 赋初始值。</span><br><span class="line">if (oldCap &gt; 0) &#123;</span><br><span class="line">//容量达到了最大值</span><br><span class="line">if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line">return oldTab;</span><br><span class="line">&#125;</span><br><span class="line">//新数组的容量和阈值都扩大原来的2倍</span><br><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line"> oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">&#125;</span><br><span class="line">//2.到这里，说明 oldCap &lt;= 0，并且 oldThr(threshold) &gt; 0，这就是 map 初始化的时候，第一次调用 resize的情况</span><br><span class="line">//而 oldThr的值等于 threshold，此时的 threshold 是通过 tableSizeFor 方法得到的一个2的n次幂的值(我们以16为例)。</span><br><span class="line">//因此，需要把 oldThr 的值，也就是 threshold ，赋值给新数组的容量 newCap，以保证数组的容量是2的n次幂。</span><br><span class="line">//所以我们可以得出结论，当map第一次 put 元素的时候，就会走到这个分支，把数组的容量设置为正确的值（2的n次幂)</span><br><span class="line">//但是，此时 threshold 的值也是2的n次幂，这不对啊，它应该是数组的容量乘以加载因子才对。别着急，这个会在③处理。</span><br><span class="line">else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">newCap = oldThr;</span><br><span class="line">//3.到这里，说明 oldCap 和 oldThr 都是小于等于0的。也说明我们的map是通过默认无参构造来创建的，</span><br><span class="line">//于是，数组的容量和阈值都取默认值就可以了，即 16 和 12。</span><br><span class="line">else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line">//③ 这里就是处理第2种情况，因为只有这种情况 newThr 才为0，</span><br><span class="line">//因此计算 newThr（用 newCap即16 乘以加载因子 0.75，得到 12） ，并把它赋值给 threshold</span><br><span class="line">if (newThr == 0) &#123;</span><br><span class="line">float ft = (float)newCap * loadFactor;</span><br><span class="line">newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">//赋予 threshold 正确的值，表示数组下次需要扩容的阈值（此时就把原来的 16 修正为了 12）。</span><br><span class="line">threshold = newThr;</span><br><span class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line">//如果原来的数组不为空，那么我们就需要把原来数组中的元素重新分配到新的数组中</span><br><span class="line">//如果是第2种情况，由于是第一次调用resize，此时数组肯定是空的，因此也就不需要重新分配元素。</span><br><span class="line">if (oldTab != null) &#123;</span><br><span class="line">//遍历旧数组</span><br><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line">//取到当前下标的第一个元素，如果存在，则分三种情况重新分配位置</span><br><span class="line">if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">oldTab[j] = null;</span><br><span class="line">//1.如果当前元素的下一个元素为空，则说明此处只有一个元素</span><br><span class="line">//则直接用它的hash()值和新数组的容量取模就可以了，得到新的下标位置。</span><br><span class="line">if (e.next == null)</span><br><span class="line">newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">//2.如果是红黑树结构，则拆分红黑树，必要时有可能退化为链表</span><br><span class="line">else if (e instanceof TreeNode)</span><br><span class="line">((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">//3.到这里说明，这是一个长度大于 1 的普通链表，则需要计算并</span><br><span class="line">//判断当前位置的链表是否需要移动到新的位置</span><br><span class="line">else &#123; // preserve order</span><br><span class="line">// loHead 和 loTail 分别代表链表旧位置的头尾节点</span><br><span class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">// hiHead 和 hiTail 分别代表链表移动到新位置的头尾节点</span><br><span class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">do &#123;</span><br><span class="line">next = e.next;</span><br><span class="line">//如果当前元素的hash值和oldCap做与运算为0，则原位置不变</span><br><span class="line">if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">if (loTail == null)</span><br><span class="line">loHead = e;</span><br><span class="line">else</span><br><span class="line">loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">&#125;</span><br><span class="line">//否则，需要移动到新的位置</span><br><span class="line">else &#123;</span><br><span class="line">if (hiTail == null)</span><br><span class="line">hiHead = e;</span><br><span class="line">else</span><br><span class="line">hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while ((e = next) != null);</span><br><span class="line">//原位置不变的一条链表，数组下标不变</span><br><span class="line">if (loTail != null) &#123;</span><br><span class="line">loTail.next = null;</span><br><span class="line">newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line">//移动到新位置的一条链表，数组下标为原下标加上旧数组的容量</span><br><span class="line">if (hiTail != null) &#123;</span><br><span class="line">hiTail.next = null;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="你一般用什么作为HashMap的key"><a href="#你一般用什么作为HashMap的key" class="headerlink" title="你一般用什么作为HashMap的key?"></a>你一般用什么作为HashMap的key?</h5><p>一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</p><p>(1)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。<br>(2)因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</p><h5 id="我用可变类当HashMap的key有什么问题"><a href="#我用可变类当HashMap的key有什么问题" class="headerlink" title="我用可变类当HashMap的key有什么问题?"></a>我用可变类当HashMap的key有什么问题?</h5><p>hashcode可能发生改变，导致put进去的值，无法get出，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">Object objectValue = new Object();</span><br><span class="line">changeMap.put(list, objectValue);</span><br><span class="line">System.out.println(changeMap.get(list));</span><br><span class="line">list.add(&quot;hello world&quot;);//hashcode发生了改变</span><br><span class="line">System.out.println(changeMap.get(list));</span><br></pre></td></tr></table></figure><p>输出值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@74a14482</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/129724004" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/129724004</a><br>[参考链接]<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br>[参考链接]<a href="https://www.lizenghai.com/archives/65376.html" target="_blank" rel="noopener">https://www.lizenghai.com/archives/65376.html</a><br><a href="https://my.oschina.net/u/2307589/blog/1800587" target="_blank" rel="noopener">https://my.oschina.net/u/2307589/blog/1800587</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//默认的初始化容量为16，必须是2的n次幂&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//最大容量为 2^30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//默认的加载因子0.75，乘以数组容量得到的值，用来表示元素个数达到多少时，需要扩容。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//为什么设置 0.75 这个值呢，简单来说就是时间和空间的权衡。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//若小于0.75如0.5，则数组长度达到一半大小就需要扩容，空间使用率大大降低，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//若大于0.75如0.8，则会增大hash冲突的概率，影响查询效率。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//刚才提到了当链表长度过长时，会有一个阈值，超过这个阈值8就会转化为红黑树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int TREEIFY_THRESHOLD = 8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//当红黑树上的元素个数，减少到6个时，就退化为链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int UNTREEIFY_THRESHOLD = 6;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//链表转化为红黑树，除了有阈值的限制，还有另外一个限制，需要数组容量至少达到64，才会树化。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//这是为了避免，数组扩容和树化阈值之间的冲突。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final int MIN_TREEIFY_CAPACITY = 64;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//存放所有Node节点的数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Node&amp;lt;K,V&amp;gt;[] table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//存放所有的键值对&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//map中的实际键值对个数，即数组中元素个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient int size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//每次结构改变时，都会自增，fail-fast机制，这是一种错误检测机制。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//当迭代集合的时候，如果结构发生改变，则会发生 fail-fast，抛出异常。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transient int modCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//数组扩容阈值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int threshold;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//加载因子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;final float loadFactor;					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//普通单向链表节点类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	final int hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	final K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	V value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//指向单链表的下一个节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.hash = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//转化为红黑树的节点类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//当前节点的父节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; parent;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//左孩子节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//右孩子节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//指向前一个节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//当前节点是红色或者黑色的标识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	boolean red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		super(hash, key, val, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://yoursite.com/2020/07/09/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/09/ThreadLocal详解/</id>
    <published>2020-07-09T11:57:10.000Z</published>
    <updated>2020-07-09T11:14:41.873Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/07/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/07/ConcurrentHashMap详解/</id>
    <published>2020-07-07T11:57:10.000Z</published>
    <updated>2020-07-15T07:18:50.606Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>ConcurrentHashMap 是 HashMap 的线程安全版本；</li><li>不允许 [key,value] 为 null;</li><li>比 Hashtable 锁粒度更细；</li><li>采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；</li><li>负载因子 0.75;</li><li>默认初始化容量 16;</li><li>put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；</li><li>put 时出现 hash 冲突，则采用 synchronized;</li><li>查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；</li><li>ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;</li></ul><a id="more"></a><h4 id="效率低下的-HashTable-容器"><a href="#效率低下的-HashTable-容器" class="headerlink" title="效率低下的 HashTable 容器"></a>效率低下的 HashTable 容器</h4><p>HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下。<br>因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><ul><li>什么时候会触发扩容</li></ul><ol><li>链表转换为红黑树时 (链表节点个数达到 8 个可能会转换为红黑树)。如果转换时 map 长度小于 64 则直接扩容一倍，不转化为红黑树。如果此时 map 长度大于 64，则不会扩容，直接进行链表转红黑树的操作。(即链表长度大于等于8且map的长度大于64才会将链表转换为红黑树)</li><li>map 中总节点数大于阈值 (即大于 map 长度的 0.75 倍) 时会进行扩容。</li></ol><ul><li>如何扩容</li></ul><ol><li>创建一个新的 map，是原先 map 的两倍。注意此过程是单线程创建的；</li><li>复制旧的 map 到新的 map 中。注意此过程是多线程并发完成。（将 map 按照线程数量平均划分成多个相等区域，每个线程负责一块区域的复制任务）；</li></ol><h4 id="成员变量解析"><a href="#成员变量解析" class="headerlink" title="成员变量解析"></a>成员变量解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile Node&lt;K,V&gt;[] table</span><br></pre></td></tr></table></figure><p>默认为 null，初始化发生在第一次插入操作，默认大小为 16 的数组，用来存储 Node 节点数据，扩容时大小总是 2 的幂次方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable</span><br></pre></td></tr></table></figure><p>默认为 null，扩容时新生成的数组，其大小为原数组的两倍。</p><ul><li>ForwardingNode<br>一个特殊的 Node 节点，hash 值为 - 1，其中存储 nextTable 的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MOVED = -1</span><br></pre></td></tr></table></figure><p>扩容节点的 hash 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl</span><br></pre></td></tr></table></figure><p>默认为 0，用来控制 table 的初始化和扩容操作，具体应用在后续会体现出来。<br>-1 代表 table 正在初始化<br>-N 表示有 N-1 个线程正在进行扩容操作<br>其余情况：<br>(1) 如果 table 未初始化，表示 table 需要初始化的大小。<br>(2) 如果 table 初始化完成，表示 table 的容量，默认是 table 大小的 0.75 倍，居然用这个公式算 0.75（n - (n &gt;&gt;&gt; 2)）—-(即n-n/4)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe U</span><br></pre></td></tr></table></figure><p>在 ConcurrentHashMap 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层 CMPXCHG 指令实现。CAS (V,O,N) 核心思想为： 若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用 CAS 是通过 sun.misc.Unsafe 类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 java 中的 “指针”。该成员变量的获取是在静态代码块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">.......</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-类相关方法"><a href="#Unsafe-类相关方法" class="headerlink" title="Unsafe 类相关方法"></a>Unsafe 类相关方法</h4><p>ConcurrentHashMap 废弃了分段锁，改用 CAS + Synchronized + valatile 保证线程安全，而 Java 主要通过 Unsafe 类实现 CAS，因此源代码大量使用了 Unsafe 类的三个 CAS 方法，如下：</p><ul><li>compareAndSwapObject(Object o, long offset, Object expected, Object x);</li><li>compareAndSwapInt(Object o, long offset, int expected, int x);</li><li>compareAndSwapLong(Object o, long offset, long expected, long x);<br>这些方法非常相似，区别只是参数 expected 和 x 的类型。它们表达的意思是，如果对象 o 在 offset 位置的值是 expected，则把值修改为 x，否则不修改。其中 o 是给定的对象，offset 表示对象内存偏移量，expected 表示当前位置的期望值，x 表示修改后的新值。<br>此外，ConcurrentHashMap 封装了三个数组元素访问方法，底层依然是调用 Unsafe 类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//从主存获取tab[i]，避免读到脏数据</span><br><span class="line">static final  Node tabAt(Node[] tab, int i) &#123;</span><br><span class="line">    return (Node)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值从c改成v</span><br><span class="line">static final  boolean casTabAt(Node[] tab, int i,</span><br><span class="line">                                    Node c, Node v) &#123;</span><br><span class="line">    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line">//将tab[i]的值v写到主存</span><br><span class="line">static final  void setTabAt(Node[] tab, int i, Node v) &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>带有并行度(concurrencyLevel)的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">            initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">        //initialCapacity这是想存储的容量，size类似初始化的容量</span><br><span class="line">        long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method" target="_blank" rel="noopener">https://stackoverflow.com/questions/50083966/bug-parameter-initialcapacity-of-concurrenthashmaps-construct-method</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//onlyIfAbsent表示key不存在才插入，存在则不更新</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap-中，是怎么去初始化底层数组的"><a href="#ConcurrentHashMap-中，是怎么去初始化底层数组的" class="headerlink" title="ConcurrentHashMap 中，是怎么去初始化底层数组的"></a>ConcurrentHashMap 中，是怎么去初始化底层数组的</h4><p>在我们用无参构造函数，去 new 一个 ConcurrentHashMap 时，此时还不会去创建底层数组，这个是一个小优化。什么时候创建数组呢，是在我们第一次去 put 的时候。<br>put 的时候，会调用 putVal。</p><p>其中，putVal 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">     // 1</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">         // 2</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br></pre></td></tr></table></figure><ul><li>1 处，把 field table，赋值给局部变量 tab</li><li>2 处，如果 tab 为 null，则进行 initTable 初始化</li></ul><p><strong><em>这个 2 处，在多线程 put 的时候，是可能多个线程同时进来的。有并发问题。</em></strong></p><p>我们接下来，看看 initTable 是怎么解决这个问题的，毕竟，我们 new 数组，只 new 一次即可，new 那么多次，没用，对性能有损耗。所以，这里面肯定会多线程争夺初始化权利的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl;</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line">    */</span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab;</span><br><span class="line">     int sc;</span><br><span class="line">     </span><br><span class="line">     // 0</span><br><span class="line">       while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">         // 1</span><br><span class="line">           if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); // lost initialization race; just spin</span><br><span class="line">         // 2</span><br><span class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 // 3</span><br><span class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                     // 4</span><br><span class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                 // 5</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">             </span><br><span class="line">           &#125;// end if</span><br><span class="line">         </span><br><span class="line">       &#125;// end while</span><br><span class="line">       return tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，这里把 sizeCtl，赋值给局部变量 sc。这里的 sizeCtl 是一个很重要的 field，当我们 new 完之后，默认这个字段，要么为 0，要么为准备创建的底层数组的长度。<br>这里去判断是否小于 0，那肯定不满足，小于 0，会是什么意思？当某个线程，抢到了这个 initTable 中的底层数组的创建权利时，就会把 sizeCtl 改为 -1。<br>所以，这里的意思是，看看是否已经有其他线程在初始化了，如果已经有了，则直接调用：<br>Thread.yield();<br>这个方法的意思是，暗示操作系统，自己准备放弃 cpu；但操作系统，自有它自己的线程调度规则，所以，这个方法可能没什么效果；我们业务代码，这里一般可以修改为 Thread.sleep。<br>这个方法调用完成后，后续也没有其他代码，所以会直接跳转到循环开始处（0 处代码），判断 table 是否初始化 ok 了，如果没有 ok，则会继续进来。</p></li><li><p>2 处，使用 cas，如果此时，sizeCtl 的值等于 sc 的值，就修改 sizeCtl 为 -1；如果成功，则返回 true，进入 3 处<br>否则，会跳转到 0 处，继续循环。</p></li><li><p>3 处，虽然抢到了控制权，但是这里还是要再判断一下，不然可能出现重复初始化，即，不加这一行，4 处的代码，会被重复执行</p></li><li><p>4 处开始，这里去执行真正的初始化逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">// 1</span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">// 2</span><br><span class="line">table = tab = nt;</span><br><span class="line">sc = n - (n &gt;&gt;&gt; 2);</span><br></pre></td></tr></table></figure></li></ul><p>这里的 1 处，new 数组；2 处，赋值给 field：table；此时，因为 table 这个 field 是 volatile 修饰的，所以其他线程会马上感知到。0 处代码就不会为 true 了，就不会继续循环了。</p><ul><li>5 处，修改 sizeCtl 为正数。</li></ul><p>这里说下，为啥要加 3 处的那个判断。</p><p>现在，假设线程 A，在初始化完成后，走到了 5 处，修改了 sizeCtl 为正数；而线程 B，刚好执行 1 处代码：</p><p>// 1<br>if ((sc = sizeCtl) &lt; 0)<br>那肯定，1 处就不满足了；然后就会进到 2 处，cas 修改成功，进行初始化。没有 3 处判断的话，就会重复初始化。</p><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>1.判断键值是否为 null，为 null 抛出异常。<br>2.调用 spread() 方法计算 key 的 hashCode () 获得哈希地址，这个 HashMap 相似。<br>3.如果当前 table 为空，则初始化 table，需要注意的是这里并没有加 synchronized，也就是允许多个线程去尝试初始化 table，但是在初始化函数里面使用了 CAS 保证只有一个线程去执行初始化过程。<br>4.使用 容量大小 - 1 &amp; 哈希地址 计算出待插入键值的下标，如果该下标上的 bucket 为 null，则直接调用实现 CAS 原子性操作的 casTabAt() 方法将节点插入到 table 中，如果插入成功则完成 put 操作，结束返回。插入失败 (被别的线程抢先插入了) 则继续往下执行。<br>5.如果该下标上的节点 (头节点) 的哈希地址为 - 1，代表需要扩容，该线程执行 helpTransfer() 方法协助扩容。<br>6.如果该下标上的 bucket 不为空，且又不需要扩容，则进入到 bucket 中，同时锁住这个 bucket，注意只是锁住该下标上的 bucket 而已，其他的 bucket 并未加锁，其他线程仍然可以操作其他未上锁的 bucket，这个就是 ConcurrentHashMap 为什么高效的原因之一。<br>7.进入到 bucket 里面，首先判断这个 bucket 存储的是红黑树 (哈希地址小于 0，原因后面分析) 还是链表。<br>8.如果是链表，则遍历链表看看是否有哈希地址和键 key 相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里结束加锁。<br>9.最后判断该 bucket 上的链表长度是否大于链表转红黑树的阈值 (8)，大于则调用 treeifyBin() 方法将链表转成红黑树，以免链表过长影响效率。<br>10.调用 addCount() 方法，作用是将 ConcurrentHashMap 的键值对数量 + 1，还有另一个作用是检查 ConcurrentHashMap 是否需要扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span><br><span class="line">    //址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span><br><span class="line">    //过spread()加多了 &amp;0x7fffffff，让结果为正数。</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span><br><span class="line">        //下面介绍。</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //调用实现了CAS原子性操作的tabAt方法</span><br><span class="line">        //tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span><br><span class="line">        //e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span><br><span class="line">        //这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span><br><span class="line">        //希地址做与运算，和HashMap的算法一样。</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span><br><span class="line">            //casTable()方法，</span><br><span class="line">            //casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span><br><span class="line">            //个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span><br><span class="line">            //的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span><br><span class="line">            //功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span><br><span class="line">            //失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span><br><span class="line">        //table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span><br><span class="line">        //HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        //如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span><br><span class="line">        //中，将新节点插入或者覆盖旧值。</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span><br><span class="line">            //该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span><br><span class="line">            //可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span><br><span class="line">            //以提高了ConcurrentHashMap的效率，提高了并发度。</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果该下标上的节点的哈希地址大于等于0，则表示这是</span><br><span class="line">                    //个链表。</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        //遍历链表。</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //如果哈希地址、键key相同 或者 键key不为空</span><br><span class="line">                            //且键key相同，则表示存在键key和待插入的键</span><br><span class="line">                            //key相同，则执行更新值value的操作。</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            //如果找到了链表的最后一个节点都没有找到相</span><br><span class="line">                            //同键Key的，则是插入操作，将插入的键值新建</span><br><span class="line">                            //个节点并且添加到链表尾部，这个和HashMap一</span><br><span class="line">                            //样都是插入到尾部。</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果该下标上的节点的哈希地址小于0 且为树节点</span><br><span class="line">                    //则将带插入键值新增到红黑树</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //如果插入的结果不为null，则表示为替换</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != null)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span><br><span class="line">            //红黑树，提高效率。这点和HashMap一样。</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="http://iambigboss.top/post/73849_1_1.html" target="_blank" rel="noopener">http://iambigboss.top/post/73849_1_1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap 是 HashMap 的线程安全版本；&lt;/li&gt;
&lt;li&gt;不允许 [key,value] 为 null;&lt;/li&gt;
&lt;li&gt;比 Hashtable 锁粒度更细；&lt;/li&gt;
&lt;li&gt;采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；&lt;/li&gt;
&lt;li&gt;负载因子 0.75;&lt;/li&gt;
&lt;li&gt;默认初始化容量 16;&lt;/li&gt;
&lt;li&gt;put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；&lt;/li&gt;
&lt;li&gt;put 时出现 hash 冲突，则采用 synchronized;&lt;/li&gt;
&lt;li&gt;查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；&lt;/li&gt;
&lt;li&gt;ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务</title>
    <link href="http://yoursite.com/2020/07/06/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/06/quartz定时任务/</id>
    <published>2020-07-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:36:45.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Quartz-API-的关键接口是："><a href="#Quartz-API-的关键接口是：" class="headerlink" title="Quartz API 的关键接口是："></a>Quartz API 的关键接口是：</h4><ul><li>Scheduler - 与调度程序交互的主要 API。</li><li>Job - 由希望由调度程序执行的组件实现的接口。</li><li>JobDetail - 用于定义作业的实例。</li><li>Trigger（即触发器） - 定义执行给定作业的计划的组件。</li><li>JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。</li><li>TriggerBuilder - 用于定义 / 构建触发器实例。</li></ul><a id="more"></a><ul><li><p>定时任务类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void run() throws SchedulerException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;journal&quot;, journalService);//可以保存到JobExecutionContext中</span><br><span class="line">        SchedulerFactory schedFact = new StdSchedulerFactory();</span><br><span class="line">        Scheduler sched = schedFact.getScheduler();</span><br><span class="line">        sched.start();</span><br><span class="line"></span><br><span class="line">        JobDetail job = newJob(SimpleTestJob.class)</span><br><span class="line">                .withIdentity(&quot;myJob&quot;, &quot;group&quot;)</span><br><span class="line">                .usingJobData(new JobDataMap(map))</span><br><span class="line">                .build();</span><br><span class="line">        Trigger trigger = newTrigger()</span><br><span class="line">                .withIdentity(&quot;myTrigger&quot;, &quot;group&quot;)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(simpleSchedule()</span><br><span class="line">                .withIntervalInMinutes(5)//设置定时任务间隔时间</span><br><span class="line">                .repeatForever())</span><br><span class="line">                .build();</span><br><span class="line">        sched.scheduleJob(job, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体执行任务的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTestJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; jobParams = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        for (String string : jobParams.keySet()) &#123;</span><br><span class="line">            Object obj = jobParams.get(string);</span><br><span class="line">            journalService = (JournalService) obj;</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">        String format = dateFormat.format(new Date());</span><br><span class="line">        System.out.println(&quot;----------------------- &quot; + format + &quot; -------------------------&quot;);</span><br><span class="line">        List&lt;Journal&gt; journalList = journalService.selectByOperateDate(format);</span><br><span class="line">        for (Journal journal : journalList) &#123;</span><br><span class="line">            String str = dateFormat.format(journal.getOperateDate());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Quartz-API-的关键接口是：&quot;&gt;&lt;a href=&quot;#Quartz-API-的关键接口是：&quot; class=&quot;headerlink&quot; title=&quot;Quartz API 的关键接口是：&quot;&gt;&lt;/a&gt;Quartz API 的关键接口是：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Scheduler - 与调度程序交互的主要 API。&lt;/li&gt;
&lt;li&gt;Job - 由希望由调度程序执行的组件实现的接口。&lt;/li&gt;
&lt;li&gt;JobDetail - 用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;Trigger（即触发器） - 定义执行给定作业的计划的组件。&lt;/li&gt;
&lt;li&gt;JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;TriggerBuilder - 用于定义 / 构建触发器实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="quartz" scheme="http://yoursite.com/categories/quartz/"/>
    
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
</feed>
