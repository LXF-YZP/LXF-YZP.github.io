<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-25T03:35:58.181Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/09/20/volatile/"/>
    <id>http://yoursite.com/2019/09/20/volatile/</id>
    <published>2019-09-20T09:28:24.000Z</published>
    <updated>2019-09-25T03:35:58.181Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/2019/09/20/volatile/aaa.png" alt><br>1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。<br>2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</p><a id="more"></a><h1 id="volatile通过禁止指令重排保证有序性"><a href="#volatile通过禁止指令重排保证有序性" class="headerlink" title="volatile通过禁止指令重排保证有序性"></a>volatile通过禁止指令重排保证有序性</h1><p>在多线程模式下，指令重排的时候会出现问题，所以在多线程的情况下为了保证线程安全，需要禁止掉指令重排。<br>volatile在禁止指令重排方面的应用：</p><ol><li>通过一个变量来进行初始化判断。如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean isInit = false;</span><br><span class="line">private Manager mManger;</span><br><span class="line">public Manager getManager()&#123;</span><br><span class="line">  if(!isInit)&#123;</span><br><span class="line">    mManger = initManager();</span><br><span class="line">    isInit = true;</span><br><span class="line">  &#125;</span><br><span class="line">  return mManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在单线程下没有任何问题，但是在多线程情况下如果进行了指令重排，那么代码是有问题的。比如指令重排之后，把 isInit = true 放在了 mManager = initManager() 之上，很可能在多线程的情况下出现 mManager 为空的情况，从而出现空指针异常。线程 1 执行 getManager 方法，由于指令重排，isInit = true 先执行，然后去真正初始化 mManager, 最后返回 mManager 实例，不会有任何问题。但是当线程 1 执行完 isInit = true 之后，线程 2 开始执行 getManager 方法，发现 isInit 为 true，就直接返回了 mManager，而此时 mManager 还没有初始化，所以线程 2 中会出现空指针异常。</p><ol start="2"><li>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance () 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance () 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance () 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><pre><code>1⃣️分配一块内存 M；2⃣️在内存 M 上初始化 Singleton 对象；3⃣️然后 M 的地址赋值给 instance 变量。</code></pre><p>换成代码如下：</p><pre><code>1⃣️memory = allocate () // 分配内存；2⃣️ctorInstanc (memory) // 初始化对象；3⃣️instance = memory // 设置 instance 指向刚分配的地址</code></pre><p>但是实际上优化后的执行路径却是这样的：</p><pre><code>1⃣️分配一块内存 M；2⃣️将 M 的地址赋值给 instance 变量；3⃣️最后在内存 M 上初始化 Singleton 对象。</code></pre><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance () 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance () 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>正确写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 关键字禁止指令重排序有两层意思：</p><p>1）当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>2）在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p><p>举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"></span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;        //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure><p>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。</p><p>并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果对语句 3、语句 4、语句 5 是可见的。</p><h1 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h1><ol><li>从上面知道 volatile 关键字保证了操作的可见性，但是 volatile 不能保证对变量的操作是原子性的，可以参考Java并发编程实战第三章。<br>下面看一个带有自增操作的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面例子输出的结果是小于10000的数，可能有的朋友就会有疑问，上面是对变量 inc 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 inc 自增完之后，在其他线程中都能看到修改后的值啊，所以有 10 个线程分别进行了 1000 次操作，那么最终 inc 的值应该是 1000*10=10000。</p><p>这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。</p><p>由于自增操作是不具备原子性的，它包括读取变量的原始值、进行加 1 操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量 inc 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了变量 inc 的原始值，然后线程 1 被阻塞了；<br>然后线程 2 对变量进行自增操作，线程 2 也去读取变量 inc 的原始值，由于线程 1 只是对变量 inc 进行读取操作，而没有对变量进行修改操作，所以不会导致线程 2 的工作内存中缓存变量 inc 的缓存行无效，线程 2 会直接去主存读取 inc 的值，发现 inc 的值是10，然后进行加 1 操作，并把 11 写入工作内存，最后写入主存。</p><p>然后线程 1 接着进行加 1 操作，由于已经读取了 inc 的值，注意此时在线程 1 的工作内存中 inc 的值仍然为 10，所以线程 1 对 inc 进行加 1 操作后 inc 的值为 11，然后将 11 写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc 只增加了 1。</p><p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改 volatile 变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的 happens-before 规则中的 volatile 变量规则，但是要注意，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。</p><p>根源就在这里，自增操作不是原子性操作，而且 volatile 也无法保证对变量的任何操作都是原子性的。</p><h2 id="对于不保证原子性的解释"><a href="#对于不保证原子性的解释" class="headerlink" title="对于不保证原子性的解释"></a>对于不保证原子性的解释</h2><p>对于上面解释原子性的操作，大家估计会有这种疑问，即当线程 1 将变量 a 读入到了自己的工作内存，还没有修改，被阻塞；线程 2 将主存中的 a 读入工作内存修改，写入主存；线程 1 苏醒是继续运行还是会检测工作内存的变量 a 是否需要刷新呢？</p><p>对于上面问题的解释，网上大致是有两种不同的解释：<br>观点1. 当线程一读取10之后被阻塞了。然后线程二得到了执行机会，并且在执行inc自增操作的时候没有被阻塞，那么线程二执行完自增操作之后更新工作内存，然后刷新到主存中，这时线程一又有了执行机会，那么线程一继续使用之前读取的值10进行自增操作（而不是从主存中读取值11进行自增操作）。<br>观点一就是说线程二修改了主存之后，线程一再次获得执行权后并没有马上去读取主存的值进行自增操作，而是使用原来的10进行自增操作。也就是认为线程二更新主存之后，没有马上去更新线程一的工作内存，导致线程一还是之前的值。</p><p>观点2. 1⃣️线程一读取 inc 的值后，还没有操作就被阻塞了。<br>2⃣️线程二被唤醒，从主存读取 inc 的值，加 1，然后被阻塞。（此时还没来得及把新的值重新赋值给 inc，当然也还没同步到主存）。<br>3⃣️线程一被唤醒，inc 值加 1，然后同步到主存（线程一结束）。<br>4⃣️线程二被唤醒，把最新的值赋值给 inc，同步到主存（此时线程二，inc 的值在第 2 步时已经被处理过了，仅仅只是把新的值赋值给 inc 而已。这个时候是不会再去读取 inc 的缓存行的，虽然 inc 的缓存行此时已经无效了）<br>观点二可以理解为，自增操作的三步：1.复制到工作内存 2.自增 3.写入主存，其中只有 1,2 步在执行之前会检查缓存行，第 3 步是不检查的。把计算后的值赋值给变量，是不需要去检查缓存行的。</p><p>我更倾向于观点二也就是说线程二更新主存之后，会马上使得线程一得工作内存失效，在线程一再去读取Inc的值时会去读取主存中的值。</p><p>把上面的代码改成以下任何一种都可以达到效果：<br>1⃣️采用 synchronized：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2⃣️采用 Lock：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3⃣️采用 AtomicInteger：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc = new AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。volatile 会使得变量 “立即” 刷新到内存中的！而不会在写入内存之前被阻塞！</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol><p>[参考文章]<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/2019/09/20/volatile/aaa.png&quot; alt&gt;&lt;br&gt;1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。&lt;br&gt;2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-Trie树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-Trie树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:36:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-Trie树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-二叉树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:33:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-二叉树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-堆/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-堆" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-图/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:35:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-图" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-散列表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-散列表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:32:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-散列表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-跳表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-跳表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-跳表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-栈/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-09-26T09:07:38.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用数组实现一个顺序栈"><a href="#用数组实现一个顺序栈" class="headerlink" title="用数组实现一个顺序栈"></a>用数组实现一个顺序栈</h2><h2 id="用链表实现一个链式栈"><a href="#用链表实现一个链式栈" class="headerlink" title="用链表实现一个链式栈"></a>用链表实现一个链式栈</h2><h2 id="编程模拟实现一个浏览器的前进、后退功能"><a href="#编程模拟实现一个浏览器的前进、后退功能" class="headerlink" title="编程模拟实现一个浏览器的前进、后退功能"></a>编程模拟实现一个浏览器的前进、后退功能</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用数组实现一个顺序栈&quot;&gt;&lt;a href=&quot;#用数组实现一个顺序栈&quot; class=&quot;headerlink&quot; title=&quot;用数组实现一个顺序栈&quot;&gt;&lt;/a&gt;用数组实现一个顺序栈&lt;/h2&gt;&lt;h2 id=&quot;用链表实现一个链式栈&quot;&gt;&lt;a href=&quot;#用链表实现一个链式栈&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-栈" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-队列</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-队列/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-09-26T09:07:44.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用数组实现一个顺序队列"><a href="#用数组实现一个顺序队列" class="headerlink" title="用数组实现一个顺序队列"></a>用数组实现一个顺序队列</h2><h2 id="用链表实现一个链式队列"><a href="#用链表实现一个链式队列" class="headerlink" title="用链表实现一个链式队列"></a>用链表实现一个链式队列</h2><h2 id="实现一个循环队列"><a href="#实现一个循环队列" class="headerlink" title="实现一个循环队列"></a>实现一个循环队列</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用数组实现一个顺序队列&quot;&gt;&lt;a href=&quot;#用数组实现一个顺序队列&quot; class=&quot;headerlink&quot; title=&quot;用数组实现一个顺序队列&quot;&gt;&lt;/a&gt;用数组实现一个顺序队列&lt;/h2&gt;&lt;h2 id=&quot;用链表实现一个链式队列&quot;&gt;&lt;a href=&quot;#用链表实现一
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-队列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-链表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-链表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-09-27T03:13:04.303Z</updated>
    
    <content type="html"><![CDATA[<p>不要问为什么写单链表反转这么简单的题，问就自己一遍写对；</p><a id="more"></a><h2 id="实现单链表，支持增删操作"><a href="#实现单链表，支持增删操作" class="headerlink" title="实现单链表，支持增删操作"></a>实现单链表，支持增删操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ①单链表的插入、删除、查找操作；</span><br><span class="line"> * ②链表中存储的是 int 类型的数据；</span><br><span class="line"> */</span><br><span class="line">public class SinglyLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    private Node head = null;</span><br><span class="line"></span><br><span class="line">    public Node findByValue(int value) &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        while (p != null &amp;&amp; p.data != value) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node findByIndex(int index) &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        while (p != null &amp;&amp; pos != index) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无头结点</span><br><span class="line">     // 表头部插入</span><br><span class="line">     // 这种操作将于输入的顺序相反，逆序</span><br><span class="line">     public void insertToHead(int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertToHead(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertToHead(Node newNode) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     // 顺序插入，链表尾部插入</span><br><span class="line">     public void insertTail(int value)&#123;</span><br><span class="line"></span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        // 空链表，可以插入新节点作为 head，也可以不操作</span><br><span class="line">         if (head == null)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node q = head;</span><br><span class="line">            while(q.next != null)&#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = q.next;</span><br><span class="line">            q.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void insertAfter(Node p, int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertAfter(p, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertAfter(Node p, Node newNode) &#123;</span><br><span class="line">        if (p == null) return;</span><br><span class="line"></span><br><span class="line">        newNode.next = p.next;</span><br><span class="line">        p.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertBefore(Node p, int value) &#123;</span><br><span class="line">        Node newNode = new Node(value, null);</span><br><span class="line">        insertBefore(p, newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertBefore(Node p, Node newNode) &#123;</span><br><span class="line">        if (p == null) return;</span><br><span class="line">        if (head == p) &#123;</span><br><span class="line">            insertToHead(newNode);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node q = head;</span><br><span class="line">        while (q != null &amp;&amp; q.next != p) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newNode.next = p;</span><br><span class="line">        q.next = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteByNode(Node p) &#123;</span><br><span class="line">        if (p == null || head == null) return;</span><br><span class="line"></span><br><span class="line">        if (p == head) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node q = head;</span><br><span class="line">        while (q != null &amp;&amp; q.next != p) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.next = q.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteByValue(int value) &#123;</span><br><span class="line">        if (head == null) return;</span><br><span class="line"></span><br><span class="line">        Node p = head;</span><br><span class="line">        Node q = null;</span><br><span class="line">        while (p != null &amp;&amp; p.data != value) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (p == null) return;</span><br><span class="line"></span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            q.next = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printAll() &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            System.out.print(p.data + &quot; &quot;);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断 true or false</span><br><span class="line">    public boolean TFResult(Node left, Node right)&#123;</span><br><span class="line">        Node l = left;</span><br><span class="line">        Node r = right;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;left_:&quot;+l.data);</span><br><span class="line">        System.out.println(&quot;right_:&quot;+r.data);</span><br><span class="line">        while(l != null &amp;&amp; r != null)&#123;</span><br><span class="line">           if (l.data == r.data)&#123;</span><br><span class="line">               l = l.next;</span><br><span class="line">               r = r.next;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 什么结果 &quot;);</span><br><span class="line">        if (l==null &amp;&amp; r==null)&#123;</span><br><span class="line">           System.out.println(&quot; 什么结果 &quot;);</span><br><span class="line">           return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //　判断是否为回文 </span><br><span class="line"></span><br><span class="line">    public boolean palindrome()&#123;</span><br><span class="line">       if (head == null)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           System.out.println(&quot; 开始执行找到中间节点 &quot;);</span><br><span class="line">           Node p = head;</span><br><span class="line">           Node q = head;</span><br><span class="line">           if (p.next == null)&#123;</span><br><span class="line">               System.out.println(&quot; 只有一个元素 &quot;);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           while( q.next != null &amp;&amp; q.next.next != null)&#123;</span><br><span class="line">               p = p.next;</span><br><span class="line">               q = q.next.next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           System.out.println(&quot; 中间节点 &quot; + p.data);</span><br><span class="line">           System.out.println(&quot; 开始执行奇数节点的回文判断 &quot;);</span><br><span class="line">           Node leftLink = null;</span><br><span class="line">           Node rightLink = null;</span><br><span class="line">           if(q.next == null)&#123;</span><br><span class="line">               //　p 一定为整个链表的中点，且节点数目为奇数</span><br><span class="line">               rightLink = p.next;</span><br><span class="line">               leftLink = inverseLinkList(p).next;</span><br><span class="line">               System.out.println(&quot; 左边第一个节点 &quot;+leftLink.data);</span><br><span class="line">               System.out.println(&quot; 右边第一个节点 &quot;+rightLink.data);</span><br><span class="line"></span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               //p q　均为中点</span><br><span class="line">               rightLink = p.next;</span><br><span class="line">               leftLink = inverseLinkList(p);</span><br><span class="line">           &#125;</span><br><span class="line">           return TFResult(leftLink, rightLink);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 带结点的链表翻转</span><br><span class="line">     public Node inverseLinkList_head(Node p)&#123;</span><br><span class="line">        //　Head　为新建的一个头结点</span><br><span class="line">         Node Head = new Node(9999,null);</span><br><span class="line">        // p　为原来整个链表的头结点，现在 Head 指向　整个链表</span><br><span class="line">         Head.next = p;</span><br><span class="line">        /*</span><br><span class="line">        带头结点的链表翻转等价于</span><br><span class="line">        从第二个元素开始重新头插法建立链表</span><br><span class="line">         */</span><br><span class="line">        Node Cur = p.next;</span><br><span class="line">        p.next = null;</span><br><span class="line">        Node next = null;</span><br><span class="line"></span><br><span class="line">        while(Cur != null)&#123;</span><br><span class="line">            next = Cur.next;</span><br><span class="line">            Cur.next = Head.next;</span><br><span class="line">            Head.next = Cur;</span><br><span class="line">            System.out.println(&quot;first &quot; + Head.data);</span><br><span class="line"></span><br><span class="line">            Cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //　返回左半部分的中点之前的那个节点</span><br><span class="line">         //　从此处开始同步像两边比较</span><br><span class="line">         return Head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无头结点的链表翻转</span><br><span class="line">     public Node inverseLinkList(Node p)&#123;</span><br><span class="line"></span><br><span class="line">        Node pre = null;</span><br><span class="line">        Node r = head;</span><br><span class="line">        System.out.println(&quot;z---&quot; + r.data);</span><br><span class="line">        Node next= null;</span><br><span class="line">        while(r !=p)&#123;</span><br><span class="line">            next = r.next;</span><br><span class="line"></span><br><span class="line">            r.next = pre;</span><br><span class="line">            pre = r;</span><br><span class="line">            r = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.next = pre;</span><br><span class="line">        //　返回左半部分的中点之前的那个节点</span><br><span class="line">         //　从此处开始同步像两边比较</span><br><span class="line">         return r;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Node createNode(int value) &#123;</span><br><span class="line">        return new Node(value, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        private int data;</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int data, Node next) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getData() &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line"></span><br><span class="line">        SinglyLinkedList link = new SinglyLinkedList(); </span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">        //int data[] = &#123;1&#125;;</span><br><span class="line">        //int data[] = &#123;1,2&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,3,1&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,5&#125;;</span><br><span class="line">        //int data[] = &#123;1,2,2,1&#125;;</span><br><span class="line">       // int data[] = &#123;1,2,5,2,1&#125;;</span><br><span class="line">        int data[] = &#123;1,2,5,3,1&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i =0; i &lt; data.length; i++)&#123;</span><br><span class="line">            //link.insertToHead(data[i]);</span><br><span class="line">            link.insertTail(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">       // link.printAll();</span><br><span class="line">       // Node p = link.inverseLinkList_head(link.head);</span><br><span class="line">       // while(p != null)&#123;</span><br><span class="line">       //     System.out.println(&quot;aa&quot;+p.data);</span><br><span class="line">       //     p = p.next;</span><br><span class="line">       // &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; 打印原始:&quot;);</span><br><span class="line">        link.printAll();</span><br><span class="line">        if (link.palindrome())&#123;</span><br><span class="line">            System.out.println(&quot; 回文 &quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot; 不是回文 &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现单链表反转"><a href="#实现单链表反转" class="headerlink" title="实现单链表反转"></a>实现单链表反转</h2><p>方法一：迭代法</p><p>假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。<br>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null; //前指针节点</span><br><span class="line">    ListNode curr = head; //当前指针节点</span><br><span class="line">    //每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next; //临时节点，暂存当前节点的下一节点，用于后移</span><br><span class="line">        curr.next = prev; //将当前节点指向它前面的节点</span><br><span class="line">        prev = curr; //前指针后移</span><br><span class="line">        curr = nextTemp; //当前指针后移</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接] <a href="https://www.iteye.com/blog/shmilyaw-hotmail-com-1798307" target="_blank" rel="noopener">https://www.iteye.com/blog/shmilyaw-hotmail-com-1798307</a></p><h2 id="实现两个有序的链表合并为一个有序链表"><a href="#实现两个有序的链表合并为一个有序链表" class="headerlink" title="实现两个有序的链表合并为一个有序链表"></a>实现两个有序的链表合并为一个有序链表</h2><p>方法一：即迭代法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line"></span><br><span class="line">        // 利用哨兵结点简化实现难度,哨兵节点即指向链表第一个节点的头结点，头结点中的数据没有实际意义；</span><br><span class="line">        ListNode soldier = new ListNode(0); </span><br><span class="line">        ListNode p = soldier;</span><br><span class="line">        </span><br><span class="line">        while ( l1 != null &amp;&amp; l2 != null )&#123;</span><br><span class="line">            if ( l1.val &lt; l2.val )&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (l1 != null) &#123; p.next = l1; &#125;</span><br><span class="line">        if (l2 != null) &#123; p.next = l2; &#125;</span><br><span class="line">        return soldier.next; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归法</p><p>递归实现请转数据结构-递归</p><h2 id="实现求链表的中间结点"><a href="#实现求链表的中间结点" class="headerlink" title="实现求链表的中间结点"></a>实现求链表的中间结点</h2><ul><li>当链表是偶数时，我们需要判断他自身是否为 null，如果为 null，说明到了末尾。</li><li>当链表是奇数时，我们需要判断他的 next 是否为 null，如果是 null，说明到了末尾。</li></ul><!-- more --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 求单链表的中间节点：</span><br><span class="line"> * 如果长度为奇数，则求出中间节点</span><br><span class="line"> * abcde---&gt;c</span><br><span class="line"> * 如果长度为偶数，则求出第二个中间节点</span><br><span class="line"> * abcdef---&gt;d </span><br><span class="line"> * 总体上的思想用的还是快慢指针，跟链表中是否包含环的求解思想一样</span><br><span class="line"> */</span><br><span class="line">public class LinkMiddle&#123;</span><br><span class="line"></span><br><span class="line">    // 求中间结点</span><br><span class="line">    public static LinkNode findMiddleNode(LinkNode list) &#123;</span><br><span class="line">        if (list == null) return null;</span><br><span class="line"></span><br><span class="line">        LinkNode fast = list;</span><br><span class="line">        LinkNode slow = list;</span><br><span class="line"></span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkNode linkNode1 = new LinkNode(&quot;1&quot;);</span><br><span class="line">        LinkNode linkNode2 = new LinkNode(&quot;2&quot;);</span><br><span class="line">        LinkNode linkNode3 = new LinkNode(&quot;3&quot;);</span><br><span class="line">        LinkNode linkNode4 = new LinkNode(&quot;4&quot;);</span><br><span class="line">        LinkNode linkNode5 = new LinkNode(&quot;5&quot;);</span><br><span class="line">        linkNode1.setNext(linkNode2);</span><br><span class="line">        linkNode2.setNext(linkNode3);</span><br><span class="line">        linkNode3.setNext(linkNode4);</span><br><span class="line">        linkNode4.setNext(linkNode5);</span><br><span class="line">        LinkNode mid =  findMiddleNode(linkNode1);</span><br><span class="line">        System.out.print(mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class LinkNode &#123;</span><br><span class="line"></span><br><span class="line">        private String val;</span><br><span class="line"></span><br><span class="line">        private LinkNode next;</span><br><span class="line"></span><br><span class="line">        public LinkNode(String data)&#123;</span><br><span class="line">            this.val  = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getData() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public LinkNode getNext() &#123;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNext(LinkNode next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;[&quot;+val+&quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要问为什么写单链表反转这么简单的题，问就自己一遍写对；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-链表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>为什么重写equals还要重写hashcode方法</title>
    <link href="http://yoursite.com/2019/05/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/14/为什么重写equals还要重写hashcode方法/</id>
    <published>2019-05-14T10:39:16.000Z</published>
    <updated>2019-09-25T12:09:45.571Z</updated>
    
    <content type="html"><![CDATA[<p>在解释标题之前，首先说明一下 JDK 对 equals (Object obj) 和 hashCode () 这两个方法的定义和规范：<br>在 Java 中任何一个对象都具备 equals (Object obj) 和 hashcode () 这两个方法，因为他们是在 Object 类中定义的。<br>equals (Object obj) 方法用来判断两个对象是否 “相同”，如果 “相同” 则返回 true，否则返回 false。<br>hashcode () 方法返回一个 int 数，在 Object 类中的默认实现是 “将该对象的内部地址转换成一个整数返回”。</p><a id="more"></a><p>接下来有两个关于这两个方法的重要规范：</p><h2 id="规范-1"><a href="#规范-1" class="headerlink" title="规范 1"></a>规范 1</h2><p>若重写 equals (Object obj) 方法，有必要重写 hashcode () 方法，确保通过 equals (Object obj) 方法判断结果为 true 的两个对象具备相等的 hashcode () 返回值。说得简单点就是：“如果两个对象相同，那么他们的 hashcode 应该 相等”。不过请注意：这个只是规范，如果你非要写一个类让 equals (Object obj) 返回 true 而 hashcode () 返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了 Java 规范，程序也就埋下了 BUG。</p><h2 id="规范-2"><a href="#规范-2" class="headerlink" title="规范 2"></a>规范 2</h2><p>如果 equals (Object obj) 返回 false，即两个对象 “不相同”，并不要求对这两个对象调用 hashcode () 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的 hashcode 可能相同”。</p><ul><li>根据这两个规范，可以得到如下推论：<br>1、如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。<br>2、如果两个对象不 equals，他们的 hashcode 有可能相等。<br>3、如果两个对象 hashcode 相等，他们不一定 equals。<br>4、如果两个对象 hashcode 不相等，他们一定不 equals。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>Object 的 hashcode 方法是本地方法，也就是用 c 或 c++ 实现的，该方法直接返回对象的内存地址。如果没有重写 hashCode ()，则任何对象的 hashCode（）值都不相等（而 hashmap 想让部分值的 hashCode 值一样，所以就要重写）</p></li><li><p>为什么重写 equals 还要重写 hashcode<br>如果没有重写 hashCode ()，则任何对象的 hashCode（）值都不相等。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode (), 比较其值是否相等，若相等再比较 equals (), 若相等则认为他们是相等的。若 equals () 不相等则认为他们不相等。<br>如果只重写 equals 没有重写 hashCode ()，就会导致相同的 key 值也被 hashcode 认为是不同的 key 值（因为没有重写 hashCode ()，则任何对象的 hashCode（）值都不相等），就会在 hashmap 中存储相同的 key 值（map 中 key 值不能相同），这就不符合条件了。</p></li></ul><p>[参考文章] <a href="https://www.jianshu.com/p/6546b1f2574f" target="_blank" rel="noopener">https://www.jianshu.com/p/6546b1f2574f</a><br>[参考文章]<a href="https://www.jianshu.com/p/3cd627ecfcff" target="_blank" rel="noopener">https://www.jianshu.com/p/3cd627ecfcff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在解释标题之前，首先说明一下 JDK 对 equals (Object obj) 和 hashCode () 这两个方法的定义和规范：&lt;br&gt;在 Java 中任何一个对象都具备 equals (Object obj) 和 hashcode () 这两个方法，因为他们是在 Object 类中定义的。&lt;br&gt;equals (Object obj) 方法用来判断两个对象是否 “相同”，如果 “相同” 则返回 true，否则返回 false。&lt;br&gt;hashcode () 方法返回一个 int 数，在 Object 类中的默认实现是 “将该对象的内部地址转换成一个整数返回”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java、equals、hashcode" scheme="http://yoursite.com/tags/java%E3%80%81equals%E3%80%81hashcode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-数组</title>
    <link href="http://yoursite.com/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/05/12/数据结构-数组/</id>
    <published>2019-05-12T11:57:10.000Z</published>
    <updated>2019-09-26T09:56:39.922Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法之美专栏中数组的常用题解；</p><a id="more"></a><h2 id="实现一个支持动态扩容的数组；"><a href="#实现一个支持动态扩容的数组；" class="headerlink" title="实现一个支持动态扩容的数组；"></a>实现一个支持动态扩容的数组；</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">public class GenericArray&lt;T&gt; &#123;</span><br><span class="line">    private T[] data;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    // 根据传入容量，构造 Array</span><br><span class="line">    public GenericArray(int capacity) &#123;</span><br><span class="line">        data = (T[]) new Object[capacity];</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无参构造方法，默认数组容量为 10</span><br><span class="line">    public GenericArray() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取数组容量</span><br><span class="line">     public int getCapacity() &#123;</span><br><span class="line">        return data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前元素个数</span><br><span class="line">     public int count() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断数组是否为空</span><br><span class="line">     public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改 index 位置的元素</span><br><span class="line">     public void set(int index, T e) &#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        data[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取对应 index 位置的元素</span><br><span class="line">     public T get(int index) &#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查看数组是否包含元素 e</span><br><span class="line">    public boolean contains(T e) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (data[i].equals(e)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取对应元素的下标，未找到，返回 -1</span><br><span class="line">    public int find(T e) &#123;</span><br><span class="line">        for ( int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (data[i].equals(e)) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 在 index 位置，插入元素 e, 时间复杂度 O (m+n)</span><br><span class="line">    public void add(int index, T e) &#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        // 如果当前元素个数等于数组容量，则将数组扩容为原来的 2 倍</span><br><span class="line">         if (size == data.length) &#123;</span><br><span class="line">            resize(2 * data.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = size - 1; i &gt;= index; i--) &#123;</span><br><span class="line">            data[i + 1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向数组头插入元素</span><br><span class="line">     public void addFirst(T e) &#123;</span><br><span class="line">        add(0, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向数组尾插入元素</span><br><span class="line">     public void addLast(T e) &#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除 index 位置的元素，并返回</span><br><span class="line">     public T remove(int index) &#123;</span><br><span class="line">        checkIndexForRemove(index);</span><br><span class="line"></span><br><span class="line">        T ret = data[index];</span><br><span class="line">        for (int i = index + 1; i &lt; size; i++) &#123;</span><br><span class="line">            data[i - 1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line">        data[size] = null;</span><br><span class="line"></span><br><span class="line">        // 缩容</span><br><span class="line">         if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123;</span><br><span class="line">            resize(data.length / 2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除第一个元素</span><br><span class="line">     public T removeFirst() &#123;</span><br><span class="line">        return remove(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除末尾元素</span><br><span class="line">     public T removeLast() &#123;</span><br><span class="line">        return remove(size - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从数组中删除指定元素</span><br><span class="line">     public void removeElement(T e) &#123;</span><br><span class="line">        int index = find(e);</span><br><span class="line">        if (index != -1) &#123;</span><br><span class="line">            remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        builder.append(String.format(&quot;Array size = %d, capacity = %d \n&quot;, size, data.length));</span><br><span class="line">        builder.append(&apos;[&apos;);</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            builder.append(data[i]);</span><br><span class="line">            if (i != size - 1) &#123;</span><br><span class="line">                builder.append(&quot;, &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(&apos;]&apos;);</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 扩容方法，时间复杂度 O (n)</span><br><span class="line">    private void resize(int capacity) &#123;</span><br><span class="line">        T[] newData = (T[]) new Object[capacity];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkIndex(int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt; size) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Add failed! Require index &gt;=0 and index &lt;= size.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkIndexForRemove(int index) &#123;</span><br><span class="line">        if(index &lt; 0 || index &gt;= size) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;remove failed! Require index &gt;=0 and index &lt; size.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个大小固定的有序数组，支持动态增删改操作；"><a href="#实现一个大小固定的有序数组，支持动态增删改操作；" class="headerlink" title="实现一个大小固定的有序数组，支持动态增删改操作；"></a>实现一个大小固定的有序数组，支持动态增删改操作；</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1) 数组的插入、删除、按照下标随机访问操作；</span><br><span class="line"> * 2）数组中的数据是 int 类型的；</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Array &#123;</span><br><span class="line"></span><br><span class="line">    // 定义整型数据 data 保存数据</span><br><span class="line">    private int[] data;</span><br><span class="line">    // 定义数组长度</span><br><span class="line">    private int n;</span><br><span class="line">    // 定义中实际个数</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    // 构造方法，定义数组大小</span><br><span class="line">    private Array(int capacity)&#123;</span><br><span class="line">        this.data = new int[capacity];</span><br><span class="line">        this.n = capacity;</span><br><span class="line">        this.count=0;// 一开始一个数都没有存所以为 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean change(int index, int value)&#123;</span><br><span class="line"></span><br><span class="line">        if (index&lt;0 || index&gt;=count) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //末尾追加</span><br><span class="line">    private boolean append(int value)&#123;</span><br><span class="line">        if (n == count) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[count++] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据索引，找到数据中的元素并返回</span><br><span class="line">    private int find(int index)&#123;</span><br><span class="line">        if (index&lt;0 || index&gt;=count) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入元素：头部插入，尾部插入</span><br><span class="line">    private boolean insert(int index, int value)&#123;</span><br><span class="line"></span><br><span class="line">        // 数组空间已满</span><br><span class="line">        if (count == n) &#123;</span><br><span class="line">            System.out.println(&quot; 没有可插入的位置 &quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 count 还没满，那么就可以插入数据到数组中</span><br><span class="line">        // 位置不合法</span><br><span class="line">        if (index &lt; 0||index &gt; count ) &#123;</span><br><span class="line">            System.out.println(&quot; 位置不合法 &quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 位置合法</span><br><span class="line">        for( int i = count; i &gt; index; --i)&#123;</span><br><span class="line">            data[i] = data[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = value;</span><br><span class="line">        ++count;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据索引，删除数组中元素</span><br><span class="line">    public boolean delete(int index)&#123;</span><br><span class="line">        if (index&lt;0 || index &gt;=count) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从删除位置开始，将后面的元素向前移动一位</span><br><span class="line">        for (int i=index+1; i&lt;count; ++i)&#123;</span><br><span class="line">            data[i-1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --count;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private void printAll() &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">            System.out.print(data[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Array array = new Array(5);</span><br><span class="line">        array.printAll();</span><br><span class="line">        array.insert(0, 3);</span><br><span class="line">        array.insert(0, 4);</span><br><span class="line">        array.insert(1, 5);</span><br><span class="line">        array.insert(3, 9);</span><br><span class="line">        array.insert(3, 10);</span><br><span class="line">        //array.insert(3, 11);</span><br><span class="line">        array.printAll();</span><br><span class="line">        int i = array.find(4);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        boolean delete = array.delete(2);</span><br><span class="line">        array.printAll();</span><br><span class="line">        array.append(10);</span><br><span class="line">        array.printAll();</span><br><span class="line">        array.change(4, 11);</span><br><span class="line">        array.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里只是以int类型作参考，通用类型可以参照第一个例子；</span><br></pre></td></tr></table></figure><h2 id="实现两个有序数组合并为一个有序数组；"><a href="#实现两个有序数组合并为一个有序数组；" class="headerlink" title="实现两个有序数组合并为一个有序数组；"></a>实现两个有序数组合并为一个有序数组；</h2><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素</li></ul><p>方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    //创建一个大小为m的数组，将传入的数组nums1复制到新创建的nums1_copy数组</span><br><span class="line">    int [] nums1_copy = new int[m];</span><br><span class="line">    System.arraycopy(nums1, 0, nums1_copy, 0, m);</span><br><span class="line"></span><br><span class="line">    //p1和p2指针指向nums1_copy和nums2数组索引为0的位置</span><br><span class="line">    int p1 = 0;</span><br><span class="line">    int p2 = 0;</span><br><span class="line">    //p1指针指向nums1数组索引为0的位置</span><br><span class="line">    int p = 0;</span><br><span class="line"></span><br><span class="line">    while ((p1 &lt; m) &amp;&amp; (p2 &lt; n))&#123;</span><br><span class="line">        nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    if (p1 &lt; m)</span><br><span class="line">      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    if (p2 &lt; n)</span><br><span class="line">      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度 : O(n+m)。</li><li>空间复杂度 : O(m)。</li></ul><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    int p1 = m - 1;</span><br><span class="line">    int p2 = n - 1;</span><br><span class="line">   </span><br><span class="line">    int p = m + n - 1;</span><br><span class="line"></span><br><span class="line">    while ((p1 &gt;= 0) &amp;&amp; (p2 &gt;= 0))&#123;</span><br><span class="line">       nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度 : O(n+m)。</li><li>空间复杂度 : O(1)。</li></ul><p>方法一和方法二思想差不多，但是方法二更加巧妙一点，方法二是倒序遍历，利用了nums1的长度大于等于m+n；</p><p>[参考连接] <a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">https://github.com/wangzheng0822/algo</a><br>[参考连接] <a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/solution/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法之美专栏中数组的常用题解；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-数组" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之数组求和</title>
    <link href="http://yoursite.com/2019/05/03/LeetCode%E4%B9%8B%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2019/05/03/LeetCode之数组求和/</id>
    <published>2019-05-03T15:34:34.000Z</published>
    <updated>2019-09-25T06:53:15.036Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定一个整数数组nums和一个目标值target,请你在改数组中找出和为目标值的那两个整数，返回他们的数组下标；</p><a id="more"></a><p>方法一：</p><pre><code>private static int[] arraySum(int[] nums, int target){    for(int i = 0; i &lt; nums.length; i++){        for (int j = i+1; j &lt; nums.length; j++){            if (nums[i] + nums[j] == target){                return new int[]{i, j};            }        }    }    return null;}public static void main(String[] args) {    int[] arr = new int[]{2, 12, 3, 6, 0, 10};    int target = 9;    int[] ints = arraySum(arr, target);    if (null != ints){        for (int anInt : ints) {            System.out.println(anInt);        }    }}</code></pre><p>方法二：</p><pre><code>public static void main(String[] args) {    int[] arr = new int[]{2, 12, 3, 6, 0, 10};    int target = 9;    int[] ints = arraySum(arr, target);    if (null != ints){        for (int anInt : ints) {            System.out.println(anInt);        }    }}private static int[] arraySum(int[] sums, int target){    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; sums.length; i++) {        if (map.containsKey(target - sums[i])){            return new int[]{map.get(target - sums[i]), i};        }        map.put(sums[i], i);    }    return null;}</code></pre><p>方法一比较暴力，使用的是双层循环，时间复杂度比较高；<br>方法二比较柔和一点，没有采用双循环的方法，复杂度比较低，推荐第一种方法；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：给定一个整数数组nums和一个目标值target,请你在改数组中找出和为目标值的那两个整数，返回他们的数组下标；&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构系列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>为何非要学数据结构和算法</title>
    <link href="http://yoursite.com/2019/04/22/%E4%B8%BA%E4%BD%95%E9%9D%9E%E8%A6%81%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/22/为何非要学数据结构和算法/</id>
    <published>2019-04-22T11:36:34.000Z</published>
    <updated>2019-09-25T06:53:51.143Z</updated>
    
    <content type="html"><![CDATA[<p>计算机专业里数据结构这门课在大学是必修课，很多程序员在毕业之后都忘得差不多了。总觉得数据结构与算法、操作系统、计算机网络是脱离实际工作的知识。在实际工作中即使你不懂数据结构和算法，照样也可以把代码敲得飞起。那么既然不懂这些也可以，为什么还要学数据结构和算法呢，大概是不想做一个CRUD boy吧!</p><a id="more"></a><p>只要对编程还有追求，就应该学一下数据结构，这样你就不在是只会写能用的代码了，而是高性能的代码。掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。在我看来数据结构和算法应该算得上是程序员的核心竞争力了，而且学习数据结构和算法可以改变你的思维方式。我大学老师曾经和我们说过程序员有两个是必须要会的，一是数据结构与算法，二是英语。你会其中一个，只能说你走的比较快而已，只有两个都会，你才能飞起来。当初不以为然，工作时间越长，发现老师说的非常对。接下来的一段时间我会持续更新数据结构与算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机专业里数据结构这门课在大学是必修课，很多程序员在毕业之后都忘得差不多了。总觉得数据结构与算法、操作系统、计算机网络是脱离实际工作的知识。在实际工作中即使你不懂数据结构和算法，照样也可以把代码敲得飞起。那么既然不懂这些也可以，为什么还要学数据结构和算法呢，大概是不想做一个CRUD boy吧!&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构系列" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized关键字总结</title>
    <link href="http://yoursite.com/2019/04/15/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/Synchronized关键字总结/</id>
    <published>2019-04-15T12:04:48.000Z</published>
    <updated>2019-09-25T06:43:54.778Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法，但是其他线程还是可以访问该实例对象的其他非 synchronized 方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1 (当前对象锁是 obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2 (当前对象锁是 obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了。</p><a id="more"></a></li><li><p>synchronized用在类中的非静态方法中，synchronized锁住的是对象this，只有调用同一个对象的方法才需要获取锁，并且同一个对象中所有加了synchronized关键字的非静态方法只能一次调用一个。</p></li><li><p>两个线程用同一个对象分别访问该对象的两个同步方法，会产生互斥。因为synchronized锁针对的是对象，当对象调用一个 synchronized 方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p></li><li><p>不同对象在两个线程中调用同一个同步方法，不会产生互斥。因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是 new 一个对象，那么就会出现两个空间，两把钥匙；</p></li><li><p>synchronized用在类中的静态方法中，synchronized锁住的是（类.class），改类中所有加了synchronized的静态方法，一次只能被调用一个。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>①用类直接在两个线程中调用两个不同的同步方法，会产生互斥。因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有 N 个房间，一把锁，因此房间（同步方法）之间一定是互斥的。<br>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p><p>②用一个类的静态对象在两个线程中调用静态方法或非静态方法，会产生互斥。<br>解释：因为是一个对象调用，同上。</p><p>③一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法，不会产生互斥。</p><p>[参考链接] <a href="https://blog.csdn.net/Amen_Wu/article/details/80799840" target="_blank" rel="noopener">https://blog.csdn.net/Amen_Wu/article/details/80799840</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法，但是其他线程还是可以访问该实例对象的其他非 synchronized 方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1 (当前对象锁是 obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2 (当前对象锁是 obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程Synchronized" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8BSynchronized/"/>
    
  </entry>
  
  <entry>
    <title>java集合</title>
    <link href="http://yoursite.com/2019/04/15/java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/04/15/java集合/</id>
    <published>2019-04-15T10:38:34.000Z</published>
    <updated>2019-09-25T06:55:11.750Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合大致可以分为 Set、List、Queue 和 Map 四种体系，<br>其中 Set 代表无序、不可重复的集合；<br>List 代表有序、重复的集合；<br>而 Map 则代表具有映射关系的集合；<br>Java 5 又增加了 Queue 体系集合，代表一种队列集合实现。<br>Java 集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进” 该容器中。<br>从 Java 5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。<br>Java 集合和数组的区别：</p><a id="more"></a><ol><li><p>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。<br>同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。</p></li><li><p>数组元素即可以是基本类型的值，也可以是对象。<br>集合里只能保存对象（实际上只是保存对象的引用变量），<br>基本数据类型的变量要转换成对应的包装类才能放入集合类中。</p></li></ol><p>Java 集合类之间的继承关系:<br>Java 的集合类主要由两个接口派生而出：Collection 和 Map,<br>Collection 和 Map 是 Java 集合框架的根接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- Collection</span><br><span class="line">  -Set</span><br><span class="line">      --SortedSet</span><br><span class="line">         ---TreeSet</span><br><span class="line">      --HashSet</span><br><span class="line">         ---LinkedHashSet</span><br><span class="line">      --EnumSet</span><br><span class="line">   -Queue</span><br><span class="line">      --PriorityQueue</span><br><span class="line">      --Deque</span><br><span class="line">         ---ArraryDeque</span><br><span class="line">         ---LinkedList</span><br><span class="line">   -List</span><br><span class="line">      --ArrayList</span><br><span class="line">         ---AttributeList</span><br><span class="line">      --Vector</span><br><span class="line">         ---Stack</span><br><span class="line">      ---LinkedList</span><br></pre></td></tr></table></figure><p>图中，ArrayList,HashSet,LinkedList,TreeSet 是我们经常会有用到的已实现的集合类。<br>list是有序(插入顺序和输出顺序)有重，set无序无重；<br>1.list–&gt;ArrayList,linkedList,Vector介绍：<br>元素都是通过索引的方式访问的，元素都是object子对象；<br>底层实现<br>linkedList是链表，其他两个都是数组；<br>使用场景<br>ArrayList：查询频率高，线程不安全<br>LinkedList：增加删除频率高，线程不安全<br>vector：线程安全</p><p>2.set–&gt;HashSet,TreeSet,LinkedHashSet<br>HashSet是无序的，TreeSet有序遍历成员，LinkedHashSet按照插入顺序遍历，都不允许重复元素；<br>底层实现<br>HashSet是hash表<br>TreeSet是二叉树(红黑树)<br>LinkedHashSet是链表、散列表<br>使用场景<br>HashSet查询最快<br>TreeSet升序排序<br>LinkedHashSet按照插入顺序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Map</span><br><span class="line">   -SortedMap</span><br><span class="line">      --TreeMap</span><br><span class="line">   -HashMap</span><br><span class="line">      --LinkedHashMap</span><br><span class="line">  -HashTable</span><br><span class="line">      --Properties</span><br></pre></td></tr></table></figure><p>Map 实现类用于保存具有映射关系的数据。Map 保存的每项数据都是 key-value 对，<br>也就是由 key 和 value 两个值组成。Map 里的 key 是不可重复的，key 用户标识集合里的每项数据.<br>1.Map–&gt;HashMap、TreeMap<br>HashMap底层是hash表，无序，频繁的插入、删除、查询元素<br>TreeMap底层是二叉树(红黑树)，有序，按照键升序遍历输出</p><p>阻塞队列<br>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供的阻塞队列：<br>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br>ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);<br>访问者的公平性是使用可重入锁实现的，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><p>详情请看阻塞队列</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 集合大致可以分为 Set、List、Queue 和 Map 四种体系，&lt;br&gt;其中 Set 代表无序、不可重复的集合；&lt;br&gt;List 代表有序、重复的集合；&lt;br&gt;而 Map 则代表具有映射关系的集合；&lt;br&gt;Java 5 又增加了 Queue 体系集合，代表一种队列集合实现。&lt;br&gt;Java 集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进” 该容器中。&lt;br&gt;从 Java 5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。&lt;br&gt;Java 集合和数组的区别：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java多线程概念</title>
    <link href="http://yoursite.com/2019/04/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/04/14/java多线程概念/</id>
    <published>2019-04-14T03:39:16.000Z</published>
    <updated>2019-09-25T06:57:03.109Z</updated>
    
    <content type="html"><![CDATA[<p>线程和进程的概念：<br>线程：进程中负责程序执行的执行单元，线程本身依靠程序进行运行；<br>线程是程序中顺序控制流，只能使用分配给程序的资源和环境；<br>进程：执行中的程序，一个进程至少包含一个线程；<br>单线程：程序中只存在一个线程，实际上主方法就是一个主线程；<br>多线程：在一个程序中运行多个任务，目的是更好的使用CPU资源；</p><a id="more"></a><p>并发与并行的概念：<br>并行：多个CPU实例或者多台机器同时执行一段处理逻辑，是真正的同时；<br>并发：通过CPU的调度算法，让用户看上去同时执行，实际上从CPU操作层面不是真正的同时，<br>并发往往在场景中有公共的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反映系统的处理能力；<br>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu 是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果。<br>同步：Java中同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的正确。例如在代码中简单的加入synchronize关键字，在保证结果正确的同时，提高了性能，线程安全优先级高于性能。</p><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停的切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下个任务，但是在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务的保存到再加载的过程就是一次上下文切换。</p><p>Java程序是操作系统的一个进程，而线程是进程中创建的贡献进程的资源。多线程主要是利用多处理器实现并发功能的。<br>并发原理：<br>多个线程“同时”运行只是我们感官上的一种表现。事实上线程是并发运行的（时间片轮转进程调度算法），单个CPU的情况下任何一个时间内有且仅有一个进程占有CPU，如果有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，各个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。OS将时间划分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行，而其他线程全部等，只要每个时间片段足够小，用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。所有并发技术不是绝对意义上的“同时发生”。</p><p>单核CPU(单处理器)上，只可能存在并发而不可能存在并行。并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作，每个小时间片执行一个操作，多个操作快速切换执行.</p><p>注意：Java中的多线程是一种抢占机制而不是分时机制。<br>抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。</p><p>Java中线程也是用一个对象(java.lang.Thread)来表示的。<br>每个进程至少有一个线程，作为程序的入口，通常情况下这个线程我们称之为主线程。<br>在Java中，程序的入口是main方法，因此main方法实际上就是运行在主线程中的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程和进程的概念：&lt;br&gt;线程：进程中负责程序执行的执行单元，线程本身依靠程序进行运行；&lt;br&gt;线程是程序中顺序控制流，只能使用分配给程序的资源和环境；&lt;br&gt;进程：执行中的程序，一个进程至少包含一个线程；&lt;br&gt;单线程：程序中只存在一个线程，实际上主方法就是一个主线程；&lt;br&gt;多线程：在一个程序中运行多个任务，目的是更好的使用CPU资源；&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java多线程实现" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>hdfs原理</title>
    <link href="http://yoursite.com/2019/04/13/hdfs%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/13/hdfs原理/</id>
    <published>2019-04-13T11:36:47.000Z</published>
    <updated>2019-04-13T11:37:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hadoop原理" scheme="http://yoursite.com/tags/hadoop%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2019/04/13/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/04/13/冒泡排序/</id>
    <published>2019-04-13T11:32:13.000Z</published>
    <updated>2019-04-13T11:33:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://yoursite.com/2019/04/13/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/13/垃圾回收机制/</id>
    <published>2019-04-13T11:10:22.000Z</published>
    <updated>2019-04-13T11:10:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
