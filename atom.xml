<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-08T11:11:31.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/07/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/07/ConcurrentHashMap详解/</id>
    <published>2020-07-07T11:57:10.000Z</published>
    <updated>2020-07-08T11:11:31.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>ConcurrentHashMap 是 HashMap 的线程安全版本；</li><li>不允许 [key,value] 为 null;</li><li>比 Hashtable 锁粒度更细；</li><li>采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构一样，数组 + 链表 / 红黑二叉树；</li><li>负载因子 0.75;</li><li>默认初始化容量 16;</li><li>put 时当前 bucket 为空时，使用 CAS 操作，将 Node 放入对应的 bucket 中；</li><li>put 时出现 hash 冲突，则采用 synchronized;</li><li>查询操作不加锁，因此 ConcurrentHashMap 不是强一致性；</li><li>ConcurrentHashMap 内部采用的锁有 synchronized、CAS、自旋锁、分段锁、volatile;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap 是 HashMap 的线程安全版本；&lt;/li&gt;
&lt;li&gt;不允许 [key,value] 为 
      
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>quartz定时任务</title>
    <link href="http://yoursite.com/2020/07/06/quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/06/quartz定时任务/</id>
    <published>2020-07-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:36:45.678Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Quartz-API-的关键接口是："><a href="#Quartz-API-的关键接口是：" class="headerlink" title="Quartz API 的关键接口是："></a>Quartz API 的关键接口是：</h4><ul><li>Scheduler - 与调度程序交互的主要 API。</li><li>Job - 由希望由调度程序执行的组件实现的接口。</li><li>JobDetail - 用于定义作业的实例。</li><li>Trigger（即触发器） - 定义执行给定作业的计划的组件。</li><li>JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。</li><li>TriggerBuilder - 用于定义 / 构建触发器实例。</li></ul><a id="more"></a><ul><li><p>定时任务类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void run() throws SchedulerException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;journal&quot;, journalService);//可以保存到JobExecutionContext中</span><br><span class="line">        SchedulerFactory schedFact = new StdSchedulerFactory();</span><br><span class="line">        Scheduler sched = schedFact.getScheduler();</span><br><span class="line">        sched.start();</span><br><span class="line"></span><br><span class="line">        JobDetail job = newJob(SimpleTestJob.class)</span><br><span class="line">                .withIdentity(&quot;myJob&quot;, &quot;group&quot;)</span><br><span class="line">                .usingJobData(new JobDataMap(map))</span><br><span class="line">                .build();</span><br><span class="line">        Trigger trigger = newTrigger()</span><br><span class="line">                .withIdentity(&quot;myTrigger&quot;, &quot;group&quot;)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(simpleSchedule()</span><br><span class="line">                .withIntervalInMinutes(5)//设置定时任务间隔时间</span><br><span class="line">                .repeatForever())</span><br><span class="line">                .build();</span><br><span class="line">        sched.scheduleJob(job, trigger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体执行任务的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTestJob implements Job &#123;</span><br><span class="line"></span><br><span class="line">    private JournalService journalService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; jobParams = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        for (String string : jobParams.keySet()) &#123;</span><br><span class="line">            Object obj = jobParams.get(string);</span><br><span class="line">            journalService = (JournalService) obj;</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">        String format = dateFormat.format(new Date());</span><br><span class="line">        System.out.println(&quot;----------------------- &quot; + format + &quot; -------------------------&quot;);</span><br><span class="line">        List&lt;Journal&gt; journalList = journalService.selectByOperateDate(format);</span><br><span class="line">        for (Journal journal : journalList) &#123;</span><br><span class="line">            String str = dateFormat.format(journal.getOperateDate());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Quartz-API-的关键接口是：&quot;&gt;&lt;a href=&quot;#Quartz-API-的关键接口是：&quot; class=&quot;headerlink&quot; title=&quot;Quartz API 的关键接口是：&quot;&gt;&lt;/a&gt;Quartz API 的关键接口是：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Scheduler - 与调度程序交互的主要 API。&lt;/li&gt;
&lt;li&gt;Job - 由希望由调度程序执行的组件实现的接口。&lt;/li&gt;
&lt;li&gt;JobDetail - 用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;Trigger（即触发器） - 定义执行给定作业的计划的组件。&lt;/li&gt;
&lt;li&gt;JobBuilder - 用于定义 / 构建 JobDetail 实例，用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;TriggerBuilder - 用于定义 / 构建触发器实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="quartz" scheme="http://yoursite.com/categories/quartz/"/>
    
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>post请求url中https报错问题</title>
    <link href="http://yoursite.com/2020/07/05/post%E8%AF%B7%E6%B1%82url%E4%B8%ADhttps%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/05/post请求url中https报错问题/</id>
    <published>2020-07-05T11:57:10.000Z</published>
    <updated>2020-07-06T09:30:20.093Z</updated>
    
    <content type="html"><![CDATA[<ul><li>异常日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException:</span><br><span class="line">    Caused by: java.security.cert.CertificateException: No subject alternative names present</span><br><span class="line">        at sun.security.util.HostnameChecker.matchIP(Unknown Source)</span><br><span class="line">        at sun.security.util.HostnameChecker.match(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)</span><br><span class="line">at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SslHandshakeExc_NsanPresent&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">URL url = new URL(&quot;https://192.168.2.222:8443/wbsystem/login.jsp&quot;);</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sc.init(null, trustAllCerts, null);</span><br><span class="line">HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line"> </span><br><span class="line">HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</span><br><span class="line"> </span><br><span class="line">// 新增部分</span><br><span class="line">conn.setHostnameVerifier(new Servlet_test().new TrustAnyHostnameVerifier());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 定制Trust</span><br><span class="line">static TrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)</span><br><span class="line">throws CertificateException &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; &#125;;</span><br><span class="line"> </span><br><span class="line">// 定制Verifier</span><br><span class="line">public class TrustAnyHostnameVerifier implements HostnameVerifier &#123;</span><br><span class="line"></span><br><span class="line">public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;异常日志&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;javax.net.ssl.SSLHandshakeException:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Caused by: java.security.cert.CertificateException: No subject alternative names present&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.matchIP(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at sun.security.util.HostnameChecker.match(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkIdentity(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http请求" scheme="http://yoursite.com/categories/http%E8%AF%B7%E6%B1%82/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>java中变量初始化</title>
    <link href="http://yoursite.com/2020/07/04/java%E4%B8%AD%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/04/java中变量初始化/</id>
    <published>2020-07-04T11:57:10.000Z</published>
    <updated>2020-07-06T09:48:55.654Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的笔记，今天放到自己的博客中；</p><a id="more"></a><p>1.对于类的成员变量，不管程序有没有显式的进行初始化，Java虚拟机都会先自动给它初始化为默认值；<br>默认值如下：<br>boolean  false<br>char     ‘\u0000’<br>byte     0<br>short    0<br>int      0<br>long     0<br>float    0.0f<br>double   0.0d</p><p>2.局部变量声明之后，Java虚拟机就不会自动给他初始化为默认值，因此局部变量使用之前必须进行显示的初始化。<br>但是需要声明的是：对于只负责接收一个表达式的值的局部变量可以不初始化，参与运算和直接输出等其他的情况的局部变量需要进行初始化</p><p>通过下面这个测试可以看到JVM对哪些数据初始化，哪写数据不初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestStatic &#123;</span><br><span class="line">    static int x; //类的成员变量，JVM负责初始化</span><br><span class="line">    static int method() &#123;</span><br><span class="line">        int y=0;  //此处必须自己初始化，它不属于类成员变量，是个method的局部变量，JVM不负责初始化</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestStatic as=new TestStatic();</span><br><span class="line">        int z=0;  //此处必须自己初始化，它不属于类成员变量，是个主函数里的局部变量，JVM不负责初始化</span><br><span class="line">        int aa=3; //此处aa参与了运算，所以必须初始化</span><br><span class="line">        aa=aa+2;</span><br><span class="line">        int a=1,b=2,max; //max只是负责接收表达式的值，不需要初始化</span><br><span class="line">        max=a&gt;b?2:1; </span><br><span class="line">        System.out.println(max); //1</span><br><span class="line">        System.out.println(aa); //5</span><br><span class="line">        System.out.println(&quot;z=&quot;+z); //z=0</span><br><span class="line">        System.out.println(&quot;x=&quot;+as.x); //x=0  </span><br><span class="line">        System.out.println(&quot;y=&quot;+as.method()); //y=0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结为一句话便是：类里定义的数据成员称为属性，属性可不赋初值，若不赋初值则JAVA会按上表为其添加默认值；方法里定义的数据成员称为变量，变量在参与运算之前必须赋初值。</p></blockquote><p>[参考链接]<a href="http://www.jb51.net/article/90743.htm" target="_blank" rel="noopener">http://www.jb51.net/article/90743.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前的笔记，今天放到自己的博客中；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java是按值传递还是按引用传递</title>
    <link href="http://yoursite.com/2020/07/03/Java%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/07/03/Java是按值传递还是按引用传递/</id>
    <published>2020-07-03T11:57:10.000Z</published>
    <updated>2020-07-03T08:16:15.263Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在开始之前，我们先理解按值传递、按引用传递的概念。</li></ul><p>1、什么是值传递？<br>指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。</p><p>2、什么是引用传递<br>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><a id="more"></a><p>明确地说，java都是按值传递的！java的世界里，都是按值传递。其实按值、按引用都只是个概念，关键是我们如何去理解java传参的本质。</p><p>下面就结合一个例子来说，有些情况下，所传参数的值，是个“引用”，这一点容易让人产生困惑。</p><p>请看下面的例子<br>首先有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog = new Dog(&quot;Rover&quot;);</span><br><span class="line">foo(myDog);</span><br></pre></td></tr></table></figure><p>这时，你传给了foo函数一个参数，这个参数值，是个引用，也就是Rover这只dog的内存地址（这只是粗略的说明，因为在java中，这个地址并非是真正的地址）<br>假设这时候Rover的地址是42，那么，我们就是传了42这个地址给foo方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo(Dog someDog) &#123;</span><br><span class="line">    someDog.setName(&quot;Max&quot;);     // AAA</span><br><span class="line">    someDog = new Dog(&quot;Fifi&quot;);  // BBB</span><br><span class="line">    someDog.setName(&quot;Rowlf&quot;);   // CCC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步解析foo方法</p><p>1.参数 someDog的值是一个地址（42）</p><p>2.在AAA这一行：<br>someDog，也就是函数外声明的myDog，name从Rover被改成了Max</p><p>3.在BBB这一行：<br>这就是关键的地方了，又new了一只dog，new 意味着又在新的地址空间放上了一只Dog，我们假设其地址是74。这时，someDog的值，会从42变成了74</p><p>4.在CCC这一行：<br>这时候的修改，是对内存地址为74的那只狗的修改，而非原先的42</p><p>从这个例子，我们可以看到，foo方法的参数someDog，它是一个值，而非引用。如果它是引用，那么在foo方法内部的修改（包括BBB、CCC这两行），都应该会对42地址空间的dog产生影响，也就是方法外的参数，mydog也会指向新的地址空间。</p><p>不细究概念了，再总结下Java初学者容易犯错的地方：<br>假如你想像例子一样，传递一个对象到一个方法中，并由该方法修改对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Object();</span><br><span class="line">foo(a);//在方法内部修改a的属性值</span><br><span class="line">return a;//希望此时的a已经是修改后的值</span><br></pre></td></tr></table></figure><p>要切记，这个Objct一定要在调用方法前，就初始化好（new一个），然后再作为参数传进去，并且在方法中不能再初始化这个参数。这样，在方法中对该参数的修改，才会有效。</p><p>[stackoverflow链接]<br><a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在开始之前，我们先理解按值传递、按引用传递的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、什么是值传递？&lt;br&gt;指的是在方法调用时，传递的参数是按值的拷贝传递。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了，每个值都对应到一个地址空间。&lt;/p&gt;
&lt;p&gt;2、什么是引用传递&lt;br&gt;指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java时间转换</title>
    <link href="http://yoursite.com/2020/06/30/Java%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/06/30/Java时间转换/</id>
    <published>2020-06-30T11:57:10.000Z</published>
    <updated>2020-07-03T09:07:52.141Z</updated>
    
    <content type="html"><![CDATA[<ul><li>时间字符串和时间转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 把时间转换为字符串</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">Date date = new Date(136464513123L);</span><br><span class="line">String string = dateFormat.format(date);</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">// 把字符串转化为时间</span><br><span class="line">String string = &quot;2018-07-19&quot;;</span><br><span class="line">DateFormat dateFormat = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);// 这里要与时间字符串的格式一样即可，否则报错</span><br><span class="line">Date date = dateFormat.parse(string);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//默认输出格式</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date);//Fri Oct 27 16:56:37 CST 2017</span><br><span class="line">//日期格式化显示，首先定义格式</span><br><span class="line">SimpleDateFormat sdf1=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//显示20171027格式</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//显示2017-10-27格式</span><br><span class="line">SimpleDateFormat sdf3=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//显示2017-10-27 10:00:00格式</span><br><span class="line">SimpleDateFormat sdf4=new SimpleDateFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;);//显示2017年10月27日10时00分00秒格式</span><br><span class="line">//将格式应用于日期</span><br><span class="line">System.out.println(sdf1.format(date));//20171027</span><br><span class="line">System.out.println(sdf2.format(date));//2017-10-27</span><br><span class="line">System.out.println(sdf3.format(date));//2017-10-27 17:11:13</span><br><span class="line">System.out.println(sdf4.format(date));//2017年10月27日17时11分13秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;时间字符串和时间转换&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 把时间转换为字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat(&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = new Date(136464513123L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = dateFormat.format(date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--------------------------------------------------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 把字符串转化为时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = &amp;quot;2018-07-19&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DateFormat dateFormat = new SimpleDateFormat (&amp;quot;yyyy-MM-dd&amp;quot;);// 这里要与时间字符串的格式一样即可，否则报错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date date = dateFormat.parse(string);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(date);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java空字符串和null的区别</title>
    <link href="http://yoursite.com/2020/06/11/Java%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/06/11/Java空字符串和null的区别/</id>
    <published>2020-06-11T11:57:10.000Z</published>
    <updated>2020-07-07T06:42:16.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java空字符串与null的区别："><a href="#Java空字符串与null的区别：" class="headerlink" title="Java空字符串与null的区别："></a>Java空字符串与null的区别：</h3><ul><li>类型<br>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）<br>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）</li><li>内存分配<br>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；<br>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：<br>就如下：<br>String str = new String(“abc”) ;<br>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<a id="more"></a></li><li>示例程序：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 = new String() ;</span><br><span class="line">        String str2 = null ;</span><br><span class="line">        String str3 = &quot;&quot; ;</span><br><span class="line">        System.out.println(str1==str2);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str2==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         //值的比较，返回false</span><br><span class="line">        System.out.println(str1==str3);                //内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         //值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;&quot;; //str1对应一个空串，声明对象的引用</span><br><span class="line">String str2 = null; //str2引用为空</span><br><span class="line">String str3 = new String(); //str3将指向具体的String实例，默认值为“”</span><br><span class="line">注意：str1和str3被实例化，而str2没有实例化，但str1和str3所指的地址不同，但值一样，都为空。</span><br></pre></td></tr></table></figure><p>有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (str != null &amp;&amp; str.length() != 0)</span><br></pre></td></tr></table></figure><p>注意：首先要检查 str 不为 null。如果在一个 null 值上调用方法，会出现错误。</p><p>通过如上的程序可以得出如下结论：<br>字符串对象与null的值不相等，且内存地址也不相等；<br>空字符串对象与null的值不相等，且内存地址也不相等；<br>new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null）</p><p>以下是java 判断字符串是否为空的四种方法:<br>方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低:<br>                     if(s == null || s.equals(“”));<br>方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法:<br>                     if(s == null || s.length() == 0);<br>方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二.<br>                     if(s == null || s.isEmpty());<br>方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多:<br>                     if (s == null || s == “”);</p><p>注意:s == null 是有必要存在的.<br>　　“如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException.<br>　　并且s==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException.”<br>　　如下Java代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　String str = null;</span><br><span class="line">　　if(str.equals(&quot;&quot;) || str == null)&#123;//会抛出异常</span><br><span class="line">　　          System.out.println(&quot;success&quot;);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.cnblogs.com/qiuting/p/5373571.html" target="_blank" rel="noopener">https://www.cnblogs.com/qiuting/p/5373571.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java空字符串与null的区别：&quot;&gt;&lt;a href=&quot;#Java空字符串与null的区别：&quot; class=&quot;headerlink&quot; title=&quot;Java空字符串与null的区别：&quot;&gt;&lt;/a&gt;Java空字符串与null的区别：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类型&lt;br&gt;null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;没有分配内存，调用null的字符串的方法会抛出空指针异常。（例如：str1.endsWith(str2); java.lang.NullPointerException）&lt;br&gt;“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;占内存，在内存中分配一个空间，可以使用Object对象中的方法。（例如：“”.toString()等）&lt;/li&gt;
&lt;li&gt;内存分配&lt;br&gt;String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；&lt;br&gt;String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；&lt;br&gt;在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：&lt;br&gt;就如下：&lt;br&gt;String str = new String(“abc”) ;&lt;br&gt;ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>properties转yml配置文件</title>
    <link href="http://yoursite.com/2020/06/10/properties%E8%BD%ACyml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/06/10/properties转yml配置文件/</id>
    <published>2020-06-10T11:57:10.000Z</published>
    <updated>2020-07-07T02:35:13.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用在线问答转换 将各自properties文件转成yml文件类型<a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">https://www.toyaml.com/index.html</a></li><li>因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author yuezp</span><br><span class="line"> * @Date 2020/5/9 5:29 下午</span><br><span class="line"> * @Version v1.0</span><br><span class="line"> */</span><br><span class="line">public class YmlResourceFactory extends DefaultPropertySourceFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        String sourceName = (name == null) ? resource.getResource().getFilename() : name;</span><br><span class="line">        assert sourceName != null;</span><br><span class="line">        if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) &#123;</span><br><span class="line">            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();</span><br><span class="line">            factory.setResources(resource.getResource());</span><br><span class="line">            factory.afterPropertiesSet();</span><br><span class="line">            Properties properties = factory.getObject();</span><br><span class="line">            assert properties != null;</span><br><span class="line">            return new PropertiesPropertySource(sourceName, properties);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.createPropertySource(name, resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>APP启动类中的@PropertySource  修改为@PropertySource(value = {“classpath:application-服务名.yml”,”application-bdev.yml”},encoding = “UTF-8”, factory = YmlResourceFactory.class)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用在线问答转换 将各自properties文件转成yml文件类型&lt;a href=&quot;https://www.toyaml.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.toyaml.com/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因为@PropertySource 这个注解不支持 yml，所以需要自定义一下 source工厂。把这个类引入 :&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举使用</title>
    <link href="http://yoursite.com/2020/06/09/%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/09/枚举使用/</id>
    <published>2020-06-09T11:57:10.000Z</published>
    <updated>2020-07-07T02:31:32.632Z</updated>
    
    <content type="html"><![CDATA[<p>枚举例子如下 ：<br>普通java类定义常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Operation &#123;  </span><br><span class="line">    private String operType;</span><br><span class="line">    </span><br><span class="line">    private Operation(String operType)&#123; </span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static final Operation ADD = new Operation(&quot;add&quot;);</span><br><span class="line">    public static final Operation DELETE = new Operation(&quot;delete&quot;);</span><br><span class="line">    public static final Operation MODIFY= new Operation(&quot;modify&quot;);</span><br><span class="line">    public static final Operation SELECT = new Operation(&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">    public String getOperType() &#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>枚举定义常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum OperationByEnum&#123;</span><br><span class="line">    ADD(&quot;add&quot;), DELETE(&quot;delete&quot;), MODIFY(&quot;modify&quot;), SELECT(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看上述两个类的 class 文件可以看出两种方式可以认为是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap OperationByEnum.class</span><br><span class="line">Compiled from &quot;OperationByEnum.java&quot;</span><br><span class="line">public final class OperationByEnum extends java.lang.Enum&lt;OperationByEnum&gt; &#123;</span><br><span class="line">  public static final OperationByEnum ADD;</span><br><span class="line">  public static final OperationByEnum DELETE;</span><br><span class="line">  public static final OperationByEnum MODIFY;</span><br><span class="line">  public static final OperationByEnum SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">  public static OperationByEnum[] values();</span><br><span class="line">  public static OperationByEnum valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D:\java\workspace\EnumDemo\bin&gt;javap Operation.class</span><br><span class="line">Compiled from &quot;Operation.java&quot;</span><br><span class="line">public class Operation &#123;</span><br><span class="line">  public static final Operation ADD;</span><br><span class="line">  public static final Operation DELETE;</span><br><span class="line">  public static final Operation MODIFY;</span><br><span class="line">  public static final Operation SELECT;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  public java.lang.String getOperType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public enum  ClusterType &#123;</span><br><span class="line"></span><br><span class="line">    kafka,</span><br><span class="line">    storm,</span><br><span class="line"></span><br><span class="line">    hdfs (&quot;hello&quot;,&quot;world&quot;),</span><br><span class="line"></span><br><span class="line">    yarn (&quot;nihao&quot;, &quot;haode&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String key;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    ClusterType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClusterType(String key, String value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ClusterType&#123;&quot; +</span><br><span class="line">                &quot;key=&apos;&quot; + key + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, value=&apos;&quot; + value + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;&#125; &quot; + super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;111 = &quot; + ClusterType.kafka);</span><br><span class="line">        ClusterType.kafka.setKey(&quot;hello&quot;);</span><br><span class="line">        String key = ClusterType.kafka.getKey();</span><br><span class="line">        System.out.println(&quot;222 = &quot; + key);</span><br><span class="line"></span><br><span class="line">        ClusterType.kafka.setValue(&quot;world&quot;);</span><br><span class="line">        String value = ClusterType.kafka.getValue();</span><br><span class="line">        System.out.println(&quot;333 = &quot; + value);</span><br><span class="line"></span><br><span class="line">        ClusterType hdfs = ClusterType.hdfs;</span><br><span class="line">        System.out.println(&quot;444 = &quot; + hdfs);</span><br><span class="line">        String s = ClusterType.hdfs.getKey();</span><br><span class="line">        System.out.println(&quot;555 = &quot; + s);</span><br><span class="line">        String value1 = ClusterType.hdfs.getValue();</span><br><span class="line">        System.out.println(&quot;666 = &quot; + value1);</span><br><span class="line">        ClusterType[] values = ClusterType.values();</span><br><span class="line">        for (ClusterType clusterType : values) &#123;</span><br><span class="line">            System.out.println(clusterType);</span><br><span class="line">        &#125;</span><br><span class="line">        ClusterType hdfs1 = ClusterType.valueOf(&quot;hdfs&quot;);</span><br><span class="line">        System.out.println(hdfs1);</span><br><span class="line">        String s1 = ClusterType.class.toString();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举中valueof用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   String str = &quot;ADD&quot;;</span><br><span class="line">OperationByEnum ob = OperationByEnum.valueOf(str);</span><br><span class="line">System.out.println(ob == OperationByEnum.ADD);//TRUE</span><br><span class="line"></span><br><span class="line">String str2=&quot;add&quot;;</span><br><span class="line">OperationByEnum ob1 = OperationByEnum.valueOf(str2);</span><br></pre></td></tr></table></figure><p>枚举类是一种特殊的 JAVA 类，枚举类中每声明一个枚举值就代表枚举类的一个实例对象。<br>与 JAVA 普通类一样，声明枚举类时也可以声明类的属性、方法、构造函数，但构造函数必须为私有。<br>枚举类也可以实现接口，继承抽象类。可以作为 switch 语句的参数。<br>若枚举类只有一个枚举值，则可以当做单例设计模式使用。<br>注意：为什么要对weekend 构造函数进行私有化， 答：保证外界无法通过调用构造函数再实例化出一个非法的枚举<br>同理 string 也要进行私有化，防止外界的非法更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> * 带抽象方法的枚举</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public enum OperationByEnum &#123;</span><br><span class="line">    ADD(&quot;add&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;增&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    DELETE(&quot;delete&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;删&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    MODIFY(&quot;modify&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;改&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">    SELECT(&quot;select&quot;) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getChineseName()</span><br><span class="line">                &#123;</span><br><span class="line">                    return &quot;查&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    private String operType;</span><br><span class="line"></span><br><span class="line">    public String getOperType()&#123;</span><br><span class="line">        return operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OperationByEnum(String operType)&#123;</span><br><span class="line">        this.operType = operType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract String getChineseName();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        print(OperationByEnum.ADD);</span><br><span class="line">        String chineseName = OperationByEnum.ADD.getChineseName();</span><br><span class="line">        System.out.println(chineseName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print(OperationByEnum arg)&#123;</span><br><span class="line">        System.out.println(arg.getOperType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接：<a href="http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6" target="_blank" rel="noopener">http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html#title-6</a></p><p>常量的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package bonc.cn.com;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by yzp on 2017/11/6.</span><br><span class="line"> */</span><br><span class="line">public class ResultCode &#123;</span><br><span class="line"></span><br><span class="line">    public String code;</span><br><span class="line">    public String message;</span><br><span class="line"></span><br><span class="line">    public String getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSystemError() &#123;</span><br><span class="line">        return SYSTEM_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultCode getSUCCESS() &#123;</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ResultCode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultCode(String code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final ResultCode SUCCESS// 编译错误，常量需要初始化</span><br><span class="line">    public static final ResultCode SUCCESS = new ResultCode();</span><br><span class="line">    public static final ResultCode SYSTEM_ERROR = new ResultCode(&quot;E00001&quot;,&quot;系统错误&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ResultCode&#123;&quot; +</span><br><span class="line">                &quot;code=&apos;&quot; + code + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, message=&apos;&quot; + message + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ResultCode.SUCCESS.toString());</span><br><span class="line">        ResultCode.SUCCESS = new ResultCode(&quot;123&quot;, &quot;234&quot;);//报编译错误因为SUCCESS是常量</span><br><span class="line">        SUCCESS.setCode(&quot;nihao&quot;);//但是可以给常量赋值属性   &lt;--------------------</span><br><span class="line">        System.out.println(SUCCESS.getCode()); // 输出nihao                   -</span><br><span class="line">        System.out.println(ResultCode.SYSTEM_ERROR.toString());               -</span><br><span class="line">    &#125;                                                                         -</span><br><span class="line">                                                                              -</span><br><span class="line">                                                                              -</span><br><span class="line">&#125;                                                                             -</span><br><span class="line">```                                                                           -</span><br><span class="line">final修饰的变量一般用于常量的定义上，因为一旦定义就无法改变了                      -</span><br><span class="line">（基础数据类型的话，无法改变的是值；引用数据类型的话，无法改变的是引用              -</span><br><span class="line">&lt;引用不能改变即存在变量中的地址无法改变，但是引用的值是可以通过方法来改变的&gt;）。-----&gt;</span><br><span class="line">PS：本质上基础数据类型跟引用数据类型在内存中的都是值，</span><br><span class="line">只不过这个值对于用户的含义不同，一个存储的就是值本身，一个存储的值是引用地址。</span><br><span class="line">常量可以在定义时不初始化，但是必须在静态代码块中初始化。如下例子：</span><br></pre></td></tr></table></figure><p>package bonc.cn.com;</p><p>/**</p><ul><li><p>Created by yzp on 2017/11/6.</p></li><li><p>/<br>public class StringStudy {</p><p>  public static final String STR;<br>  public static final A a;<br>  static {</p><pre><code>STR = &quot;INIT&quot;;a = new A();a.a = &quot;abc&quot;;//常量可以在静态代码块中初始化，但是不允许修改引用，不过引用的对象中的属性是可以随意修改的。</code></pre><p>  }</p></li></ul><p>}</p><p>class A {<br>    String a;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">常量的三种动态初始化：</span><br></pre></td></tr></table></figure><p>public class Configuration {</p><p>public static final String CONFIG = “你想要指定的一些配置项”;</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">当我们需要给Configuration类中的CONFIG常量第一次使用时动态指定一个值时，而此时我们又不想去修改源代码，那我们有三种方法去实现这种需求。</span><br><span class="line"></span><br><span class="line">第一种：使用一个static静态代码块来指定，然后在静态代码块中，我们去动态读取外部的一个Properties文件的值。（最推荐）</span><br></pre></td></tr></table></figure><p>import java.util.Properties;</p><p>/**</p><ul><li><p>第一种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>Properties properties = new Properties();//把一个properties读进来CONFIG = &quot;properties.getConfig&quot;;//通过properties的配置项config来初始化我们的常量config</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二种：我们可以配置Java的运行时配置，来指定一个-Dname=value的参数，这样也可以在类内部动态的接受到运行时指定的一个参数。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第二种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getProperty(&quot;CONFIG&quot;);//通过系统的-D配置参数name=value形式来拿到这个配置值//如果是eclipse，右键-&gt;RUN AS-&gt;Run Configurations-&gt;arguments-&gt;VMarguments 里输入（-DCONFIG=我们想要加入的配置）</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三种：我们还可以读的到系统配置的PATH或者CLASSPATH里面的值，同理，我们也可以配置自己的环境变量，然后在程序中一样也能读到这些配置的环境变量。</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li><p>第三种实现方法</p></li><li><p>@author William</p></li><li></li><li><p>/<br>public class Configuration {</p><p>  public static final String CONFIG;//常量声明时不马上初始化</p><p>  static {</p><pre><code>CONFIG = System.getenv(&quot;PATH&quot;);//通过System.getenv()方法可以拿到系统环境变量，但我自己指定的环境变量没有取得成功，如果有知道原因的给我留言哈谢谢</code></pre><p>  }</p><p>  public static void main(String[] args) {</p><pre><code>System.out.println(Configuration.CONFIG);</code></pre><p>  }<br>}</p></li></ul><p>final double PI=3.1415926</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原先很多书上说常量的初始化只有在定义的时候才可以，</span><br><span class="line">像上边的代码一样。其实常量的初始化也可以在构造函数中定义，但要注意必须要在所有重载的构造函数中都要定义一遍。</span><br><span class="line">常量在JAVA中经常定义成静态的static，这是为了节省内存，也是因为他是不能改变的。</span><br><span class="line">于是变成了：</span><br></pre></td></tr></table></figure><p>statis final double PI=3.1415926</p><pre><code>当定义静态常量的时候，就不能使用构造函数初始化常量了，这是因为我们经常直接使用类名调用静态成员，而构造函数的第一次运行，是在第一次new这个类的对象的时候。我们如果不去new，那么常量就永远不能初始化。所以，这个时候必须用上边的代码直接初始化。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举例子如下 ：&lt;br&gt;普通java类定义常量&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Operation &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Operation(String operType)&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this.operType = operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation ADD = new Operation(&amp;quot;add&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation DELETE = new Operation(&amp;quot;delete&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation MODIFY= new Operation(&amp;quot;modify&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static final Operation SELECT = new Operation(&amp;quot;select&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getOperType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return operType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://yoursite.com/2020/06/06/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/06/06/Java泛型/</id>
    <published>2020-06-06T11:57:10.000Z</published>
    <updated>2020-07-07T06:49:06.874Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lt-extends-T-gt-和-lt-super-T-gt-的区别"><a href="#lt-extends-T-gt-和-lt-super-T-gt-的区别" class="headerlink" title="&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别"></a>&lt;? extends T&gt; 和 &lt;? super T &gt; 的区别</h4><ul><li>&lt;? extends T&gt; 表示该通配符所代表的类型是 T 类型的子类。</li><li>&lt;? super T&gt; 表示该通配符所代表的类型是 T 类型的父类。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fun():</span><br><span class="line">&lt;T&gt;是用来规范T的，例如&lt;T extends Object&gt;就规定了边界，</span><br><span class="line">即规定了所有出现T的地方，T类型必须是Object的子类。</span><br><span class="line"></span><br><span class="line">Box 类定义为一个泛型类:</span><br><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T object;</span><br><span class="line"></span><br><span class="line">    public void set(T object) &#123; this.object = object; &#125;</span><br><span class="line">    public T get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建一个 Box 对象，不带泛型参数，发现获取对象的时候需要强制转换</span><br><span class="line"></span><br><span class="line">Box box2 = new Box();</span><br><span class="line">box2.set(new Apple());</span><br><span class="line">Apple apple = (Apple) box2.get();</span><br><span class="line">创建一个 Box 对象，带泛型参数，获取对象的时候就不需要强制转换</span><br><span class="line"></span><br><span class="line">Box&lt;Apple&gt; box = new Box&lt;Apple&gt;();</span><br><span class="line">box.set(new Apple());</span><br><span class="line">Apple apple = box.get();</span><br><span class="line">总结下泛型的好处就是</span><br><span class="line">省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上;</span><br></pre></td></tr></table></figure><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 element(即元素)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Test&lt;T&gt; &#123;    </span><br><span class="line">    public List&lt;T&gt; list = new ArrayList&lt;T&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">和</span><br><span class="line">public class Test&lt;A&gt; &#123;    </span><br><span class="line">    public List&lt;A&gt; list = new ArrayList&lt;A&gt;();   </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test&lt;String&gt; test = new Test&lt;String&gt;();</span><br><span class="line">        test.list.add(&quot;hello&quot;);</span><br><span class="line">        System.out.println(test.list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 T 换成了 A，在执行效果上是没有任何区别的，只不过我们约定好了 T 代表 type，<br>所以还是按照约定规范来比较好，增加了代码的可读性；</p><p>如果要定义多个泛型参数，比如说两个泛型参数<br>很典型的一个栗子是 Map 的 key,value 泛型，我们也可以定义一个这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Mymap&lt;K, V&gt; &#123;</span><br><span class="line">    public K getKey();</span><br><span class="line">    public V getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MymapImpl&lt;K, V&gt; implements Mymap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public MymapImpl(K key, V value) &#123;</span><br><span class="line">       this.key = key;</span><br><span class="line">       this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey()    &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来就可以传入任意类型，创建实例了，不用转化类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mymap&lt;String, Integer&gt; mp1= new MymapImpl&lt;String, Integer&gt;(&quot;Even&quot;, 8);</span><br><span class="line">Mymap&lt;String, String&gt;  mp2= new MymapImpl&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">Mymap&lt;Integer, Integer&gt; mp3= new MymapImpl&lt;Integer, Integer&gt;(888, 888);</span><br></pre></td></tr></table></figure><h4 id="List，List，List-lt-gt-区别"><a href="#List，List，List-lt-gt-区别" class="headerlink" title="List，List，List&lt;?&gt; 区别"></a>List<t>，List<object>，List&lt;?&gt; 区别</object></t></h4><ul><li>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是 T 类型</t></t></li><li>ArrayList<?> al=new ArrayList<?>(); 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</li><li>ArrayList&lt;? extends E&gt; al=new ArrayList&lt;? extends E&gt;();<br>泛型的限定：<br>? extends E: 接收 E 类型或者 E 的子类型。<br>? super E: 接收 E 类型或者 E 的父类型<br>? 和 T 区别是？是一个不确定类，？和 T 都表示不确定的类型 ，<br>但如果是 T 的话，函数里面可以对 T 进行操作，比方 T car = getCar()，而不能用？ car = getCar()。</li></ul><p>[参考链接]<a href="http://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">http://www.jianshu.com/p/95f349258afb</a><br>[参考链接]<a href="http://frankco.iteye.com/blog/1668466" target="_blank" rel="noopener">http://frankco.iteye.com/blog/1668466</a></p><h4 id="最后来说说-T，Class，Class-lt-gt-区别："><a href="#最后来说说-T，Class，Class-lt-gt-区别：" class="headerlink" title="最后来说说 T，Class，Class&lt;?&gt; 区别："></a>最后来说说 T，Class<t>，Class&lt;?&gt; 区别：</t></h4><p>T 是一种具体的类，例如 String,List,Map…… 等等，这些都是属于具体的类，这个比较好理解<br>Class 是什么呢，Class 也是一个类，但 Class 是存放上面 String,List,Map…… 类信息的一个类，有点抽象，我们一步一步来看 。</p><p>如何获取到 Class 类呢，有三种方式：</p><ol><li>调用 Object 类的 getClass() 方法来得到 Class 对象，这也是最常见的产生 Class 对象的方法。<br>例如：</li></ol><p>List list = null;<br>Class clazz = list.getClass();</p><ol start="2"><li>使用 Class 类的中静态 forName() 方法获得与字符串对应的 Class 对象。<br>例如：Class clazz = Class.forName(“com.lyang.demo.fanxing.People”);</li><li>获取 Class 类型对象的第三个方法非常简单。如果 T 是一个 Java 类型，那么 T.class 就代表了匹配的类对象。<br>Class clazz = List.class;<br>那么问题来了，Class 类是创建出来了，但是 Class<t> 和 Class&lt;?&gt; 适用于什么时候呢？</t></li></ol><p>使用 Class<t> 和 Class&lt;?&gt; 多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。<br>People people = (People) Class.forName(“com.lyang.demo.fanxing.People”).newInstance();<br>看到了么，需要强转，如果反射的类型不是 People 类，就会报<br>java.lang.ClassCastException 错误。</t></p><p>使用 Class<t> 泛型后，不用强转了</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        return clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  throws IllegalAccessException, InstantiationException  &#123;</span><br><span class="line">            Fruit fruit= createInstance(Fruit .class);</span><br><span class="line">            People people= createInstance(People.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 Class<t> 和 Class<?> 有什么区别呢？Class<t> 在实例化的时候，T 要替换成具体类Class<?> 它是个通配泛型，? 可以代表任何类型，主要用于声明时的限制情况<br>例如可以声明一个<br>public Class<?> clazz;但是你不能声明一个public Class<t> clazz;因为 T 需要指定类型所以当不知道定声明什么类型的 Class 的时候可以定义一个 Class<?>,Class&lt;?&gt; 可以用于参数类型定义，方法返回值定义等。</t></t></t></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;lt-extends-T-gt-和-lt-super-T-gt-的区别&quot;&gt;&lt;a href=&quot;#lt-extends-T-gt-和-lt-super-T-gt-的区别&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&quot;&gt;&lt;/a&gt;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T &amp;gt; 的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;? extends T&amp;gt; 表示该通配符所代表的类型是 T 类型的子类。&lt;/li&gt;
&lt;li&gt;&amp;lt;? super T&amp;gt; 表示该通配符所代表的类型是 T 类型的父类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>方法中参数前有final修饰</title>
    <link href="http://yoursite.com/2020/06/05/%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0%E5%89%8D%E6%9C%89final%E4%BF%AE%E9%A5%B0/"/>
    <id>http://yoursite.com/2020/06/05/方法中参数前有final修饰/</id>
    <published>2020-06-05T11:57:10.000Z</published>
    <updated>2020-07-07T01:05:31.892Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；</p><p>如下基本数据类型的代码例子：</p><pre><code>/** * final修饰的基本数据类型的值是不能够改变的 * @param i */public static void setValue(final int i) {    //编译通不过，基本数据类型不能够改变    i = 10;}</code></pre><p>如下引用数据类型的代码例子：</p><pre><code>/** * 对应final修饰的基本数据类型方法内部是不可以变得，但是引用数据类型是引用不可以变，但是值可以变 * @param user */public static void setUser(final User user) {    //引用的数据类型的值是可以改变的，但是指向的引用是不能够变的    user.setPassword(&quot;sdf&quot;);    //引用的数据类型引用是不可以变得，否则编译是不能够通过的    user = new User();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般情况下final修饰的参数是在方法中不能够被修改的，但是这样的定义又不是最准确的，首先如果形参类型是基本的数据类型的话参数的值是不能够被改变的，但是如果参数类型是引用数据类型的话引用是不能够变得，但是引用的值是可以改变的；&lt;/p&gt;
&lt;p&gt;如下基本数据类型的代码例子：&lt;/
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2020/06/04/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/04/Java异常处理/</id>
    <published>2020-06-04T11:57:10.000Z</published>
    <updated>2020-07-07T00:43:09.223Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，<br>在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、<br>IndexOutOfBoundsException 等），这些异常类分为两大类：Error 和 Exception。</p><p>Error 是无法处理的异常，比如 OutOfMemoryError，一般发生这种异常，<br>JVM 会选择终止程序。因此我们编写程序时不需要关心这类异常。<br>Exception，也就是我们经常见到的一些异常情况，<br>比如 NullPointerException、IndexOutOfBoundsException，这些异常是我们可以处理的异常。</p><p>Exception 类的异常包括 checked exception 和 unchecked exception<br>（unchecked exception 也称运行时异常 RuntimeException，<br>当然这里的运行时异常并不是前面我所说的运行期间的异常，<br>只是 Java 中用运行时异常这个术语来表示，Exception 类的异常都是在运行期间发生的）。</p><p>unchecked exception（非检查异常），也称运行时异常（RuntimeException），<br>比如常见的 NullPointerException、IndexOutOfBoundsException。对于运行时异常，<br>java 编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。<br>　　<br>checked exception（检查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），<br>java 编译器强制程序员必须进行捕获处理，比如常见的 IOExeption 和 SQLException。<br>对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><p>在 Java 中，所有异常类的父类是 Throwable 类，Error 类是 error 类型异常的父类，<br>Exception 类是 exception 类型异常的父类，RuntimeException 类是所有运行时异常的父类，<br>RuntimeException 以外的并且继承 Exception 的类是非运行时异常。<br>　　<br>典型的 RuntimeException 包括 NullPointerException、IndexOutOfBoundsException、<br>IllegalArgumentException 等。<br>　　<br>典型的非 RuntimeException 包括 IOException、SQLException 等。</p><p>在Java中什么是内存不足错误？<br>答：在Java中，OutOfMemoryError是 java.lang.VirtualMachineError的一个子类，<br>当堆内存耗尽时会被JVM抛出。我们能通过设置Java选项来提供更大的内存供应用使用来达到修复的目的。<br>$&gt;java MyProgram -Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=256m</p><p>引发Exception in thread main的各种不同情形？<br>答：通常的一些主线程异常情形主要有以下几种：<br>Exception in thread main java.lang.UnsupportedClassVersionError:当编译和运行Java类的JDK版本不同的时出现这种异常。<br>Exception in thread main java.lang.NoClassDefFoundError:这种异常出现的原因有两种：第一种是提供类全名时附带有.class；第二种是指定类未找到。<br>Exception in thread main java.lang.NoSuchMethodError: main:当试图运行一个没main方法的类时会出现这种异常。<br>Exception in thread main java.lang.NoSuchMethodError: main:无论何时main方法任何异常，它打印异常到控制台。其第一部分是陈述main方法抛出的异常，第二部分打印异常类名，后接异常类信息。</p><p>Java中final,finally,finalize的区别？<br>答：final和finally在Java中是关键字，而finalize则是一个方法。<br>final关键字使得类变量不可变，避免类被其它类继承或方法被重写。finally跟try-catch块一起使用，即使是出现了异常，其子句总会被执行，通常，finally子句用来关闭相关资源。finally方法中的对象被销毁之前会被垃圾回收。<br>综上三者，只有finally用于异常处理。</p><p>在main方法抛出异常时发生了什么？<br>答：当main方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><p>catch子句能为空吗？<br>答：可以有空的catch子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的catch子句。Catch子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><p>链接：<a href="http://www.jianshu.com/p/f6865c97cd52" target="_blank" rel="noopener">http://www.jianshu.com/p/f6865c97cd52</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中异常被当做对象来处理，根类是 java.lang.Throwable 类，&lt;br&gt;在 Java 中定义了很多异常类（如 OutOfMemoryError、NullPointerException、&lt;br&gt;IndexOutOfBoundsException 等
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>值传递</title>
    <link href="http://yoursite.com/2020/06/03/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/06/03/值传递/</id>
    <published>2020-06-03T11:57:10.000Z</published>
    <updated>2020-07-07T00:41:03.767Z</updated>
    
    <content type="html"><![CDATA[<p>首先举例如下：<br>public class Employee {  </p><pre><code>public String name=null;  public Employee(String n){      this.name=n;  }  //将两个Employee对象交换  public static void swap(Employee e1,Employee e2){      Employee temp=e1;      e1=e2;      e2=temp;              System.out.println(e1.name+&quot; &quot;+e2.name); //打印结果：李四 张三  }  //主函数  public static void main(String[] args) {      Employee worker=new Employee(&quot;张三&quot;);      Employee manager=new Employee(&quot;李四&quot;);      swap(worker,manager);      System.out.println(worker.name+&quot; &quot;+manager.name); //打印结果仍然是： 张三 李四  }  </code></pre><p>}<br>上面的结果让人很失望，虽然形参对象 e1,e2 的内容交换了，<br>但实参对象 worker,manager 并没有互换内容。<br>这里面最重要的原因就在于形参 e1,e2 是实参 worker,manager 的地址拷贝。</p><p>传值：<br>传递的是值的副本。方法中对副本的修改，不会影响到调用方法<br>传引用：<br>传递的是引用的副本，共用一个内存，会影响到调用方法。<br>此时，形参和实参指向同一个内存地址。<br>对引用副本本身（对象地址）的修改，如设置为 null，重新指向其他对象，不会影响到调用方法。</p><p>链接：<a href="http://6924918.blog.51cto.com/6914918/1283761" target="_blank" rel="noopener">http://6924918.blog.51cto.com/6914918/1283761</a></p><p>String简单介绍：<br>两种方式是有区别的，这和 java 的内存管理有关，前面已经说过，string 创建之后是不可变的，<br>所以按照第一种方式创建的字符串会放在栈里，更确切的是常量池中，<br>常量池就是用来保存在编译阶段确定好了大小的数据，<br>一般我们定义的 int 等基本数据类型就保存在这里。<br>其具体的一个流程就是，编译器首先检查常量池，看看有没有一个 “string”，如果没有则创建。<br>如果有的话，则则直接把 str1 指向那个位置。<br>第二种创建字符串的方法是通过 new 关键字，还是 java 的内存分配，<br>java 会将 new 的对象放在堆中，这一部分对象是在运行时创建的对象。<br>所以我们每一次 new 的时候，都会创建不同的对象，即便是堆中已经有了一个一模一样的。<br>写一个小例子</p><pre><code>String str1 = &quot;string&quot;;String str4 = &quot;string&quot;;String str2 = new String(&quot;string&quot;);String str3 = new String(&quot;string&quot;);/*用于测试两种创建字符串方式的区别*/System.out.println(str1 == str4);System.out.println(str2 == str3);System.out.println(str3 == str1);str3 = str3.intern(); //一个不常见的方法System.out.println(str3 == str1);</code></pre><p>这个的运行结果是<br>true // 解释：两个字符串的内容完全相同，因而指向常量池中的同一个区域<br>false // 解释：每一次 new 都会创建一个新的对象<br>false // 解释： 注意 == 比较的是地址，不仅仅是内容<br>true // 介绍一下 intern 方法，这个方法会返回一个字符串在常量池中的一个地址，<br>如果常量池中有与 str3 内容相同的 string 则返回那个地址，如果没有，<br>则在常量池中创建一个 string 后再返回。实际上，str3 现在指向了 str1 的地址。</p><p>string 是不变的，那么为什么 str1 + “some” 是合法的，<br>其实，每次对 string 进行修改，都会创建一个新的对象。<br>所以如果需要对一个字符串不断的修改的话，效率是非常的低的，<br>因为堆的好处是可以动态的增加空间，劣势就是分配新的空间消耗是很大的</p><p>String 字符串常量：<br>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，<br>则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。<br>因此，每次在对 String 类型的对象进行改变的时候其实都等同于<br>生成了一个新的 String 对象，然后将指针指向新的 String 对象，<br>所以经常改变内容的字符串最好不要用 String，因为每次生成对象<br>都会对系统性能产生影响。</p><p>StringBuffer 字符串变量 (线程安全）：<br>所谓变量，即是可以随时变化的量。如果对 StringBuffer 对象进<br>行改变，每次结果都会对 StringBuffer 对象进行操作，而不是生<br>成新的对象。所以一般字符串要经常变化的话使用 StringBuffer。</p><p>StringBuilder 字符串变量（非线程安全）：<br>StringBuilder 和 StringBuffer 类功能基本相似，方法也差不多，<br>主要区别在于 StringBuffer 类的方法是多线程安全的，<br>而 StringBuilder 不是线程安全的，相比而言 StringBuilder 类会略微快一点。</p><p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<br>    （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中<br>    （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。<br>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量<br>    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的<br>    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。<br>         引用变量名和对应的对象仍然存储在相应的堆中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先举例如下：&lt;br&gt;public class Employee {  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public String name=null;  

public Employee(String n){  
    this.name=n;  
}  
//将两个
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>kafka基础笔记</title>
    <link href="http://yoursite.com/2020/06/02/kafka%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/02/kafka基础笔记/</id>
    <published>2020-06-02T11:57:10.000Z</published>
    <updated>2020-07-06T09:59:10.073Z</updated>
    
    <content type="html"><![CDATA[<p>consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）<br>一种是topic-partition粒度（用户自己去管理）；</p><a id="more"></a><p>// 订阅指定的 topic 列表,并且会自动进行动态 partition 订阅<br>// 当发生以下情况时,会进行 rebalance: 1.订阅的 topic 列表改变; 2.topic 被创建或删除; 3.consumer 线程 die; 4. 加一个新的 consumer 线程<br>// 当发生 rebalance 时，会唤醒 ConsumerRebalanceListener 线程<br>public void subscribe(Collection topics, ConsumerRebalanceListener listener){}<br>// 同上，但是这里没有设置 listener<br>public void subscribe(Collection topics){}<br>//note: 订阅那些满足一定规则(pattern)的 topic<br>public void subscribe(Pattern pattern, ConsumerRebalanceListener listener){}</p><p>以上三种 API 都是按照 topic 级别去订阅，可以动态地获取其分配的 topic-partition，这是使用 Group 动态管理 ，它不能与手动 partition 管理一起使用。当监控到发生下面的事件时，Group 将会触发 rebalance 操作：</p><ul><li>订阅的 topic 列表变化；</li><li>topic 被创建或删除；</li><li>consumer group 的某个 consumer 实例挂掉；</li><li>一个新的 consumer 实例通过 join 方法加入到一个 group 中。</li></ul><p>consumer的两种commit实现，commitAsync()和commitSync()，即同步commit和异步commit；</p><p>kafka常用命令：<br>列出所有topic：kafka-topics.sh –zookeeper localhost:2181 –list<br>创建topic：kafka-topics.sh –zookeeper localhost:2181<br>                            –create<br>                            –topic earth<br>                            –partitions 1<br>                            –replication-factor 1</p><p>生产数据：kafka-console-producer.sh<br>                    –broker-list localhost:9092<br>                    –topic earth</p><p>消费数据：kafka-console-consumer.sh –zookeeper localhost:2181<br>                                      –topic earth<br>                                      –from-beginning</p><p>获取offset的最大最小值：kafka-run-class.sh kafka.tools.GetOffsetShell<br>                                 –broker-list localhost:9092<br>                                 –topic earth<br>                                 –time -1</p><p>最后的参数-1表示显示获取最大值，-2表示获取最小值；</p><p>查看具体某个partition数据内容：kafka-simple-consumer-shell.sh –broker-list localhost:9092<br>                                       –topic earth<br>                                       –partition 1<br>                                       –print-offsets<br>                                       –offset 18<br>                                       –clientId test<br>                                       –property print.key=true</p><p>1).System.exit(0)是将你的整个虚拟机里的内容都停掉了 ，而dispose()只是关闭这个窗口，但是并没有停止整个application exit() 。无论如何，内存都释放了！也就是说连JVM都关闭了，内存里根本不可能还有什么东西<br>2).System.exit(0)是正常退出程序，而System.exit(1)或者说非0表示非正常退出程序<br>3).System.exit(status)不管status为何值都会退出程序。和return 相比有以下不同点：return是回到上一层，而System.exit(status)是回到最上层<br>示例:<br>在一个if-else判断中，如果我们程序是按照我们预想的执行，到最后我们需要停止程序，那么我们使用System.exit(0)，而System.exit(1)一般放在catch块中，当捕获到异常，需要停止程序，我们使用System.exit(1)。这个status=1是用来表示这个程序是非正常退出。</p><p>自动关机命令：<br>表示600秒后自动关机：shutdown -s -t 600<br>取消定时关机：shutdown -a<br>表示600秒后自动重启：shutdown -r -t 600<br>rononce -p：15秒关机</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;consumer的两种订阅模式，subscribe()和assign()模式，一种是topic粒度的（使用group管理）&lt;br&gt;一种是topic-partition粒度（用户自己去管理）；&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka、大数据" scheme="http://yoursite.com/tags/kafka%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>java中内存结构</title>
    <link href="http://yoursite.com/2020/06/01/java%E4%B8%AD%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/06/01/java中内存结构/</id>
    <published>2020-06-01T11:57:10.000Z</published>
    <updated>2020-07-06T09:55:30.293Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的笔记，今天记录到自己的博客中；</p><ul><li>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   </li></ul><p>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   </p><ul><li>堆内存用来存放由new创建的对象和数组。<br>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。<br>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。<br>引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   </li></ul><a id="more"></a><h4 id="java中变量在内存中的分配"><a href="#java中变量在内存中的分配" class="headerlink" title="java中变量在内存中的分配"></a>java中变量在内存中的分配</h4><p>1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭</p><p>2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</p><p>3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</p><p>附：java的内存机制</p><p>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。<br>　　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。<br>　　这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！</p><p>[参考链接]<a href="http://blog.csdn.net/emira_j/article/details/51232611" target="_blank" rel="noopener">http://blog.csdn.net/emira_j/article/details/51232611</a><br>[参考链接]<a href="http://blog.csdn.net/fuckluy/article/details/50614983" target="_blank" rel="noopener">http://blog.csdn.net/fuckluy/article/details/50614983</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前的笔记，今天记录到自己的博客中；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆内存用来存放由new创建的对象和数组。&lt;br&gt;在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。&lt;br&gt;在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。&lt;br&gt;引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>tiny-spring笔记一</title>
    <link href="http://yoursite.com/2020/05/29/tiny-spring%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/05/29/tiny-spring笔记一/</id>
    <published>2020-05-29T11:57:10.000Z</published>
    <updated>2020-06-01T01:33:33.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-step1-最基本的容器"><a href="#1-step1-最基本的容器" class="headerlink" title="1.step1 - 最基本的容器"></a>1.step1 - 最基本的容器</h4><p>使用如下命令在idea中查看最开始的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-1-container-register-and-get</span><br></pre></td></tr></table></figure><p>代码结构如下图所示<br><img src="/2020/05/29/tiny-spring笔记一/aaa.png" alt><br>IoC 最基本的角色有两个：容器 (BeanFactory) 和 Bean 本身。这里使用 BeanDefinition 来封装了 bean 对象(当前之后bean属性)，这样可以保存一些额外的元信息。</p><a id="more"></a><h4 id="2-step2-将-bean-创建放入工厂"><a href="#2-step2-将-bean-创建放入工厂" class="headerlink" title="2.step2 - 将 bean 创建放入工厂"></a>2.step2 - 将 bean 创建放入工厂</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-2-abstract-beanfactory-and-do-bean-initilizing-in-it</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/bbb.png" alt><br>step1 中的 bean 是初始化好之后再 set 进去的，实际使用中，我们希望容器来管理 bean 的创建。于是我们将 bean 的初始化放入 BeanFactory 中。为了保证扩展性，我们使用 Extract Interface 的方法，将 BeanFactory 替换成接口，而使用 AbstractBeanFactory 和 AutowireCapableBeanFactory 作为其实现。”AutowireCapable” 的意思是 “可自动装配的”，为我们后面注入属性做准备。step2和step1创建bean的方式不同，step2的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">注意newInstance和new的区别</span><br></pre></td></tr></table></figure><h4 id="3-step3-为-bean-注入属性"><a href="#3-step3-为-bean-注入属性" class="headerlink" title="3.step3 - 为 bean 注入属性"></a>3.step3 - 为 bean 注入属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-3-inject-bean-with-property</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/ccc.png" alt><br><img src="/2020/05/29/tiny-spring笔记一/ddd.png" alt><br>这一步，我们想要为 bean 注入属性。我们选择将属性注入信息保存成 PropertyValue 对象，并且保存到 BeanDefinition 中。这样在初始化 bean 的时候，我们就可以根据 PropertyValue 来进行 bean 属性的注入。Spring 本身使用了 setter 来进行注入，这里为了代码简洁，我们使用 Field 的形式来注入。</p><h4 id="4-step4-读取-xml-配置来初始化-bean"><a href="#4-step4-读取-xml-配置来初始化-bean" class="headerlink" title="4.step4 - 读取 xml 配置来初始化 bean"></a>4.step4 - 读取 xml 配置来初始化 bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-4-config-beanfactory-with-xml</span><br></pre></td></tr></table></figure><p>代码结构如下<br><img src="/2020/05/29/tiny-spring笔记一/eee.png" alt></p><h4 id="5-step5-为-bean-注入-bean"><a href="#5-step5-为-bean-注入-bean" class="headerlink" title="5.step5 - 为 bean 注入 bean"></a>5.step5 - 为 bean 注入 bean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-5-inject-bean-to-bean</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-step1-最基本的容器&quot;&gt;&lt;a href=&quot;#1-step1-最基本的容器&quot; class=&quot;headerlink&quot; title=&quot;1.step1 - 最基本的容器&quot;&gt;&lt;/a&gt;1.step1 - 最基本的容器&lt;/h4&gt;&lt;p&gt;使用如下命令在idea中查看最开始的版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout step-1-container-register-and-get&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;代码结构如下图所示&lt;br&gt;&lt;img src=&quot;/2020/05/29/tiny-spring笔记一/aaa.png&quot; alt&gt;&lt;br&gt;IoC 最基本的角色有两个：容器 (BeanFactory) 和 Bean 本身。这里使用 BeanDefinition 来封装了 bean 对象(当前之后bean属性)，这样可以保存一些额外的元信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring、Java" scheme="http://yoursite.com/categories/Spring%E3%80%81Java/"/>
    
    
      <category term="Spring、Java、Ioc" scheme="http://yoursite.com/tags/Spring%E3%80%81Java%E3%80%81Ioc/"/>
    
  </entry>
  
  <entry>
    <title>接口Iterator和接口Iterable的区别</title>
    <link href="http://yoursite.com/2020/05/26/%E6%8E%A5%E5%8F%A3%20Iterator%20%E5%92%8C%E6%8E%A5%E5%8F%A3%20Iterable%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/26/接口 Iterator 和接口 Iterable 的区别/</id>
    <published>2020-05-26T11:57:10.000Z</published>
    <updated>2020-05-26T02:06:02.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h4><ul><li>内置了 iterator 方法顺序遍历数据源返回值 Iterator 接口</li><li>jdk8 增加了 forEach 方法返回 void</li><li>Set、List 都要实现 Iterable 接口，基本上使用迭代器都要实现该接口</li></ul><p>Iterable 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line"></span><br><span class="line">    default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Spliterator&lt;T&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliteratorUnknownSize(iterator(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Iterator-和-ListIterator-主要区别有："><a href="#Iterator-和-ListIterator-主要区别有：" class="headerlink" title="Iterator 和 ListIterator 主要区别有："></a>Iterator 和 ListIterator 主要区别有：</h4><ul><li>ListIterator 有 add () 方法，可以向 List 中添加对象；而 Iterator 不能</li><li>ListIterator 和 Iterator 都有 hasNext () 和 next () 方法，可以实现顺序向后遍历。ListIterator 有 hasPrevious () 和 previous () 方法，可以实现逆向（顺序向前）遍历。Iterator 就不可以。</li><li>ListIterator 可以定位当前的索引位置，nextIndex () 和 previousIndex () 可以实现。Iterator 没有此功能。</li><li>都可实现删除对象，但是 ListIterator 可以实现对象的修改，set () 方法可以实现。Iterator 仅能遍历，不能修改。因为 ListIterator 的这些功能，可以实现对 LinkedList 等 List 数据结构的操作。</li></ul><h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><ul><li>出现 Iterator 是为了解决遍历集合时，避免我们在操作集合的时候必须要根据集合内部结构来选择我们应该如何遍历，因此把 Iterator 抽象出来</li></ul><p>Iterator 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        while (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterable-接口和-Iterator-接口"><a href="#Iterable-接口和-Iterator-接口" class="headerlink" title="Iterable 接口和 Iterator 接口"></a>Iterable 接口和 Iterator 接口</h4><blockquote><p>这两个都是迭代相关的接口，可以这么认为，实现了 Iterable 接口，则表示某个对象是可被迭代的；Iterator 接口相当于是一个迭代器，实现了 Iterator 接口，等于具体定义了这个可被迭代的对象时如何进行迭代的。一般 Iterable 和 Iterator 接口都是结合着一起使用的。</p></blockquote><h4 id="为什么一定要实现-Iterable-接口而不直接实现-Iterator-接口了呢"><a href="#为什么一定要实现-Iterable-接口而不直接实现-Iterator-接口了呢" class="headerlink" title="为什么一定要实现 Iterable 接口而不直接实现 Iterator 接口了呢?"></a>为什么一定要实现 Iterable 接口而不直接实现 Iterator 接口了呢?</h4><blockquote><p>因为 Iterator 接口的核心方法 next () 或者 hasNext () 都是依赖于迭代器的当前迭代位置的。如果 Collection 直接实现 Iterator 接口，势必导致集合对象中包含当前迭代位置的数据，当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next () 方法的结果会变成不可预知的。除非再为 Iterator 接口添加一个 reset () 方法，用来重置当前迭代位置。但即使这样，Collection 也同时只能存在一个当前迭代位置。而 Iterable，每次调用都返回一个从头开始计数的迭代器，多个迭代器时互不干扰.</p></blockquote><p>可能这么解释不是很明白，再解释明白一点，我自己写的一个 ArrayList，如果直接实现 Iterator 接口，那么势必是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; implements List&lt;E&gt;, Iterator&lt;E&gt;, RandomAccess, Cloneable, Serializable&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 序列化ID</span><br><span class="line">     */</span><br><span class="line">    private static final long serialVersionUID = -5786598508477165970L;</span><br><span class="line">    </span><br><span class="line">    private int size = 0;</span><br><span class="line">    private transient Object[] elementData = null;</span><br><span class="line">    </span><br><span class="line">    public E next()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么问题就来了，如果一个 ArrayList 实例被多个地方迭代，next () 方法、hasNext () 直接操作的是 ArrayList 中的资源，假如我在 ArrayList 中定义一个迭代位置的变量，那么对于不同调用处，这个迭代变量是共享的，线程 A 迭代的时候将迭代变量设置成了第 5 个位置，这时候切换到了线程 B，对于线程 B 来讲，就从第 5 个位置开始遍历此 ArrayList 了，根本不是从 0 开始，如何正确迭代？</p><p>实现 Iterable 接口返回一个 Iterator 接口的实例就不一样了，我为自己写的 ArrayList 定义一个内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListIterator implements Iterator&lt;E&gt;&#123;</span><br><span class="line">    int iteratorPostion = 0;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断是否后面还有元素</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext()</span><br><span class="line">    &#123;</span><br><span class="line">        if ((iteratorPostion + 1) &gt; size)</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回之前一个元素的引用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public E next()</span><br><span class="line">    &#123;</span><br><span class="line">        return (E)elementData[iteratorPostion++];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都返回一个返回一个 ArrayListIterator 实例出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回一个ArrayList的迭代器，可以通过该迭代器遍历ArrayList中的元素</span><br><span class="line"> */</span><br><span class="line">public Iterator&lt;E&gt; iterator()</span><br><span class="line">&#123;</span><br><span class="line">    return new ArrayListIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就保证了，即使是多处同时迭代这个 ArrayList，依然每处都是从 0 开始迭代这个 ArrayList 实例的。</p><h4 id="深入探讨-Iterable-与-Iterator-关系"><a href="#深入探讨-Iterable-与-Iterator-关系" class="headerlink" title="深入探讨 Iterable 与 Iterator 关系"></a>深入探讨 Iterable 与 Iterator 关系</h4><p>有一个问题，为什么不直接将 hasNext ()，next () 方法放在 Iterable 接口中，其他类直接实现就可以了？</p><p>原因是有些集合类可能不止一种遍历方式，实现了 Iterable 的类可以再实现多个 Iterator 内部类，例如 LinkedList 中的 ListItr 和 DescendingIterator 两个内部类，就分别实现了双向遍历和逆序遍历。通过返回不同的 Iterator 实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的 Iterator 实现类了。ListItr 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        return new ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        ListItr(int index) &#123;</span><br><span class="line">            // assert isPositionIndex(index);</span><br><span class="line">            next = (index == size) ? null : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>如上所示可以通过调用 list.listIterator() 方法返回 iterator 迭代器（list.iterator() 只是其默认实现）</p><p>DescendingIterator 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">        return new DescendingIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    private class DescendingIterator implements Iterator&lt;E&gt;     &#123;</span><br><span class="line">        private final ListItr itr = new ListItr(size());</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return itr.hasPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            return itr.previous();</span><br><span class="line">        &#125;</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            itr.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样可以通过 list.descendingIterator() 使用该迭代器。</p><p>[参考链接]<a href="https://segmentfault.com/a/1190000020642743" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020642743</a><br>[参考链接]<a href="https://www.cnblogs.com/xrq730/p/4907184.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4907184.html</a><br>[参考链接]<a href="https://zhuanlan.zhihu.com/p/52366312" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52366312</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Iterable-接口&quot;&gt;&lt;a href=&quot;#Iterable-接口&quot; class=&quot;headerlink&quot; title=&quot;Iterable 接口&quot;&gt;&lt;/a&gt;Iterable 接口&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内置了 iterator 方法顺序遍历数据源返回值 Iterator 接口&lt;/li&gt;
&lt;li&gt;jdk8 增加了 forEach 方法返回 void&lt;/li&gt;
&lt;li&gt;Set、List 都要实现 Iterable 接口，基本上使用迭代器都要实现该接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Iterable 的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface Iterable&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Iterator&amp;lt;T&amp;gt; iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Objects.requireNonNull(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (T t : this) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            action.accept(t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default Spliterator&amp;lt;T&amp;gt; spliterator() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Spliterators.spliteratorUnknownSize(iterator(), 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="http://yoursite.com/2020/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/25/设计模式之迭代器模式/</id>
    <published>2020-05-25T11:57:10.000Z</published>
    <updated>2020-05-27T02:22:59.056Z</updated>
    
    <content type="html"><![CDATA[<h4 id="迭代器模式定义"><a href="#迭代器模式定义" class="headerlink" title="迭代器模式定义"></a>迭代器模式定义</h4><blockquote><p>迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。</p></blockquote><h4 id="迭代器模式的优点有"><a href="#迭代器模式的优点有" class="headerlink" title="迭代器模式的优点有"></a>迭代器模式的优点有</h4><blockquote><p>简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于 hash 表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。<br>可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。<br>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</p></blockquote><h4 id="迭代器模式的缺点"><a href="#迭代器模式的缺点" class="headerlink" title="迭代器模式的缺点"></a>迭代器模式的缺点</h4><blockquote><p>对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像 ArrayList，我们宁可愿意使用 for 循环和 get 方法来遍历集合。</p></blockquote><a id="more"></a><h4 id="继承关系图"><a href="#继承关系图" class="headerlink" title="继承关系图"></a>继承关系图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">此处以ArrayList为例</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns an iterator over elements of type &#123;@code T&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return an Iterator.</span><br><span class="line">     */</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor;       // index of next element to return</span><br><span class="line">        int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i = cursor;</span><br><span class="line">            if (i &gt;= size)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;= elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;迭代器模式定义&quot;&gt;&lt;a href=&quot;#迭代器模式定义&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式定义&quot;&gt;&lt;/a&gt;迭代器模式定义&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代器模式的优点有&quot;&gt;&lt;a href=&quot;#迭代器模式的优点有&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式的优点有&quot;&gt;&lt;/a&gt;迭代器模式的优点有&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于 hash 表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。&lt;br&gt;可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。&lt;br&gt;封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代器模式的缺点&quot;&gt;&lt;a href=&quot;#迭代器模式的缺点&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式的缺点&quot;&gt;&lt;/a&gt;迭代器模式的缺点&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像 ArrayList，我们宁可愿意使用 for 循环和 get 方法来遍历集合。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="迭代器模式" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序员英语</title>
    <link href="http://yoursite.com/2020/05/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/"/>
    <id>http://yoursite.com/2020/05/24/程序员英语/</id>
    <published>2020-05-24T11:57:10.000Z</published>
    <updated>2020-05-25T02:21:37.273Z</updated>
    
    <content type="html"><![CDATA[<p>contents<br>prevVolume<br>Sub<br>Invalid<br>calculate<br>Failed<br>claas<br>Prefix<br>Index<br>lite</p><a id="more"></a><p>export<br>Volume<br>WithDetailsException<br>Fair<br>Add<br>compiled<br>Configuration<br>This<br>Fair<br>suitable<br>illegal<br>License<br>focus<br>Traceback<br>Organization<br>org.apache.hadoop.hbase.DoNotRetryIOException:<br>omitted<br>cheat<br>find<br>constraint<br>reign<br>Duplicated<br>previous<br>swap<br>SpiritSoft<br>cause<br>Cronos<br>fetchMetadata:<br>prev<br>merge<br>This<br>element<br>Lists<br>fixes<br>Storage<br>Error<br>Nov<br>Service<br>early<br>Error<br>Required<br>priority<br>Provided<br>smart<br>theme<br>Returns<br>The<br>chat<br>quick<br>ObjectStore#listVolumesByUser<br>java.sql.SQLException:<br>park<br>his<br>attaching<br>Design<br>trim<br>操作<br>While<br>租户<br>omitted<br>relative<br>Jul<br>staff<br>Caused<br>hold<br>Removed<br>drill<br>reentrantlock<br>omitted<br>delimited<br>Goal<br>exhausted<br>all<br>Currently<br>Unnecessary<br>If<br>already<br>Exclusive<br>dry<br>Service<br>Copyright<br>fulfil<br>Implementation<br>spawn<br>String<br>Notifications<br>Categories<br>Array<br>Offload<br>ANTLR<br>folders<br>All<br>conflict<br>defer<br>good<br>tenement<br>hints<br>Volumes<br>interceptor<br>foundation<br>timeout<br>drainTo<br>Untracked<br>Incompatible<br>ExhaustedWithDetailsException<br>Base<br>call<br>async<br>Copyright<br>CodisLabs<br>quota<br>absent<br>merchant<br>retries<br>folded<br>Maximum<br>federation<br>annotation<br>through<br>Duplicated<br>Leaving<br>error:<br>Carlier<br>label<br>visited<br>joker<br>accessed<br>IllegalAccess<br>TREEIFY<br>volumes<br>Full<br>logic<br>line<br>coursera<br>dequeue<br>calculateSize<br>Please<br>Descripto<br>getTenantId()<br>When<br>entered<br>Duplicated<br>SpiritSoft<br>Returns<br>ant<br>unnecessary<br>RetriesExhaustedWithDetailsException<br>remainder<br>leetcode-cn<br>claas<br>Pochmann<br>Copyright<br>invalisd<br>操作中不包含上传下载<br>Coursera<br>Lists<br>leetcode-cn<br>Melancholy<br>serviceType<br>abnormally<br>Maximum<br>Annotationsare<br>redundant<br>Oracle<br>Required<br>Quota<br>Error<br>Configuration<br>Size<br>public<br>explicit<br>Size<br>aym<br>Race<br>Annotations<br>Invalid<br>section<br>Timestamp<br>percentage<br>String<br>Red<br>Copyright<br>visible<br>transfer<br>Data<br>Medium<br>It<br>decompression<br>one<br>fix<br>untracked<br>proxy<br>delay<br>Currently<br>Framework<br>IntelliJ<br>Returns<br>large<br>tracking<br>Xiaoyu<br>Returns<br>sign<br>authored<br>Fair<br>drill<br>metadata<br>aNode:<br>starting<br>Only<br>prevVolume<br>terminator<br>one<br>volumePrefix<br>enqueue<br>repository<br>GLOBALS<br>review<br>inclusive<br>goal<br>Incompatible<br>columns<br>distribution<br>Volume<br>Creates<br>leaf<br>expect<br>call<br>Page<br>Authorize<br>call<br>Inc<br>recovery<br>Returns<br>omitted<br>Gets<br>object<br>accessible<br>Shutdown<br>truncated<br>IllegalAccessError<br>replicated<br>discuss<br>BaseContextHandler<br>This<br>enumeration<br>set<br>passing<br>chunkSize<br>multiple<br>undeclared<br>genericwildcard<br>remix<br>recursive<br>relaunch<br>avail<br>SafeModePrecheck<br>With<br>Deprecated<br>IllegalAcc<br>Gets<br>fatal:<br>automatic<br>Subcommand<br>iterable<br>Lombok<br>Block<br>gener<br>unindent<br>Run<br>renderer<br>found<br>desired<br>Sets<br>Allows<br>creation<br>Searched<br>initiate<br>Demons<br>ozone<br>generic<br>fully<br>Removedundeclared<br>jcenter<br>ceiver<br>set<br>survive<br>unpacking<br>system<br>memoized<br>Receiving<br>Ozone<br>recon<br>bucket<br>right<br>correctly<br>company<br>memoizedIsInitialized<br>qualified<br>collaborator<br>supplier<br>nodeAddress=172.16.13.168:1234<br>trash<br>background<br>oriented<br>treeify<br>commit<br>reflect<br>above<br>Deprecated<br>semaphore<br>as<br>futrue<br>mismatch<br>freon<br>modification<br>use<br>Branch<br>freon<br>actionable<br>multiple<br>ListKeysRequest<br>Block<br>Description<br>Protobuf<br>set<br>anonymous<br>threshold<br>FileEncryptionInfo<br>cleaner<br>Developer<br>chunk<br>checksum<br>track<br>lookup<br>lifecucle<br>attachments<br>failures<br>Pruning<br>Audit<br>post<br>generated<br>bycode<br>Ozone<br>movie<br>rights<br>prototype<br>remove<br>took<br>original<br>declared<br>suggested<br>The<br>fully<br>completed<br>Details<br>NativeCodeLoader:60<br>generify<br>BigDecimal<br>Gets<br>qualified<br>encryption<br>repeated<br>Decom<br>leaving<br>@Command<br>description<br>resolving<br>usage<br>Collaborator<br>criteria<br>usage<br>Module<br>Disable<br>leaving<br>enabled<br>receiving<br>Constructor<br>fully<br>EncryptionInfo<br>completed<br>Scheduled<br>Replication<br>contribute<br>IllegalAc<br>invalid<br>Gets<br>designed<br>deltas<br>original<br>group<br>gank<br>replicated<br>charge<br>programming<br>maven{<br>specification<br>UnsatisfiedDependencyException<br>set<br>library<br>freon<br>snapshots<br>auto<br>author<br>recover<br>wheel<br>Removed<br>delta<br>leaving<br>expiry<br>conditions<br>Checkavailsum<br>rights<br>intern<br>closer<br>List<br>demons<br>Gets<br>xceiver<br>Found<br>location<br>fatal<br>Unchecked<br>Process<br>CurrentlyIn<br>invocation<br>exact<br>untreeify<br>Central<br>What<br>wildcard<br>ContextHandler<br>revea<br>decompiled<br>algorithm<br>cloud<br>Blank<br>renew<br>erase<br>Datagram<br>bind<br>reserved<br>spawned<br>parsing<br>pars<br>cannot<br>multipart<br>peer<br>Broken<br>truncation<br>Pending<br>Caught<br>With<br>vantage<br>cheap<br>mon<br>detection<br>status<br>disabled<br>disables<br>automatically<br>succeed<br>alert<br>redirect<br>grep<br>recursive<br>firefly<br>price<br>straightforward<br>args<br>components<br>ware<br>default<br>rollback<br>switch<br>timestamp<br>info<br>ultima<br>ultimately<br>destination<br>source<br>uploads<br>download<br>overflow<br>stack<br>isBlank<br>revert<br>equal<br>Instruction<br>mutable<br>depiction<br>write<br>down<br>incorrectly<br>Key<br>stars<br>matched<br>caution<br>occupied<br>service<br>client<br>Balancer<br>parcel<br>clouder<br>cloudier<br>context<br>case<br>rawtypes<br>were<br>Multiple<br>tail<br>RpcLite<br>typedef<br>plan<br>fail<br>FEMALE<br>MALE<br>HEAD<br>director<br>assignment<br>acquire<br>multiple<br>STOPPING<br>convert<br>combined<br>aggregation<br>Invalid<br>triggers<br>instance<br>fired<br>checkin<br>cron<br>quartz<br>wrong<br>fragment<br>way<br>inverted<br>enablement<br>Disallow<br>customize<br>lapping<br>Over<br>luckin<br>Trigger<br>base<br>Exhausted<br>Retries<br>metric<br>magic<br>mid<br>SIMPLE<br>previous<br>show<br>show<br>Aggregate<br>all<br>match<br>remind<br>occurred<br>diagrams<br>global<br>instantiate<br>preserve<br>EAGER<br>serial<br>gateway<br>Invocation<br>warn<br>invokeAll<br>discretion<br>flink<br>compute<br>Stream<br>availability<br>Frame<br>exactly-once<br>stract<br>Graph<br>primitive<br>performance<br>concern<br>rank<br>null<br>dereference<br>dead<br>internationalization<br>dodgy<br>bread<br>timezone<br>wding<br>instantf<br>tags<br>unbenannt<br>startseite<br>archiv<br>farewell<br>Manifest<br>Memtable<br>compile<br>warehourse<br>warehours<br>snappy<br>auth<br>stealing<br>fork<br>Schedual<br>call<br>abort<br>Vertex<br>Dispatcher<br>clusters<br>cluster<br>useless<br>Vulnerability<br>processors<br>such<br>assertion<br>sigar<br>Chat<br>Stats<br>Wrapper<br>compare<br>applet<br>Visible<br>Dashboard<br>billion<br>script<br>invite<br>MultiLine<br>majors<br>typo<br>retail<br>press<br>device<br>booting<br>booting<br>associated<br>Fetched<br>drop<br>recommend<br>during<br>injection<br>Sniper<br>hive<br>entire<br>whether<br>made<br>certain<br>calls<br>Readable<br>comments<br>validate<br>ordinal<br>reviation<br>EXECUTE<br>Place<br>Handle<br>Async<br>excluded<br>alias<br>countermand<br>inexecution<br>undo<br>Launching<br>Tracking<br>explain<br>expires<br>clause<br>blockers<br>enclosing<br>each<br>raises<br>tricky<br>Correctly<br>Scheduled<br>Duration<br>AtomicInteger<br>Reentrant<br>blocking<br>instanceof<br>commons<br>practice<br>Correctness<br>Cumulative<br>incremental<br>Coffees<br>Label<br>digits<br>decimal<br>catalog<br>concrete<br>aspect<br>Mirror<br>jan<br>Confidential<br>Prepared<br>credentials<br>collection<br>collection<br>terminated<br>extended<br>DUPLICATION<br>Dependency<br>instantiation<br>nested<br>through<br>expressed<br>Unsatisfied<br>privileges<br>orign<br>tenant<br>waterfall<br>split<br>Capacity<br>Statement<br>extract<br>hundred<br>Noncompliant<br>Forbidden<br>beaver<br>embedded<br>decr<br>TotalPage<br>paging<br>oldkey<br>ren<br>invalid<br>relly<br>flush<br>Sorted<br>subject<br>depth<br>EXPOT<br>thrift<br>explore<br>Appender<br>authorizer<br>prefixLength<br>normalize<br>existence<br>Completion<br>current<br>register<br>struct<br>Owner<br>Modifying<br>Valid<br>Transform<br>category<br>authority<br>Generator<br>Generic<br>processor<br>pick<br>already<br>Expiration<br>preserve<br>in-flight<br>capability<br>issue<br>Autowired<br>browser<br>unauthorized<br>raw<br>parameters<br>actual<br>defined<br>currently<br>requirement<br>argument<br>Oauth<br>Conflict<br>negative<br>heap<br>Common<br>rack<br>paradise<br>hook<br>future<br>coverage<br>the<br>trans<br>generator<br>missing<br>wrong<br>illegal<br>grant<br>comment<br>complete<br>keyboard<br>Minor<br>squid<br>smell<br>Critical<br>incl<br>nesting<br>rule<br>browse<br>search<br>serializer<br>Seek<br>Seeking<br>halt<br>require<br>interceptors<br>inherited<br>club<br>compaction<br>dispatch<br>reactor<br>Sequence<br>replay<br>patch<br>completion<br>forget<br>fire<br>fire<br>transport<br>dismiss<br>undeploy<br>external<br>faster<br>indicates<br>probably<br>Virtual<br>Constant<br>advanced<br>actors<br>abstract<br>repeat<br>revoked<br>progress<br>illegal<br>generation<br>coordination<br>cceeds<br>multi<br>coordinator<br>concat<br>greeting<br>Symbol<br>ident<br>provider<br>Permissions<br>Multicast<br>identifier<br>reassignment<br>Transformation<br>gmall<br>frontend<br>backend<br>notify<br>architecture<br>dubbo<br>submission<br>Distributed<br>most<br>related<br>features<br>performed<br>specific<br>exclude<br>facets<br>disable<br>remoting<br>Disposable<br>Phase<br>destroy<br>Lifecycle<br>yet<br>received<br>decompiler<br>lllegal<br>redial<br>dialed<br>subscriber<br>Foundry<br>Transactional<br>seq<br>Execution<br>exception<br>uncaught<br>Processor<br>Roaming<br>exactly<br>loop<br>samples<br>execution<br>Runner<br>Line<br>command<br>Enable<br>uppercamelcase<br>exchange<br>restTemplate<br>Bearer<br>Secret<br>Access<br>Platform<br>round-robin<br>retention<br>socket<br>sender<br>bound<br>trait<br>trade-off<br>initial<br>rebalancing<br>compacted<br>Usage<br>metrics<br>notification<br>identity<br>domain<br>domin<br>popedom<br>Module<br>token<br>EPHEMERAL<br>disconnect<br>Strict<br>Domain<br>Beeline<br>Efficiency<br>Bootstrap<br>Advanced<br>Mechanism<br>General<br>avro<br>radio<br>origin<br>index<br>run<br>drop<br>daemon<br>Damon<br>result<br>verify<br>constant<br>thyme<br>border<br>pencil<br>NEUTRAL<br>with<br>recall<br>lisence<br>assert<br>crash<br>condition<br>reverse<br>dialect<br>strategy<br>whitelabel<br>stretch<br>Extract<br>Target<br>artifact<br>provided<br>Repl<br>slots<br>assigned<br>epoch<br>notice<br>disconnected<br>afair<br>one<br>establish<br>clear<br>show<br>show<br>word<br>word<br>word<br>word<br>estalished<br>deflate<br>partial<br>Niubility<br>Mapper<br>aliases<br>guanxi<br>note<br>beat<br>Annotation<br>cover<br>seem<br>present<br>statemachine<br>sample<br>actuator<br>Template<br>Expect<br>perform<br>ignore<br>reference<br>under<br>suffix<br>Thymeleaf<br>scope<br>Generate<br>STACKTRACE<br>Communications<br>publish<br>reCall<br>Repository<br>Starters<br>print<br>talk<br>content<br>page<br>coming<br>additivity<br>metastore<br>pagination<br>NumberFormat<br>displayed<br>Number<br>edges<br>items<br>displaye<br>onclick<br>event<br>Compiling<br>undefined<br>Monitor<br>loader<br>SUSPEND<br>Alongside<br>Running<br>Scheduling<br>audit<br>rele<br>Structured<br>destory<br>Option<br>mangagement<br>mangage<br>dynamic<br>administer<br>storage<br>sto<br>processing<br>inside<br>routing<br>indeep<br>action<br>machine<br>installation<br>effective<br>periodically<br>way<br>durable<br>similar<br>capabilities<br>Introduction<br>Prior<br>releases<br>flat<br>serde<br>Released<br>connection<br>flight<br>full<br>replicas<br>insync<br>enable<br>election<br>unclean<br>random<br>compression<br>compress<br>datacommunication<br>communication<br>resolved<br>resol<br>resole<br>adver<br>tick<br>ensemble<br>legacy<br>Position<br>Bounds<br>riven<br>java<br>Unit<br>license<br>Reassignment<br>allowed<br>compiled<br>filtered<br>Detail<br>pairs<br>stable<br>Manual<br>idle<br>resume<br>pause<br>prompt<br>Sqoop<br>failover<br>Argument<br>Illegal<br>compact<br>major<br>mutex<br>volatitle<br>fight<br>interrupt<br>monitor<br>lifecycle<br>exit<br>Security<br>SecurityManager<br>allocates<br>handler<br>row<br>reject<br>take<br>que<br>blocked<br>limit<br>runnable<br>policy<br>task<br>protocol<br>configured<br>Ensure<br>AndEnsureOpen<br>acquireAndEnsureOpen<br>reflection<br>Eagle<br>cite<br>times<br>verdana<br>family<br>font-family<br>PowderBlue<br>center<br>align<br>height<br>width<br>href<br>tiy<br>Rectangle<br>Unnamed<br>Immutable<br>catch<br>Application<br>Bootstrap<br>controlFlag<br>required<br>Authorization<br>secret<br>loss<br>ephemeral<br>tracker<br>foreign<br>connected<br>state<br>Caused<br>See<br>Parameters<br>Specified<br>case<br>module<br>latency<br>fetch-throttle-time<br>sensor<br>Codinator<br>Assigned<br>Revoked<br>Interrupted<br>record<br>prefix<br>issues<br>iss<br>internal<br>Describe<br>DescribeCluster<br>duplicated<br>Utility<br>owned<br>non-owned<br>identified<br>yield<br>volatile<br>volati<br>volatite<br>Replica<br>controller<br>Listener<br>Rebalance<br>Atomic<br>wakeup<br>ConcurrentModification<br>Modification<br>Concurrent<br>inspection<br>Future<br>earliest<br>movingAvg<br>custemor<br>custe<br>maker<br>administering<br>adminis<br>admin<br>training<br>train<br>transaction<br>exactly<br>Deserializer<br>powered<br>powered<br>power<br>powerded<br>subscribe模式差异分析<br>subscribe<br>refer<br>construct<br>PLAINTEXT<br>Security<br>invalid<br>unique<br>Unreachable<br>TRACE<br>available<br>target<br>rollingfile<br>rolli<br>foreground<br>foregr<br>custom<br>remote<br>histories<br>unrelated<br>skip<br>Failures<br>period<br>lease<br>sit<br>instead<br>option<br>Executed<br>idempotence<br>symbol<br>regex<br>medium<br>Importance<br>deletion<br>France<br>precision<br>country<br>customer<br>customercountry<br>Columns<br>scala<br>meta<br>ITEM<br>DEVELOP<br>TRADE<br>applicable<br>WHOLE<br>temp<br>spark<br>Schames<br>timer<br>time<br>matches<br>expected<br>expecte<br>PARTITION<br>exiting<br>established<br>optional<br>MemStore<br>Store<br>platform<br>general<br>generalplatform<br>records<br>contains<br>invoke<br>poll<br>Deal<br>seek<br>parameter<br>usages<br>Field<br>modified<br>Definitions<br>Parse<br>Standard<br>Custom<br>checkpoint<br>secure<br>reduce<br>Guide<br>Reference<br>scheme<br>Received<br>topics<br>Due<br>queue<br>Proposed<br>Current<br>generate<br>region<br>qualifier<br>call<br>unable<br>Get<br>wonderfuk<br>locations<br>produce<br>Extracts<br>admins<br>For<br>The<br>MEMORY<br>BLOOMFILTER<br>ENABLED<br>could<br>Native<br>details<br>HRegionServer<br>backup<br>schema<br>Region<br>Pipeline<br>Transient<br>rejected<br>Push<br>bootstrap<br>remote<br>Building<br>remove<br>credential<br>dereferenced<br>can<br>implies<br>Redirected<br>Redirected<br>failed<br>featurel<br>develop<br>sonar<br>replace<br>Segment<br>hadoop<br>retrieve<br>store<br>separator<br>international<br>component<br>ignored<br>Elastic<br>wired<br>from<br>Loaded<br>via<br>recording<br>attempts<br>JsonIgnore<br>Sample<br>mounted<br>Poller<br>Periodic<br>PeriodicPoller<br>process<br>weather<br>increase<br>segment<br>SEMANTIC<br>SYNTAX<br>Patterns<br>mutate<br>grok<br>decode<br>match<br>plain<br>pipeline<br>Options<br>ensure<br>codec<br>position<br>Pretty<br>Escape<br>Escaping<br>disable<br>contributions<br>Corporation<br>concurrent<br>function<br>scan<br>common<br>Excute<br>Interval<br>cache<br>accessors<br>staged<br>Agent<br>snapshot<br>define<br>borrow<br>invalid<br>incorrect<br>inactive<br>Secondary<br>Column<br>salary<br>custom<br>dependency<br>resolve<br>collector<br>flow<br>Job<br>shuffle<br>Record<br>You<br>access<br>Minion<br>buffer<br>millis<br>intervalceiling<br>interval<br>pacemaker<br>pacemaker<br>deprecation<br>slow<br>contributors<br>wonderful<br>leadership<br>shard<br>increasing<br>consider<br>low<br>likely<br>process<br>descriptors<br>interests<br>Megacorp<br>sense<br>nstall<br>Permission<br>elastic<br>access<br>fetch<br>shape<br>Iterable<br>iterator<br>pervious<br>item<br>security<br>blobstore<br>implementation<br>ssl.secure.random.implementation<br>remark<br>sheet<br>reblance<br>mooc<br>Invalid<br>Automatic<br>receive<br>recommended<br>pool<br>Invalid<br>moment<br>Unable<br>stat<br>archive<br>sort<br>originState<br>broker<br>advertised<br>brokers<br>available<br>factor<br>replication<br>regular<br>advertise<br>essential<br>explanation<br>thnx<br>to<br>notty<br>difference<br>intersect<br>union<br>uniq<br>minify<br>wiki<br>native<br>ether<br>netmask<br>bcast<br>broadcast<br>fatal<br>field<br>Cell<br>Document<br>Information<br>Summary<br>developerworks<br>Exiting<br>Skipping<br>Fall<br>Security<br>too<br>Definition<br>ship<br>images<br>launch<br>Core<br>Full<br>Deployer<br>Extras<br>Embedded<br>latest<br>mirror<br>registry<br>Redirecting<br>batch<br>Handler<br>Unspecified<br>container<br>persist<br>Constraints<br>parse<br>feature<br>eature<br>offers<br>driver<br>specify<br>Function<br>UserWarning<br>staging<br>stag<br>Fetch<br>AttributeError<br>Installing<br>Press<br>Keep<br>pull<br>push<br>Microsoft<br>elements<br>upgrade<br>upgread<br>referer<br>request<br>alien<br>fleet<br>snip<br>bottom<br>rect<br>screen<br>blit<br>fill<br>exporrer<br>attribute<br>AttributeError<br>usage<br>InsecureRequestWarning<br>tickets<br>TypeError:<br>stations<br>perf<br>hsperf<br>future<br>SyntaxError:<br>based<br>executable<br>Ticket<br>libpng<br>libpng<br>libpng<br>display<br>caption<br>ValueError<br>Redirection<br>image<br>range<br>font<br>IOError<br>site<br>UnicodeEncodeError<br>SIGTERM<br>RECEIVED<br>proceed<br>comparison<br>permission<br>manual<br>syntax<br>conditiona<br>CASCADE<br>RESTRICT<br>alter<br>modify<br>TEMPORARY<br>Expressions<br>primary<br>distinct<br>enterprise<br>Component<br>release<br>assign<br>Call<br>sqrate<br>rate<br>summary<br>Data<br>near<br>BINARY<br>PRIVILEGES<br>Column<br>duplicate<br>dump<br>column<br>cursor<br>FOREIGN<br>REFERENCES<br>CONSTRAINT<br>PRIMARY<br>structure<br>formatter<br>cast<br>detected<br>bracket<br>statement<br>layout<br>neutral<br>rolling<br>level<br>expression<br>evaluator<br>deny<br>Mismatch<br>Match<br>append<br>pattern<br>encoder<br>Policy<br>triggering<br>triggeringPolicy<br>appender<br>configuration<br>Judge<br>transform<br>Unreachable<br>persistent<br>constrains<br>SERVLET<br>monit<br>stage<br>artifacts<br>encode<br>submit<br>except<br>report<br>operate<br>Operation<br>last<br>interva<br>Wipe<br>query<br>dumps<br>executor<br>Configuration<br>Reliability<br>Bolts<br>Spouts<br>Streams<br>topology<br>nimbus<br>supervisor<br>rebalance<br>deploy<br>Terminal<br>Operator<br>Container<br>External<br>Volume<br>Persistent<br>Element<br>Response<br>Queue<br>Strategy<br>Upgrade<br>Failure<br>deprecated<br>transactional<br>transactiona<br>template<br>Accept<br>Content<br>recent</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;contents&lt;br&gt;prevVolume&lt;br&gt;Sub&lt;br&gt;Invalid&lt;br&gt;calculate&lt;br&gt;Failed&lt;br&gt;claas&lt;br&gt;Prefix&lt;br&gt;Index&lt;br&gt;lite&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序员英语" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之职责链模式</title>
    <link href="http://yoursite.com/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/22/设计模式之职责链模式/</id>
    <published>2020-05-22T11:57:10.000Z</published>
    <updated>2020-05-21T07:45:00.844Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
