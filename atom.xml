<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-08T01:57:43.394Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发之多线程间通信</title>
    <link href="http://yoursite.com/2019/09/30/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/30/Java并发之多线程间通信/</id>
    <published>2019-09-30T10:28:24.000Z</published>
    <updated>2019-10-08T01:57:43.394Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程通信" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之内存模型和happens-before规则</title>
    <link href="http://yoursite.com/2019/09/29/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/09/29/java多线程之内存模型和happens-before规则/</id>
    <published>2019-09-29T10:28:24.000Z</published>
    <updated>2019-09-30T06:50:19.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。</p><a id="more"></a><p>JMM 是围绕着在并发过程中如何处理原子性、可见性和有序性这 3 个特征来建立的。</p><p>JMM 是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。</p><p>Java 内存模型把 Java 虚拟机内部划分为线程栈和堆。</p><h5 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h5><p>每一个运行在 Java 虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p><p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆上包含在 Java 程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p><p>一个本地变量可能是原始类型，在这种情况下，它总是在线程栈上。 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。 静态成员变量跟随着类定义一起也存放在堆上。 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="/2019/09/29/java多线程之内存模型和happens-before规则/1556440274529751.jpg" alt></p><h3 id="多线程可见性"><a href="#多线程可见性" class="headerlink" title="多线程可见性"></a>多线程可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其它线程能够适时得知这个修改。在单线程环境中，如果在程序前面修改了某个变量的值，后面的程序一定会读取到那个变量的新值。这看起来很自然，然而当变量的写操作和读操作在不同的线程中时，情况却并非如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *《Java并发编程实战》27页程序清单3-1</span><br><span class="line"> */</span><br><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready; </span><br><span class="line">    private static int number;</span><br><span class="line">    </span><br><span class="line">    private static class ReaderThread extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ReaderThread().start(); //启动一个线程</span><br><span class="line">        number = 42;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，主线程和读线程都访问共享变量 ready 和 number。程序看起来会输出 42（输出42是正常思维，就是number和ready被复制之后没一会就将值更新到了主内存，更新到主内存之后，等其他线程到主内存中读取值的时候就可以看到修改后的值），但事实上很可能会输出 0，或者根本无法终止。这是因为上面的程序缺少线程间变量可见性的保证，所以在主线程中写入的变量值，可能无法被读线程感知到。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作 Happens-Before 书写在后面的代码操作。这时因为 Java 语言规范要求 JVM 在单个线程内部要维护类似严格串行的语义，如果多个操作之间有<strong><em>先后依赖关系</em></strong>，则不允许对这些操作进行重排序。</p><h3 id="锁定规则"><a href="#锁定规则" class="headerlink" title="锁定规则"></a>锁定规则</h3><p>对锁 M 解锁之前的所有操作 Happens-Before 对锁 M 加锁之后的所有操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class HappensBeforeLock &#123;</span><br><span class="line">    private int value = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，setValue 和 getValue 两个方法共享同一个监视器锁。假设 setValue 方法在线程 A 中执行，getValue 方法在线程 B 中执行。setValue 方法会先对 value 变量赋值，然后释放锁。getValue 方法会先获取到同一个锁后，再读取 value 的值。所以根据锁定原则，线程 A 中对 value 变量的修改，可以被线程 B 感知到。<br>如果这个两个方法上没有 synchronized 声明，则在线程 A 中执行 setValue 方法对 value 赋值后，线程 B 中 getValue 方法返回的 value 值并不能保证是最新值。<br>本条锁定规则对显示锁 (ReentrantLock) 和内置锁 (synchronized) 在加锁和解锁等操作上有着相同的内存语义。<br>对于锁定原则，可以像下面这样去理解：同一时刻只能有一个线程执行锁中的操作，所以锁中的操作被重排序外界是不关心的，只要最终结果能被外界感知到就好。除了重排序，剩下影响变量可见性的就是 CPU 缓存了。在锁被释放时，A 线程会把释放锁之前所有的操作结果同步到主内存中，而在获取锁时，B 线程会使自己 CPU 的缓存失效，重新从主内存中读取变量的值。这样，A 线程中的操作结果就会被 B 线程感知到了。</p><h3 id="传递性规则"><a href="#传递性规则" class="headerlink" title="传递性规则"></a>传递性规则</h3><p>如果操作 A Happens-Before B，B Happens-Before C，那么可以得出操作 A Happens-Before C。</p><h3 id="volatile-变量规则"><a href="#volatile-变量规则" class="headerlink" title="volatile 变量规则"></a>volatile 变量规则</h3><blockquote><p>对一个 volatile 变量的写操作及这个写操作之前的所有操作 Happens-Before 对这个变量的读操作及这个读操作之后的所有操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line">char[] configText; //线程间共享变量，用于保存配置信息</span><br><span class="line">// 此变量必须定义为volatile</span><br><span class="line">volatile boolean initialized = false;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程A中执行</span><br><span class="line">// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程B中执行</span><br><span class="line">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span><br><span class="line">while (!initialized) &#123;    </span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">//使用线程A中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>上面这段代码，读取配置文件的操作和使用配置信息的操作分别在两个不同的线程 A、B 中执行，两个线程通过共享变量 configOptions 传递配置信息，并通过共享变量 initialized 作为初始化是否完成的通知。initialized 变量被声明为 volatile 类型的，根据 volatile 变量规则，volatile 变量的写入操作 Happens-Before 对这个变量的读操作，所以在线程 A 中将变量 initialized 设为 true，线程 B 中是可以感知到这个修改操作的。<br>但是更牛逼的是，volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作对其它线程的可见性。考虑这样一种情况，如果 volatile 变量仅能保证自己的变量可见性，那么当线程 B 感知到 initialized 已经变成 true 然后执行 doSomethingWithConfig 操作时，可能无法获取到 configOptions 最新值而导致操作结果错误。所以 volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作 Happens-Before 书写在 volatile 变量读操作之后的那些操作。<br>可以这样理解 volatile 变量的写入和读取操作流程：<br>首先，volatile 变量的操作会禁止与其它普通变量的操作进行重排序，例如上面代码中会禁止 initialized = true 与它上面的两行代码进行重排序 (但是它上面的代码之间是可以重排序的)，否则会导致程序结果错误。volatile 变量的写操作就像是一条基准线，到达这条线之后，不管之前的代码有没有重排序，反正到达这条线之后，前面的操作都已完成并生成好结果。<br>然后，在 volatile 变量写操作发生后，A 线程会把 volatile 变量本身和书写在它之前的那些操作的执行结果一起同步到主内存中。<br>最后，当 B 线程读取 volatile 变量时，B 线程会使自己的 CPU 缓存失效，重新从主内存读取所需变量的值，这样无论是 volatile 本身，还是书写在 volatile 变量写操作之前的那些操作结果，都能让 B 线程感知到，也就是上面程序中的 initialized 和 configOptions 变量的最新值都可以让线程 B 感知到。<br>原子变量与 volatile 变量在读操作和写操作上有着相同的语义。</p><h3 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h3><p>Thread 对象的 start 方法及书写在 start 方法前面的代码操作 Happens-Before 此线程的每一个动作。<br>start 方法和新线程中的动作一定是在两个不同的线程中执行。线程启动规则可以这样去理解：调用 start 方法时，会将 start 方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在 start 方法调用之前的所有操作结果对于新创建的线程都是可见的。</p><h3 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h3><p>线程中的任何操作都 Happens-Before 其它线程检测到该线程已经结束。这个说法有些抽象，下面举例子对其进行说明。<br>假设两个线程 s、t。在线程 s 中调用 t.join () 方法。则线程 s 会被挂起，等待 t 线程运行结束才能恢复执行。当 t.join () 成功返回时，s 线程就知道 t 线程已经结束了。所以根据本条原则，在 t 线程中对共享变量的修改，对 s 线程都是可见的。类似的还有 Thread.isAlive 方法也可以检测到一个线程是否结束。<br>可以猜测，当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程 A 对共享变量的修改，对于其它检测了 A 线程是否结束的线程是可见的。</p><h3 id="中断规则"><a href="#中断规则" class="headerlink" title="中断规则"></a>中断规则</h3><p>一个线程在另一个线程上调用 interrupt,Happens-Before 被中断线程检测到 interrupt 被调用。<br>假设两个线程 A 和 B，A 先做了一些操作 operationA，然后调用 B 线程的 interrupt 方法。当 B 线程感知到自己的中断标识被设置时 (通过抛出 InterruptedException，或调用 interrupted 和 isInterrupted),operationA 中的操作结果对 B 都是可见的。</p><p>[参考链接]<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011458941</a><br>[参考链接]<a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="noopener">http://ifeve.com/java-memory-model-6/</a><br>[参考链接]<a href="http://ifeve.com/memory-model/" target="_blank" rel="noopener">http://ifeve.com/memory-model/</a><br>[参考链接]<a href="http://ifeve.com/from-singleton-happens-before/" target="_blank" rel="noopener">http://ifeve.com/from-singleton-happens-before/</a><br>[参考链接]<a href="http://blog.itpub.net/69917606/viewspace-2642808/" target="_blank" rel="noopener">http://blog.itpub.net/69917606/viewspace-2642808/</a><br>[参考链接]<a href="https://www.jianshu.com/p/4455e4234d5c" target="_blank" rel="noopener">https://www.jianshu.com/p/4455e4234d5c</a><br>[参考链接]<a href="https://www.jianshu.com/p/15106e9c4bf3" target="_blank" rel="noopener">https://www.jianshu.com/p/15106e9c4bf3</a><br>参考书籍《Java并发编程艺术》第三章，《Java并发编程实战》第三章，第十六章，《深入理解Java内存模型》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h3&gt;&lt;p&gt;JMM 的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与 Java 编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-内存模型、happens-before规则" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81happens-before%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之CAS</title>
    <link href="http://yoursite.com/2019/09/28/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCAS/"/>
    <id>http://yoursite.com/2019/09/28/java多线程之CAS/</id>
    <published>2019-09-28T10:28:24.000Z</published>
    <updated>2019-10-08T01:57:40.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-CAS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之AQS</title>
    <link href="http://yoursite.com/2019/09/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/09/27/Java多线程之AQS/</id>
    <published>2019-09-27T10:28:24.000Z</published>
    <updated>2019-09-27T11:12:19.375Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-AQS" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之lock</title>
    <link href="http://yoursite.com/2019/09/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Block/"/>
    <id>http://yoursite.com/2019/09/26/Java多线程之lock/</id>
    <published>2019-09-26T10:28:24.000Z</published>
    <updated>2019-10-08T06:38:16.049Z</updated>
    
    <content type="html"><![CDATA[<p>Java 从 Java SE 5 之后在并发包中提供 Lock 接口。在 java.util.concurrent.locks 包中有很多 Lock 的实现类，常用的有 ReentrantLock、ReadWriteLock（实现类 ReentrantReadWriteLock），其实现都依赖 java.util.concurrent.AbstractQueuedSynchronizer 类，实现思路都大同小异，因此我们以 ReentrantLock 作为讲解切入点。Lock 锁，可以得到和 synchronized 一样的效果，即实现原子性、有序性和可见性。相较于 synchronized，Lock 锁可手动获取锁和释放锁、可中断的获取锁、超时获取锁。Lock 是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。</p><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>Lock 锁的基本用法， l.lock () 方法进行上锁， l.unlock () 方法进行解锁，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">l.lock(); // 上锁</span><br><span class="line">try &#123;</span><br><span class="line">  // access the resource protected by this lock</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  l.unlock(); // 解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-应用场景举例"><a href="#Lock-应用场景举例" class="headerlink" title="Lock 应用场景举例"></a>Lock 应用场景举例</h3><ul><li>解决获取锁的等待问题<br>如果占有锁的线程 A 由于各种原因导致阻塞而没有释放锁，此时其他线程 B 也需要获得该锁。synchronized 的机制是让 B 持续等待，如果 A 一直没有释放锁，那么 B 将一直等待，这会很大程度影响执行的效率；而 Lock 中提供了中断线程等待的方法，也提供了带有超时时间的获取锁的方法，后面会讲到这些方法。</li><li>读写锁的分离<br>我们知道，多线程仅仅是执行读操作的话是没有冲突问题的，因而在读操作时的锁没必要是独占的。synchronized 实现同步就会导致在读操作时只能有一个线程获得锁，其他线程只能等待锁的释放。Lock 中的 ReentrantReadWriteLock 很好的解决了这个问题。</li><li>其他锁的操作<br>如获知当前线程是否成功获得锁等，synchronized 是做不到的。</li></ul><h3 id="Lock-锁常用方法"><a href="#Lock-锁常用方法" class="headerlink" title="Lock 锁常用方法"></a>Lock 锁常用方法</h3><table><thead><tr><th align="center">修饰符和类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">lock（）</td><td align="center">获得锁。</td></tr><tr><td align="center">void</td><td align="center">lockInterruptibly​()</td><td align="center">获得锁，可中断。举个例子，当两个线程同时通过 lock.lockInterruptibly () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 threadB.interrupt () 方法能够中断线程 B 的等待过程。</td></tr><tr><td align="center">boolean</td><td align="center">tryLock​()</td><td align="center">锁在空闲的才能获取锁（未获得锁不会等待）。举个例子：当两个线程同时通过 lock.trylock () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 不会等待，直接放弃获取锁。</td></tr><tr><td align="center">boolean</td><td align="center">tryLock​(long time, TimeUnit unit)</td><td align="center">如果锁定可用，则此方法立即返回值 true。如果锁不可用，则当前线程将被禁用以进行线程调度，并且在发生以下三种情况之一之前处于休眠状态：①当前线程获取锁。②其他一些线程中断当前线程。③等待时间过去了，返回 false</td></tr><tr><td align="center">void</td><td align="center">unlock​()</td><td align="center">释放锁。</td></tr></tbody></table><blockquote><p>注意事项：</p><ul><li>Lock 的实例一般定义为成员变量，如果定义为局部变量，每个线程都会保存一个自己的副本，那么在获取锁的操作时，实际每个线程获取的是不同的锁，无法形成同步互斥访问。</li><li>获取锁的操作要放在 try 模块之外，原因是如果放在 try 模块内的话，当获取锁的操作发生异常会调用 finally 中的代码释放锁，而此时可能并没有获取锁，就会抛出异常。</li></ul></blockquote><ol><li>lock()<br>特点：发生异常不自动释放锁；如果没有获取到锁会等待；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock(); //创建锁</span><br><span class="line"></span><br><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock(); //获得锁</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.print(&quot;业务处理&quot;); //任务处理</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock(); //释放锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>tryLock()<br>特点：带有 boolean 型返回值；无论是否成功获取锁会立即返回不进行等待；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock(); //创建锁</span><br><span class="line"></span><br><span class="line">public void getLock() &#123;</span><br><span class="line"></span><br><span class="line">    if(lock.tryLock()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.print(&quot;业务处理&quot;); //任务处理</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); //释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">           System.out.print(&quot;获取锁失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>tryLock(long time, TimeUnit unit)<br>特点：可以设置获取锁的等待时间，如 tryLock (4, TimeUnit.SECONDS) 等待 4 秒；可以在等待过程中相应中断；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> Lock l = new ReentrantLock();</span><br><span class="line"> try &#123;</span><br><span class="line">    if (l.tryLock(4000, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;获取锁&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;: &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l.unlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;未获取锁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lockInterruptibly()　</p></li></ol><p>　　lockInterruptibly () 方法比较特殊，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够 响应中断，即中断线程的等待状态。例如，当两个线程同时通过 lock.lockInterruptibly () 想获取某个锁时，假若此时线程 A 获取到了锁，而线程 B 只有在等待，那么对线程 B 调用 threadB.interrupt () 方法能够中断线程 B 的等待过程。</p><p>　　由于 lockInterruptibly () 的声明中抛出了异常，所以 lock.lockInterruptibly () 必须放在 try 块中或者在调用 lockInterruptibly () 的方法外声明抛出 InterruptedException，但推荐使用后者，原因稍后阐述。因此，lockInterruptibly () 一般的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //.....</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>当一个线程获取了锁之后，是不会被 interrupt () 方法中断的。因为 interrupt () 方法只能中断阻塞过程中的线程而不能中断正在运行过程中的线程。因此，当通过 lockInterruptibly () 方法获取某个锁时，如果不能获取到，那么只有进行等待的情况下，才可以响应中断的。与 synchronized 相比，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><blockquote><p>可中断锁<br>顾名思义，可中断锁就是可以响应中断的锁。在 Java 中，synchronized 就不是可中断锁，而 Lock 是可中断锁。<br>如果某一线程 A 正在执行锁中的代码，另一线程 B 正在等待获取该锁，可能由于等待时间过长，线程 B 不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。在前面演示 tryLock (long time, TimeUnit unit) 和 lockInterruptibly () 的用法时已经体现了 Lock 的可中断性。</p></blockquote><p>[参考链接]<a href="https://blog.csdn.net/qq_38737992/article/details/89607758" target="_blank" rel="noopener">https://blog.csdn.net/qq_38737992/article/details/89607758</a><br>[参考链接]<a href="https://blog.csdn.net/qq_25160969/article/details/71335362" target="_blank" rel="noopener">https://blog.csdn.net/qq_25160969/article/details/71335362</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 从 Java SE 5 之后在并发包中提供 Lock 接口。在 java.util.concurrent.locks 包中有很多 Lock 的实现类，常用的有 ReentrantLock、ReadWriteLock（实现类 ReentrantReadWriteLo
      
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-lock" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-lock/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://yoursite.com/2019/09/25/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/25/MarkDown语法/</id>
    <published>2019-09-25T10:28:24.000Z</published>
    <updated>2019-09-27T09:49:58.307Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；</p><a id="more"></a><p>Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持 Markdown 编辑模式。</p><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加 #来表示<br>一个 #是一级标题，二个 #是二级标题，以此类推。支持六级标题。<br>注：标准语法一般在 #后跟个空格再写文字,vscode就是要在#之后空一格。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li>加粗<br>要加粗的文字左右分别用两个 * 号包起来</li><li>斜体<br>要倾斜的文字左右分别用一个 * 号包起来</li><li>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来</li><li>删除线<br>要加删除线的文字左右分别用两个～～号包起来<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加 &gt; 即可。引用也可以嵌套，如加两个 &gt;&gt; 三个 &gt;&gt;&gt;</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/550)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6860761-fd2f51090a890873.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt></p><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><ul><li>无序列表<br>语法：<br>无序列表用 - + * 任何一种都可以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：- + * 跟内容之间都要有一个空格</p><ul><li>有序列表<br>语法：<br>数字加点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li></ul><p>注意：序号跟内容之间要有空格</p><ul><li>列表嵌套</li></ul><p>上一级和下一级之间敲三个空格即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 一级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br><span class="line">       + 二级无序列表内容</span><br></pre></td></tr></table></figure><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p><code>代码内容</code></p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><p>示例：<br>单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`create database hero;`</span><br></pre></td></tr></table></figure><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>(<code>)    function fun(){         echo &quot;这是一句非常牛逼的代码&quot;;    }    fun();(</code>)</p><h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><p>我这使用的vscode出不来流程图，我还花钱买了一个Markdown软件，结果发现也不支持，不知道是不是我太菜了，估计就是我太菜了。<br>流程图的技巧可以参考这个<a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">流程图</a></p><p>[参考链接] <a href="https://segmentfault.com/a/1190000006247465" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006247465</a><br>[参考链接] <a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇主要是有的语法还用的不是很熟练，用到的时候还得从网上搜一下，太不方便了，所以写一篇博客，然后不会的就可以直接看自己的博客了；&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="博客随笔" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>git使用整理</title>
    <link href="http://yoursite.com/2019/09/24/git%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/24/git使用整理/</id>
    <published>2019-09-24T10:28:24.000Z</published>
    <updated>2019-09-29T11:38:48.747Z</updated>
    
    <content type="html"><![CDATA[<p>本文不做过多概念解释，详细概念请参照官网。本文只是针对平时使用的命令做一个记录；</p><a id="more"></a><ul><li>配置用户信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yuezp&quot;</span><br><span class="line">$ git config --global user.email &quot;yuezp@bonc.com.cn&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注:如果使⽤–global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项⽬使⽤不同的用户名称与邮件地址时，可以在那个项目目录下运行没有–global选项的命令来配置。</p></blockquote><h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><ul><li>查看配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git config —list</span><br><span class="line"></span><br><span class="line">core.excludesfile=~/.gitignore</span><br><span class="line">core.legacyheaders=false</span><br><span class="line">core.quotepath=false</span><br><span class="line">core.pager=less</span><br><span class="line">mergetool.keepbackup=true</span><br><span class="line">push.default=simple</span><br><span class="line">color.ui=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">repack.usedeltabaseoffset=true</span><br><span class="line">alias.s=status</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h3><p><strong><em>如果你本地已经生成过秘钥</em></strong></p><ul><li>查看本地库终端秘钥<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa</span><br><span class="line">AAAAB3NzaC1yc2EAAAADAQABAAABAQC4LHzWicHvC3rj7xHIolwADsBXxQFx19nOmltOP+vV1mI</span><br><span class="line">gLrbOdw3nu32d6SgjLKEptBAmuuBMM11tOixd2WD680leugdfhIk8j4EoKB1iuQOytEhGCIqxsQ</span><br><span class="line">kGc/PSCSlNnpvj1Pdhm5WjEUctv8KU3mqi9DwxeVe9h/8bMPoisuAAAGTRyLH6HwL/PwV+y2wRd</span><br><span class="line">lbGIgYtD9/PNhmZWanihcYWIWLrBfyTTHtFHhOASHCoOtn8sf6d4YX9Mr//2T+/QhAfti8fuPec</span><br><span class="line">AfffdTAGwR7FfjyPw2WfReFaFwI27M9G7j6ZzB8sCq8psRfUXDi3MeGmDIM6cj0TUTObmCVf</span><br><span class="line">yuezp@bonc.com.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h3><blockquote><p>创建 dev 分支，然后切换到 dev 分支：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><blockquote><p>git checkout 命令加上 -b 参数表示创建并切换，相当于以下两条命令：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><blockquote><p>使用git branch命令查看当前分支,git branch -a查看全部分支,git branch -r查看远程分支：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><ul><li>合并分支操作<blockquote><p>在master分支创建文件readme.md,并在文件内写入内容；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.md</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>然后使用前面讲解的创建分支并切换分支命令,然后添加内容到当前分支，之后添加文件到暂存区，之后提交到本地库；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b test</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支test</span><br><span class="line"></span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;提交当前分支内容&quot;</span><br></pre></td></tr></table></figure><blockquote><p>然后切回到master分支，进行合并操作;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge test</span><br></pre></td></tr></table></figure><blockquote><p>合并之后就可以删除test分支了；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d test</span><br></pre></td></tr></table></figure><p><strong><em>上面的合并操作是没有冲突的，下面讲解有合并冲突的情况</em></strong></p><blockquote><p>在master分支创建文件readme.md,并在文件内写入内容；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.md</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br></pre></td></tr></table></figure><blockquote><p>然后使用前面讲解的创建分支并切换分支命令,然后添加内容到当前分支，之后添加文件到暂存区，之后提交到本地库；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支dev</span><br><span class="line"></span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;提交当前分支内容&quot;</span><br></pre></td></tr></table></figure><blockquote><p>然后切回到master分支，在master分支中操作文件readme.md文件，之后进行合并操作;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim readme.md</span><br><span class="line">cat readme.md</span><br><span class="line">合并分支操作</span><br><span class="line">操作当前分支master</span><br><span class="line"></span><br><span class="line">$ git merge dev 执行完这条命令之后会发生冲突</span><br><span class="line"></span><br><span class="line">Auto-merging readme.md</span><br><span class="line">CONFLICT (content): Merge conflict in readme.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>报错之后，查看readme.md文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">合并分支操作</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">操作当前分支master</span><br><span class="line">=======</span><br><span class="line">操作当前分支test</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br></pre></td></tr></table></figure><blockquote><p>Git 用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，我们修改如下后保存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">合并分支操作</span><br><span class="line">操作当前分支master</span><br><span class="line">操作当前分支test</span><br></pre></td></tr></table></figure><blockquote><p>使用git命令添加到暂存区，之后添加到本地库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;合并分支操作&quot;</span><br></pre></td></tr></table></figure><blockquote><p>删除分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><blockquote><p>推送本地分支命令如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li>抓取分支</li></ul><p>从远程库 clone 项目时，默认情况下，只能看到本地的 master 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>如果要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，用这个命令创建本地 dev 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><blockquote><p>现在就可以在dev分支进行操作了；</p></blockquote><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在当前分支执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本一</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本一&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">$ cat readme.md</span><br><span class="line">版本二</span><br><span class="line">$ git add readme.md</span><br><span class="line">$ git commit -m &quot;版本二&quot;</span><br></pre></td></tr></table></figure><p>执行命令git log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本四</span><br><span class="line"></span><br><span class="line">commit e705f67e98755ebaaaa70441c16c9f73ae906a09</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本三</span><br><span class="line"></span><br><span class="line">commit d35039370984410c90b9794809e349474974940d</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本二</span><br><span class="line"></span><br><span class="line">commit 21fd94a72dd54cea4e3c42a1988e0a5e2b42eb20</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本一</span><br></pre></td></tr></table></figure><p>可以看到当前版本是版本四，即commit id是e705f67e98755ebaaaa70441c16c9f73ae906a09的这条记录<br>准备回退到版本三，即commit id是d35039370984410c90b9794809e349474974940d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard d35039370984410c90b9794809e349474974940d</span><br></pre></td></tr></table></figure><p>再次执行git log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本三</span><br><span class="line"></span><br><span class="line">commit d35039370984410c90b9794809e349474974940d</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本二</span><br><span class="line"></span><br><span class="line">commit 21fd94a72dd54cea4e3c42a1988e0a5e2b42eb20</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    版本一</span><br><span class="line"></span><br><span class="line">commit 9e77a55a2cb65c9fc59556367f2ac39110a30a91 (origin/test, test)</span><br><span class="line">Author: yuezhiping &lt;yuezhiping@bonc.com.cn&gt;</span><br></pre></td></tr></table></figure><p>如果想再返回版本四，首先执行git reflog获取到版本四的commit id然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本四id</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在当前分支创建readme.md文件，然后git add再git commit -m “信息”<br>现在想删除文件readme.md,一种方法是右键删除，还有一种是使用rm删除；<br>这个时候，Git 知道你删除了文件，因此，工作区和版本库就不一致了，git status 命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令 git rm 删掉，并且 git commit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm readme.md</span><br><span class="line">rm &apos;readme.md&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove readme.md&quot;</span><br><span class="line">[master d46f35e] remove readme.md</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 readme.md</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br></pre></td></tr></table></figure><p>git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以 “一键还原”。</p><ul><li>撤销修改<br>在该工作区修改了readme.md文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vim readme.md</span><br><span class="line">添加内容：</span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh  新加内容</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>你可以发现，Git 会告诉你，git checkout – file 可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br></pre></td></tr></table></figure><p>命令 git checkout – readme.md意思就是，把 readme.md 文件在工作区的修改全部撤销，这里有两种情况：<br>第一种是 readme.md自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.md </span><br><span class="line">head----1</span><br><span class="line">head----2</span><br><span class="line">head----3</span><br></pre></td></tr></table></figure><p>第二种是 readme.md 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line"></span><br><span class="line">$ vim readme.md</span><br><span class="line">添加内容：</span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh  </span><br><span class="line">jjjjjjjjjjjjjjjjj 新加内容</span><br><span class="line"></span><br><span class="line">$ git checkout -- readme.md</span><br><span class="line"></span><br><span class="line">$ cat readme.md</span><br><span class="line">head----1 原来内容</span><br><span class="line">head----2 原来内容</span><br><span class="line">head----3 原来内容</span><br><span class="line">hhhhhhhhhhhhhhhhhh</span><br></pre></td></tr></table></figure><p>总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。</p><p>第二种方法使用用命令 git reset HEAD <file> 也可以把暂存区的修改撤销掉（unstage），重新放回工作区：</file></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.md</span><br></pre></td></tr></table></figure><p>git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。</p><p>再用 git status 查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.md</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.md</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><strong><em>如果你本地没有生成过秘钥</em></strong></p><ul><li>生成秘钥</li></ul><p>如果本地库终端不存在 ~/.ssh 目录或不存在 ~/.ssh/id_rsa.pub 文件，则⽣生成密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “xxx@bonc.com.cn&quot;</span><br></pre></td></tr></table></figure><p>复制本地库密钥(即~/.ssh/id_rsa.pub 文件)到远程库个人配置中（就是你的gitlab或者GitHub中）</p><p><strong><em>方法一</em></strong></p><h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p>有两种创建 Git 项目仓库的方法:在现有目录中初始化 Repository，或克隆一个既有的 Git仓库。</p><ul><li>在现有目录中初始化Repository</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为 .git 的⼦目录，这个⼦目录含有你初始化的 Git 仓库中所有的必须文件，这<br>些文件是 Git 仓库的骨干。</p><ul><li>从服务器克隆一个现有的Git仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone [Remote URL] [Repository Name]</span><br></pre></td></tr></table></figure><p>如果不需要自定义本地仓库名称，可以不指定 Repository Name，本地仓库名称将与远程库相同;</p><h3 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h3><p>git add<br>将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。</p><h2 id="整个Github提交流程如下："><a href="#整个Github提交流程如下：" class="headerlink" title="整个Github提交流程如下："></a>整个Github提交流程如下：</h2><ul><li><p>首先在本地创建版本库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir github_repository</span><br><span class="line">$ cd github_repository</span><br></pre></td></tr></table></figure></li><li><p>初始化版本库</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><ul><li><p>添加文件或者文件夹到版本库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all </span><br><span class="line">$ git status</span><br><span class="line">$ git commit -m &quot;提交信息&quot;</span><br></pre></td></tr></table></figure></li><li><p>在GitHub账户上创建远程仓库</p></li></ul><p>这里请按照GitHub上的操作流程走就行</p><ul><li>将本地仓库和远程仓库进行关联</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:LXF-YZP/study.git</span><br><span class="line">注：我远程仓库的名字和本地仓库的名字都是study</span><br></pre></td></tr></table></figure><ul><li>将本体仓库提交到远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line">如果你在GitHub上创建远程仓库的时候还创建了README.md,那么在执行上面的push命令之前请执行</span><br><span class="line"></span><br><span class="line">$ git pull --rebase origin master</span><br><span class="line"></span><br><span class="line">不然会报错：</span><br><span class="line">To github.com:LXF-YZP/study.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:LXF-YZP/study.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>方法二</em></strong><br>首先在GitHub上创建远程仓库，然后使用命令进行克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:LXF-YZP/study.git</span><br></pre></td></tr></table></figure><blockquote><p>参考之前项目经理写的Git使用说明<br>[参考文章]<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文不做过多概念解释，详细概念请参照官网。本文只是针对平时使用的命令做一个记录；&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC详解</title>
    <link href="http://yoursite.com/2019/09/23/Spring%20IOC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/23/Spring IOC详解/</id>
    <published>2019-09-23T10:28:24.000Z</published>
    <updated>2019-09-27T11:28:39.550Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、ioc" scheme="http://yoursite.com/tags/spring%E3%80%81ioc/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP之动态代理</title>
    <link href="http://yoursite.com/2019/09/22/Spring%20AOP%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/22/Spring AOP之动态代理/</id>
    <published>2019-09-22T10:28:24.000Z</published>
    <updated>2019-09-27T11:27:54.319Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、动态代理" scheme="http://yoursite.com/tags/spring%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP详解</title>
    <link href="http://yoursite.com/2019/09/21/Spring%20AOP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/21/Spring AOP详解/</id>
    <published>2019-09-21T10:28:24.000Z</published>
    <updated>2019-09-27T11:25:36.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring、aop" scheme="http://yoursite.com/tags/spring%E3%80%81aop/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之各种锁概念</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/20/Java多线程之各种锁概念/</id>
    <published>2019-09-20T10:28:24.000Z</published>
    <updated>2019-09-27T10:59:40.284Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。</p><a id="more"></a><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li>公平锁：指的是线程按照申请锁的顺序来获取锁（这里的公平和鹅城张麻子说的公平，公平，还是公平不一样，没看过的建议看一下《让子弹飞》，具体讲的什么我就不说了，再说就扯远了）；</li><li>非公平锁：指的是多个线程获取锁的顺序并不是按照申请锁的顺序来的，有可能会出现后申请锁的线程比先申请锁的线程先获得锁；<br>非公平锁一上来就尝试占用锁，如果尝试占用失败，就采用公平锁的方式到末尾排队。在高并发的情况下，有可能造成优先级反转或饥饿现象。非公平锁的优点在于吞吐量比公平锁大。</li></ul><ul><li>ReentrantLock：可以指定构造方法的 boolean 类型来指定是公平锁还是非公平锁，默认是非公平锁</li><li>Synchronized：是一种非公平锁</li></ul><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><ul><li>独占锁：是指该锁一次只能被一个线程所持有。ReentrantLock 和 synchronized 都是独占锁；</li><li>共享锁：是指该锁可以被多个线程所持有，ReentrantReadWriteLock：其读锁是共享锁，其写锁是独占锁，读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的；</li></ul><h2 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h2><ul><li>上面说到的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在 Java 中的具体实现就是 ReentrantLock；读写锁在 Java 中的具体实现就是 ReadWriteLock。</li><li>互斥锁：某个线程要更改共享数据时，先将其锁定，此时资源的状态为 “锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成 “非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br>互斥锁是阻塞锁，当某线程无法获取互斥量时，该线程会被 CPU 直接挂起，该线程不再消耗 CPU 时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。</li><li>读写锁：读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。读写互斥，读读共享。</li></ul><p>1.多读者可以同时读<br>2.写者写时不允许读，不允许其他写者写<br>3.读者读时不允许写者写</p><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul><li>可重入锁：指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。即获取锁的粒度是线程而不是调用。<br>在同一个线程在外层方法获取锁的时候，在进入内层方法的时候会自动获取锁，也就是说，线程可以进入任何一个它自己已经拥有的锁所同步着的代码块<br>可重入锁最大的作用是避免死锁。ReentrantLock 和 synchronized 都是可重入锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        People people = new People();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                people.get();</span><br><span class="line">            &#125;,&quot;t&quot; + i).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class People&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void get()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; get&quot;);</span><br><span class="line">            set();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; set&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><strong><em>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</em></strong></li></ul><ul><li><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如 Java 里面的同步原语 synchronized 关键字的实现就是悲观锁。</p></li><li><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS (Compare and Swap 比较并交换) 实现的。</p></li></ul><h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><blockquote><p>这三种锁是指锁的状态，并且是针对 synchronized。在 Java 5 通过引入锁升级的机制来实现高效 synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p></blockquote><blockquote><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p></blockquote><blockquote><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p></blockquote><blockquote><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p></blockquote><ul><li><p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p></li><li><p>轻量级锁：线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁 (两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</p></li><li><p>重量级锁：在 JVM 中又叫对象监视器（Monitor），它很像 C 中的 Mutex，除了具备 Mutex (0|1) 互斥的功能，它还负责实现了 Semaphore (信号量) 的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。</p></li></ul><p>整个 synchronized 锁流程如下：<br>①检测 Mark Word 里面是不是当前线程的 ID，如果是，表示当前线程处于偏向锁<br>②如果不是，则使用 CAS 将当前线程的 ID 替换 Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位 1<br>③如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。<br>④当前线程使用 CAS 将对象头的 Mark Word 替换为锁记录指针，如果成功，当前线程获得锁<br>⑤如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>⑥如果自旋成功则依然处于轻量级状态。<br>⑦如果自旋失败，则升级为重量级锁。</p><table><thead><tr><th>锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td><td align="center">如果始终得不到锁竞争的线程使用自旋会消耗 CPU</td><td align="center">追求响应时间，锁占用时间很短</td></tr><tr><td>重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗 CPU</td><td align="center">线程阻塞，响应时间缓慢</td><td align="center">追求吞吐量，锁占用时间较长</td></tr></tbody></table><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待（不会睡眠），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>自旋锁是非阻塞锁，一直占用 CPU，他在未获得锁的情况下，一直尝试得到锁也就是自旋，所以占用着 CPU，如果不能在很短的时间内获得锁，会使 CPU 效率降低。</p></blockquote><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap（JDK7 与 JDK8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 HashMap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计 size 的时候，可就是获取 HashMap 全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><p>[参考链接] <a href="https://blog.csdn.net/li3781695/article/details/99715169" target="_blank" rel="noopener">https://blog.csdn.net/li3781695/article/details/99715169</a><br>[参考链接] <a href="https://blog.csdn.net/tyyj90/article/details/78236053" target="_blank" rel="noopener">https://blog.csdn.net/tyyj90/article/details/78236053</a><br>[参考链接] <a href="https://blog.csdn.net/qq_41282026/article/details/98304960" target="_blank" rel="noopener">https://blog.csdn.net/qq_41282026/article/details/98304960</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲的所有锁，不会在这里详细讲解，只是给个概念，之后碰到了这种叫法知道是什么就行，详细的讲解请见博客其他文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-锁概念" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/09/20/volatile/"/>
    <id>http://yoursite.com/2019/09/20/volatile/</id>
    <published>2019-09-20T09:28:24.000Z</published>
    <updated>2019-09-27T06:23:58.850Z</updated>
    
    <content type="html"><![CDATA[<p>在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.<br><img src="/2019/09/20/volatile/aaa.png" alt><br>1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。<br>2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。</p><a id="more"></a><h1 id="volatile通过禁止指令重排保证有序性"><a href="#volatile通过禁止指令重排保证有序性" class="headerlink" title="volatile通过禁止指令重排保证有序性"></a>volatile通过禁止指令重排保证有序性</h1><p>在多线程模式下，指令重排的时候会出现问题，所以在多线程的情况下为了保证线程安全，需要禁止掉指令重排。<br>volatile在禁止指令重排方面的应用：</p><ol><li>通过一个变量来进行初始化判断。如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean isInit = false;</span><br><span class="line">private Manager mManger;</span><br><span class="line">public Manager getManager()&#123;</span><br><span class="line">  if(!isInit)&#123;</span><br><span class="line">    mManger = initManager();</span><br><span class="line">    isInit = true;</span><br><span class="line">  &#125;</span><br><span class="line">  return mManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子在单线程下没有任何问题，但是在多线程情况下如果进行了指令重排，那么代码是有问题的。比如指令重排之后，把 isInit = true 放在了 mManager = initManager() 之上，很可能在多线程的情况下出现 mManager 为空的情况，从而出现空指针异常。线程 1 执行 getManager 方法，由于指令重排，isInit = true 先执行，然后去真正初始化 mManager, 最后返回 mManager 实例，不会有任何问题。但是当线程 1 执行完 isInit = true 之后，线程 2 开始执行 getManager 方法，发现 isInit 为 true，就直接返回了 mManager，而此时 mManager 还没有初始化，所以线程 2 中会出现空指针异常。</p><ol start="2"><li>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance () 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance () 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance () 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><pre><code>1⃣️分配一块内存 M；2⃣️在内存 M 上初始化 Singleton 对象；3⃣️然后 M 的地址赋值给 instance 变量。</code></pre><p>换成代码如下：</p><pre><code>1⃣️memory = allocate () // 分配内存；2⃣️ctorInstanc (memory) // 初始化对象；3⃣️instance = memory // 设置 instance 指向刚分配的地址</code></pre><p>但是实际上优化后的执行路径却是这样的：</p><pre><code>1⃣️分配一块内存 M；2⃣️将 M 的地址赋值给 instance 变量；3⃣️最后在内存 M 上初始化 Singleton 对象。</code></pre><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance () 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance () 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。<br>正确写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 关键字禁止指令重排序有两层意思：</p><p>1）当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>2）在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p><p>举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"></span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;        //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure><p>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。</p><p>并且 volatile 关键字能保证，执行到语句 3 时，语句 1 和语句 2 必定是执行完毕了的，且语句 1 和语句 2 的执行结果对语句 3、语句 4、语句 5 是可见的。</p><h1 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h1><ol><li>从上面知道 volatile 关键字保证了操作的可见性，但是 volatile 不能保证对变量的操作是原子性的，可以参考Java并发编程实战第三章。<br>下面看一个带有自增操作的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面例子输出的结果是小于10000的数，可能有的朋友就会有疑问，上面是对变量 inc 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 inc 自增完之后，在其他线程中都能看到修改后的值啊，所以有 10 个线程分别进行了 1000 次操作，那么最终 inc 的值应该是 1000*10=10000。</p><p>这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。</p><p>由于自增操作是不具备原子性的，它包括读取变量的原始值、进行加 1 操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量 inc 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了变量 inc 的原始值，然后线程 1 被阻塞了；<br>然后线程 2 对变量进行自增操作，线程 2 也去读取变量 inc 的原始值，由于线程 1 只是对变量 inc 进行读取操作，而没有对变量进行修改操作，所以不会导致线程 2 的工作内存中缓存变量 inc 的缓存行无效，线程 2 会直接去主存读取 inc 的值，发现 inc 的值是10，然后进行加 1 操作，并把 11 写入工作内存，最后写入主存。</p><p>然后线程 1 接着进行加 1 操作，由于已经读取了 inc 的值，注意此时在线程 1 的工作内存中 inc 的值仍然为 10，所以线程 1 对 inc 进行加 1 操作后 inc 的值为 11，然后将 11 写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc 只增加了 1。</p><p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改 volatile 变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的 happens-before 规则中的 volatile 变量规则，但是要注意，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。</p><p>根源就在这里，自增操作不是原子性操作，而且 volatile 也无法保证对变量的任何操作都是原子性的。</p><h2 id="对于不保证原子性的解释"><a href="#对于不保证原子性的解释" class="headerlink" title="对于不保证原子性的解释"></a>对于不保证原子性的解释</h2><p>对于上面解释原子性的操作，大家估计会有这种疑问，即当线程 1 将变量 a 读入到了自己的工作内存，还没有修改，被阻塞；线程 2 将主存中的 a 读入工作内存修改，写入主存；线程 1 苏醒是继续运行还是会检测工作内存的变量 a 是否需要刷新呢？</p><p>对于上面问题的解释，网上大致是有两种不同的解释：<br>观点1. 当线程一读取10之后被阻塞了。然后线程二得到了执行机会，并且在执行inc自增操作的时候没有被阻塞，那么线程二执行完自增操作之后更新工作内存，然后刷新到主存中，这时线程一又有了执行机会，那么线程一继续使用之前读取的值10进行自增操作（而不是从主存中读取值11进行自增操作）。<br>观点一就是说线程二修改了主存之后，线程一再次获得执行权后并没有马上去读取主存的值进行自增操作，而是使用原来的10进行自增操作。也就是认为线程二更新主存之后，没有马上去更新线程一的工作内存，导致线程一还是之前的值。</p><p>观点2. 1⃣️线程一读取 inc 的值后，还没有操作就被阻塞了。<br>2⃣️线程二被唤醒，从主存读取 inc 的值，加 1，然后被阻塞。（此时还没来得及把新的值重新赋值给 inc，当然也还没同步到主存）。<br>3⃣️线程一被唤醒，inc 值加 1，然后同步到主存（线程一结束）。<br>4⃣️线程二被唤醒，把最新的值赋值给 inc，同步到主存（此时线程二，inc 的值在第 2 步时已经被处理过了，仅仅只是把新的值赋值给 inc 而已。这个时候是不会再去读取 inc 的缓存行的，虽然 inc 的缓存行此时已经无效了）<br>观点二可以理解为，自增操作的三步：1.复制到工作内存 2.自增 3.写入主存，其中只有 1,2 步在执行之前会检查缓存行，第 3 步是不检查的。把计算后的值赋值给变量，是不需要去检查缓存行的。</p><p>我更倾向于观点二也就是说线程二更新主存之后，会马上使得线程一得工作内存失效，在线程一再去读取Inc的值时会去读取主存中的值。</p><p>把上面的代码改成以下任何一种都可以达到效果：<br>1⃣️采用 synchronized：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2⃣️采用 Lock：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  int inc = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3⃣️采用 AtomicInteger：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc = new AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>volatile 只保证了可见性和防止了指令重排序，并没有保证原子性。</li><li>volatile 修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。volatile 会使得变量 “立即” 刷新到内存中的！而不会在写入内存之前被阻塞！</li><li>在 synchronized 修饰的方法体或者常量（final）不需要使用 volatile。</li><li>由于使用了 volatile 屏蔽掉了 JVM 中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。</li></ol><p>[参考文章]<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JVM 中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据.&lt;br&gt;&lt;img src=&quot;/2019/09/20/volatile/aaa.png&quot; alt&gt;&lt;br&gt;1）对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。&lt;br&gt;2）对于 volatile 变量：读操作时 JVM 会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作 JVM 也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-volatile关键字" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>java多线程的生命周期</title>
    <link href="http://yoursite.com/2019/09/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/09/19/java多线程的生命周期/</id>
    <published>2019-09-19T10:28:24.000Z</published>
    <updated>2019-09-30T08:06:40.840Z</updated>
    
    <content type="html"><![CDATA[<p>Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。</p><p>在操作系统层面，线程也有 “生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了。</p><p>我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下 Java 中线程的生命周期。</p><a id="more"></a><h3 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h3><p>通用的线程生命周期基本上可以用下图这个 “五态模型” 来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。</p><p><img src="/2019/09/19/java多线程的生命周期/9bbc6fa7fb4d631484aa953626cf6ae5.png" alt></p><p>这 “五态模型” 的详细情况如下所示。</p><p>①<strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配 CPU 执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。<br>②<strong>可运行状态</strong>，指的是线程可以分配 CPU 执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。<br>③当有空闲的 CPU 时，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成了<strong>运行状态</strong>。<br>④运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放 CPU 使用权，休眠状态的线程永远没有机会获得 CPU 使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。<br>⑤线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。<br>这五种状态在不同编程语言里会有简化合并。例如，C 语言的 POSIX Threads 规范，就把初始状态和可运行状态合并了；Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。</p><p>除了简化合并，这五种状态也有可能被细化，比如，Java 语言里就细化了休眠状态。</p><h3 id="Java-中线程的生命周期"><a href="#Java-中线程的生命周期" class="headerlink" title="Java 中线程的生命周期"></a>Java 中线程的生命周期</h3><p>Java 语言中线程共有六种状态，分别是：</p><ol><li>NEW（初始化状态）</li><li>RUNNABLE（可运行 / 运行状态）</li><li>BLOCKED（阻塞状态）</li><li>WAITING（无时限等待）</li><li>TIMED_WAITING（有时限等待）</li><li>TERMINATED（终止状态）<br>在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，<strong>那么这个线程就永远没有 CPU 的使用权</strong>。</li></ol><p>所以 Java 线程的生命周期可以简化为下图：<br><img src="/2019/09/19/java多线程的生命周期/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png" alt></p><p>其中，BLOCKED、WAITING、TIMED_WAITING 可以理解为线程导致休眠状态的三种原因。那具体是哪些情形会导致线程从 RUNNABLE 状态转换到这三种状态呢？而这三种状态又是何时转换回 RUNNABLE 的呢？以及 NEW、TERMINATED 和 RUNNABLE 状态是如何转换的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A thread state.  A thread can be in one of the following states:</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #NEW&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has not yet started is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #RUNNABLE&#125;&lt;br&gt;</span><br><span class="line">     *     A thread executing in the Java virtual machine is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #BLOCKED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is blocked waiting for a monitor lock</span><br><span class="line">     *     is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting indefinitely for another thread to</span><br><span class="line">     *     perform a particular action is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TIMED_WAITING&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that is waiting for another thread to perform an action</span><br><span class="line">     *     for up to a specified waiting time is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;li&gt;&#123;@link #TERMINATED&#125;&lt;br&gt;</span><br><span class="line">     *     A thread that has exited is in this state.</span><br><span class="line">     *     &lt;/li&gt;</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * A thread can be in only one state at a given point in time.</span><br><span class="line">     * These states are virtual machine states which do not reflect</span><br><span class="line">     * any operating system thread states.</span><br><span class="line">     *</span><br><span class="line">     * @since   1.5</span><br><span class="line">     * @see #getState</span><br><span class="line">     */</span><br><span class="line">    public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the state of this thread.</span><br><span class="line">     * This method is designed for use in monitoring of the system state,</span><br><span class="line">     * not for synchronization control.</span><br><span class="line">     *</span><br><span class="line">     * @return this thread&apos;s state.</span><br><span class="line">     * @since 1.5</span><br><span class="line">     */</span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        // get current thread state</span><br><span class="line">        return sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-RUNNABLE-与-BLOCKED-的状态转换"><a href="#1-RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="1. RUNNABLE 与 BLOCKED 的状态转换"></a>1. RUNNABLE 与 BLOCKED 的状态转换</h3><p>只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。</p><p>如果你熟悉操作系统线程的生命周期的话，可能会有个疑问：线程调用阻塞式 API 时，是否会转换到 BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。<strong>JVM 层面并不关心操作系统调度相关的状态</strong>，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。</p><p>而我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。</p><h3 id="2-RUNNABLE-与-WAITING-的状态转换"><a href="#2-RUNNABLE-与-WAITING-的状态转换" class="headerlink" title="2. RUNNABLE 与 WAITING 的状态转换"></a>2. RUNNABLE 与 WAITING 的状态转换</h3><p>总体来说，有三种场景会触发这种转换。</p><p>第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait () 方法。其中，wait () 方法我们在上一篇讲解管程的时候已经深入介绍过了，这里就不再赘述。</p><p>第二种场景，调用无参数的 Thread.join () 方法。其中的 join () 是一种线程同步方法，例如有一个线程对象 thread A，当调用 A.join () 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。</p><p>第三种场景，调用 LockSupport.park () 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用 LockSupport.park () 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark (Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。</p><h3 id="3-RUNNABLE-与-TIMED-WAITING-的状态转换"><a href="#3-RUNNABLE-与-TIMED-WAITING-的状态转换" class="headerlink" title="3. RUNNABLE 与 TIMED_WAITING 的状态转换"></a>3. RUNNABLE 与 TIMED_WAITING 的状态转换</h3><p>有五种场景会触发这种转换：</p><p>调用带超时参数的 Thread.sleep (long millis) 方法；<br>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait (long timeout) 方法；<br>调用带超时参数的 Thread.join (long millis) 方法；<br>调用带超时参数的 LockSupport.parkNanos (Object blocker, long deadline) 方法；<br>调用带超时参数的 LockSupport.parkUntil (long deadline) 方法。<br>这里你会发现 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了<strong>超时参数</strong>。</p><h3 id="4-从-NEW-到-RUNNABLE-状态"><a href="#4-从-NEW-到-RUNNABLE-状态" class="headerlink" title="4. 从 NEW 到 RUNNABLE 状态"></a>4. 从 NEW 到 RUNNABLE 状态</h3><p>Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run () 方法。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 自定义线程对象</span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    // 线程需要执行的代码</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建线程对象</span><br><span class="line">MyThread myThread = new MyThread();</span><br></pre></td></tr></table></figure><p>另一种是实现 Runnable 接口，重写 run () 方法，并将该实现类作为创建 Thread 对象的参数。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 实现 Runnable 接口</span><br><span class="line">class Runner implements Runnable &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    // 线程需要执行的代码</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建线程对象</span><br><span class="line">Thread thread = new Thread(new Runner());</span><br></pre></td></tr></table></figure><p>NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start () 方法就可以了，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = new MyThread();</span><br><span class="line">// 从 NEW 状态转换到 RUNNABLE 状态</span><br><span class="line">myThread.start()；</span><br></pre></td></tr></table></figure><h3 id="5-从-RUNNABLE-到-TERMINATED-状态"><a href="#5-从-RUNNABLE-到-TERMINATED-状态" class="headerlink" title="5. 从 RUNNABLE 到 TERMINATED 状态"></a>5. 从 RUNNABLE 到 TERMINATED 状态</h3><p>线程执行完 run () 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run () 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run () 方法的执行，例如 run () 方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java 的 Thread 类里面倒是有个 stop () 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用 interrupt () 方法。</p><p><strong><em>那 stop () 和 interrupt () 方法的主要区别是什么呢？</em></strong></p><p>stop () 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop () 的线程并不会自动调用 ReentrantLock 的 unlock () 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend () 和 resume () 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。</p><p>而 interrupt () 方法就温柔多了，interrupt () 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p><p>当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt () 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait ()、join ()、sleep () 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt () 方法。</p><p>当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其他线程调用线程 A 的 interrupt () 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt () 方法，线程 A 的 java.nio.channels.Selector 会立即返回。</p><p>上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt () 方法，那么线程 A 可以通过 isInterrupted () 方法，检测是不是自己被中断了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助，多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。同时，本文介绍的线程生命周期具备很强的通用性，对于学习其他语言的多线程编程也有很大的帮助。</p><p>你可以通过 jstack 命令或者 Java VisualVM 这个可视化工具将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。例如，我曾经写过一个死锁的程序，导出的线程栈明确告诉我发生了死锁，并且将死锁线程的调用栈信息清晰地显示出来了。导出线程栈，分析线程状态是诊断并发问题的一个重要工具。</p><p>[参考链接]<a href="https://time.geekbang.org/column/article/86366" target="_blank" rel="noopener">https://time.geekbang.org/column/article/86366</a><br>[参考链接]<a href="https://www.jianshu.com/p/9d98aac9cf22?utm_campaign=haruki" target="_blank" rel="noopener">https://www.jianshu.com/p/9d98aac9cf22?utm_campaign=haruki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。&lt;/p&gt;
&lt;p&gt;在操作系统层面，线程也有 “生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂生命周期中各个节点的状态转换机制就可以了。&lt;/p&gt;
&lt;p&gt;我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下 Java 中线程的生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程-生命周期" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理之基本概念</title>
    <link href="http://yoursite.com/2019/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/13/计算机组成原理之基本概念/</id>
    <published>2019-09-13T11:10:22.000Z</published>
    <updated>2019-09-27T09:30:52.576Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。<br>不要问看懂看不懂，现在就是看不懂也要看啊，越到后面越需要基础的东西，早点学会基础的东西，早点享受基础知识带来的红利；<br>学计算机基础就是要苟，不知道苟啥意思是吧，我给你详细解释一下；<br><img src="/2019/09/13/计算机组成原理之基本概念/68258.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看计算机组成原理，估计会写5-10篇左右博客，主要还是根据冯.诺依曼体系结构来分篇的。学计算机组成原理之前先过一遍C语言，大学学的C语言都还回去了，现在要再借过来。还得会一点汇编知识，基本的汇编命令能看懂就可以了。&lt;br&gt;不要问看懂看不懂，现在就是看不懂也要看啊，越到
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理-概念" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Thrift简介</title>
    <link href="http://yoursite.com/2019/09/01/Thrift%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/09/01/Thrift简介/</id>
    <published>2019-09-01T10:28:24.000Z</published>
    <updated>2019-09-30T07:12:07.625Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Thrift" scheme="http://yoursite.com/categories/Thrift/"/>
    
    
      <category term="RPC，远程调用" scheme="http://yoursite.com/tags/RPC%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-Trie树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-Trie树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:36:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-Trie树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-二叉树/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:33:28.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-二叉树" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-图/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:35:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-图" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-堆/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:34:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-堆" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-散列表</title>
    <link href="http://yoursite.com/2019/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/14/数据结构-散列表/</id>
    <published>2019-05-14T11:57:10.000Z</published>
    <updated>2019-05-14T06:32:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构-散列表" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
</feed>
