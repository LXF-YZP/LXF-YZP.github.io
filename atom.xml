<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-20T09:48:48.502Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>策略模式</title>
    <link href="http://yoursite.com/2020/03/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/21/策略模式/</id>
    <published>2020-03-21T11:57:10.000Z</published>
    <updated>2020-03-20T09:48:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是策略模式？"><a href="#一、什么是策略模式？" class="headerlink" title="一、什么是策略模式？"></a>一、什么是策略模式？</h2><p>在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。<br>然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。</p><a id="more"></a><h2 id="二、基本的策略模式使用方法"><a href="#二、基本的策略模式使用方法" class="headerlink" title="二、基本的策略模式使用方法"></a>二、基本的策略模式使用方法</h2><p>我们直接来看例子：</p><h3 id="1-策略接口"><a href="#1-策略接口" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    void testStrategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备两个实现类"><a href="#2-准备两个实现类" class="headerlink" title="2. 准备两个实现类"></a>2. 准备两个实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 实现类A</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyA implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 实现类B</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyB implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void testStrategy() &#123;</span><br><span class="line">        System.out.println(&quot;我是实现类B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-策略执行-Context-类"><a href="#3-策略执行-Context-类" class="headerlink" title="3. 策略执行 Context 类"></a>3. 策略执行 Context 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 策略执行</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class Context &#123;</span><br><span class="line">    </span><br><span class="line">    private Strategy stg;</span><br><span class="line">    </span><br><span class="line">    public void doAction() &#123;</span><br><span class="line">        this.stg.testStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">    /*  Getter And Setter */</span><br><span class="line">    public Strategy getStg() &#123;</span><br><span class="line">        return stg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStg(Strategy stg) &#123;</span><br><span class="line">        this.stg = stg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们准备一个 main 方法来测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: StrategyTest</span><br><span class="line"> * Author:    lllx</span><br><span class="line"> * Created at:    2017/12/18</span><br><span class="line"> */</span><br><span class="line">public class StrategyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy stgB = new StrategyB();</span><br><span class="line">        Context context = new Context(stgB);</span><br><span class="line">        context.setStg(stgB);</span><br><span class="line">        context.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、与-Spring-想结合的策略模式"><a href="#三、与-Spring-想结合的策略模式" class="headerlink" title="三、与 Spring 想结合的策略模式"></a>三、与 Spring 想结合的策略模式</h2><p>我们主要利用 Spring 的核心 IOC 来实现它，还是使用上面的例子；<br>由于我们要在 Spring 的配置文件中来注入 Context 的实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;context&quot; class = &quot;top.catalinali.search.service.impl.Context&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;stg&quot; ref=&quot;stgB&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;stgA&quot; class = &quot;top.catalinali.search.service.impl.StrategyA&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;stgB&quot; class = &quot;top.catalinali.search.service.impl.StrategyB&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样就可以通过只修改配置文件来更改 context 的实现类，从而达到策略模式的目的。</p><h2 id="四、通过-Spring-使用策略模式替换中间件的单机与集群配置"><a href="#四、通过-Spring-使用策略模式替换中间件的单机与集群配置" class="headerlink" title="四、通过 Spring 使用策略模式替换中间件的单机与集群配置"></a>四、通过 Spring 使用策略模式替换中间件的单机与集群配置</h2><p>在开发环境中，许多中间件使用的是单机配置。可到了生产我们就需要使用集群配置。这里我们就可以通过策略模式来快速改变中间件的配置，现在我们以 Redis 为例：</p><h3 id="1-策略接口-1"><a href="#1-策略接口-1" class="headerlink" title="1. 策略接口"></a>1. 策略接口</h3><p>首先我们把 Redis 方法抽成一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface JedisClient &#123;</span><br><span class="line">    String set(String key, String value);</span><br><span class="line">    String get(String key);</span><br><span class="line">    Boolean exists(String key);</span><br><span class="line">    Long expire(String key, int seconds);</span><br><span class="line">    Long ttl(String key);</span><br><span class="line">    Long incr(String key);</span><br><span class="line">    Long hset(String key, String field, String value);</span><br><span class="line">    String hget(String key, String field);</span><br><span class="line">    Long hdel(String key, String... field);</span><br><span class="line">    Boolean hexists(String key, String field);</span><br><span class="line">    List&lt;String&gt; hvals(String key);</span><br><span class="line">    Long del(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-单机和集群两个实现类"><a href="#2-单机和集群两个实现类" class="headerlink" title="2. 单机和集群两个实现类"></a>2. 单机和集群两个实现类</h3><p>这里我们准备单机和集群两个实现类：JedisClientPool 和 JedisClientCluster。实现上面的 JedisClient 接口，分别使用单机和集群的代码来实现这些方法。因为代码冗长就不在这里贴出来了。</p><h3 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h3><p>我们使用不同的环境只需要把不用的配置注释掉就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 连接redis单机版 --&gt;</span><br><span class="line">&lt;bean id=&quot;jedisClientPool&quot; class=&quot;top.catalinali.common.jedis.JedisClientPool&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisPool&quot; ref=&quot;jedisPool&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.72.121&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 连接redis集群 --&gt;</span><br><span class="line">&lt;!-- &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;cn.e3mall.common.jedis.JedisClientCluster&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jedisCluster&quot; ref=&quot;jedisCluster&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;nodes&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">            &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.162&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt; </span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt; --&gt;</span><br></pre></td></tr></table></figure><p>这样在我们开发时只需要注释掉连接集群的配置，而在上线时注释掉单机的配置就好。</p><p>[转载]<a href="https://segmentfault.com/a/1190000012474002" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012474002</a><br>[参考链接]<a href="https://juejin.im/post/59facc30518825297a0e164c" target="_blank" rel="noopener">https://juejin.im/post/59facc30518825297a0e164c</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是策略模式？&quot;&gt;&lt;a href=&quot;#一、什么是策略模式？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是策略模式？&quot;&gt;&lt;/a&gt;一、什么是策略模式？&lt;/h2&gt;&lt;p&gt;在开发中常常遇到这种情况，实现某一个功能有多方式，我们可以根据不同的条件选择不同的方式来完成该功能。最常用的方法是将这些算法方式写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的算法；或者通过 if…else… 或者 case 等条件判断语句来进行选择。&lt;br&gt;然而该类代码将较复杂，维护较为困难。如果我们把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。这就是策略模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="策略模式" scheme="http://yoursite.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="http://yoursite.com/2020/03/20/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/20/装饰器模式/</id>
    <published>2020-03-20T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:24.639Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="装饰器模式" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板模式</title>
    <link href="http://yoursite.com/2020/03/19/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/19/模板模式/</id>
    <published>2020-03-19T11:57:10.000Z</published>
    <updated>2020-03-19T06:37:17.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板模式优缺点"><a href="#模板模式优缺点" class="headerlink" title="模板模式优缺点"></a>模板模式优缺点</h3><p>优点:<br>使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求，封装不变部分，扩展可变部分；例如你装饰房子的方法有很多种，每一种都可能给你带来不一样的体验；<br>提取公共代码，有利于后期的维护；例如每个房间功能明确；<br>行为由父类控制，子类实现；比如定义了厨房这个房间，具体厨房要怎么装修，要看你的做法；<br>缺点:<br>如果算法骨架有修改的话，则需要修改抽象类；(修改整体框架是很困难的)<br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。(这里类似于房间的装修方案)</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>设计模板类，也就是父类，由父类规定好框架，抽象方法以及父类的功能；<br>具体实现留给继承父类的子类进行实现；这样就实现了父类的重复使用，也就是模板；</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先定义一个模板类，它的非抽象方法需要定为 final, 因为它不希望被子类继承和改写，这个功能是父类特有的；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class House &#123;</span><br><span class="line">    // 子类要实现的方法;</span><br><span class="line">    public abstract void bathroom();</span><br><span class="line">    public abstract void bedroom();</span><br><span class="line">    public abstract void kitchen();</span><br><span class="line"></span><br><span class="line">    // 为了避免子类继承, 一般模板的方法都加上final;</span><br><span class="line">    public final void decorate() &#123;</span><br><span class="line">        // 装修浴室;</span><br><span class="line">        bathroom();</span><br><span class="line"></span><br><span class="line">        // 装修卧室;</span><br><span class="line">        bedroom();</span><br><span class="line"></span><br><span class="line">        // 装修厨房;</span><br><span class="line">        kitchen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是实现子类，这里我们实现两个装修方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class scheme1 extends House &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bathroom() &#123;</span><br><span class="line">        System.out.println(&quot;bathroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bedroom() &#123;</span><br><span class="line">        System.out.println(&quot;bedroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void kitchen() &#123;</span><br><span class="line">        System.out.println(&quot;kitchen scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class scheme1 extends House &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bathroom() &#123;</span><br><span class="line">        System.out.println(&quot;bathroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bedroom() &#123;</span><br><span class="line">        System.out.println(&quot;bedroom scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void kitchen() &#123;</span><br><span class="line">        System.out.println(&quot;kitchen scheme one!!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是两个装修方案，接下来来看看测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class demo_house &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args) &#123;</span><br><span class="line">        House house; // 父类引用;</span><br><span class="line">        // 方案1;</span><br><span class="line">        house = new scheme1();</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">        // 方案2;</span><br><span class="line">        house = new scheme2();</span><br><span class="line">        house.decorate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bathroom scheme one!!!</span><br><span class="line">bedroom scheme one!!!</span><br><span class="line">kitchen scheme one!!!</span><br><span class="line">---------------------</span><br><span class="line">bathroom scheme two!!!</span><br><span class="line">bedroom scheme two!!!</span><br><span class="line">kitchen scheme two!!!</span><br></pre></td></tr></table></figure><p>[转载]<a href="https://zhuanlan.zhihu.com/p/40770254" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40770254</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模板模式优缺点&quot;&gt;&lt;a href=&quot;#模板模式优缺点&quot; class=&quot;headerlink&quot; title=&quot;模板模式优缺点&quot;&gt;&lt;/a&gt;模板模式优缺点&lt;/h3&gt;&lt;p&gt;优点:&lt;br&gt;使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.7hashmap多线程下成环原因</title>
    <link href="http://yoursite.com/2020/03/18/jdk1.7hashmap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%88%90%E7%8E%AF%E5%8E%9F%E5%9B%A0/"/>
    <id>http://yoursite.com/2020/03/18/jdk1.7hashmap多线程下成环原因/</id>
    <published>2020-03-18T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:26.175Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.7下hashmap的部分源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable)&#123;</span><br><span class="line">        Entry[] src=table;</span><br><span class="line">        int newCapacity=newTable.length;    </span><br><span class="line">        for(int j=0;j&lt;src.length;j++)&#123;</span><br><span class="line">            Entry&lt;K, V&gt; e=src[j];</span><br><span class="line">            if(e!=null)&#123;</span><br><span class="line">                src[j]=null;</span><br><span class="line">                do&#123;</span><br><span class="line">                    Entry&lt;K, V&gt; next=e.next;// 保存下一次循环的 Entry</span><br><span class="line">                    // 在新的 table 中求得适合插入的位置</span><br><span class="line">                    int i=indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next=newTable[i];//  如果 I 位置原来没有值，则直接插入；有值，采用链头插入法</span><br><span class="line">                    newTable[i]=e;</span><br><span class="line">                    // 轮替，下一次循环</span><br><span class="line">                    e=next;</span><br><span class="line">                &#125;while(e!=null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/aaa.png" alt></p><p>假设原来在数组 1 的下标位置有个链表，链表元素是 a-b-null，现在有两个线程同时执行这个方法，我们先来根据线程 1 的执行情况来分别分析下这三行代码：<br>e.next = newTable[i];<br>newTable 表示新的数组，newTable [i] 表示新数组下标为 i 的值，第一次循环的时候为 null，e 表示原来链表位置的头一个元素，是 a，e.next 是 b，<br>e.next = newTable [i] 的意思就是拿出 a 来，并且使 a 的后一个节点是 null;</p><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/bbb.png" alt></p><p>newTable[i] = e;<br>就是把 a 赋值给新数组下标为 1 的地方;</p><p>e = next;<br>next 的值在 while 循环一开始就有了，为：Entrynext = e.next; 在此处 next 的值就是 b，把 b 赋值给 e，接着下一轮循环。</p><p>从 b 开始下一轮循环，重复 1、2、3，注意此时 e 是 b 了，而 newTable [i] 的值已经不是空了，已经是 a 了，所以 1，2，3 行代码执行下来，b 就会插入到 a 的前面，如下图 ;</p><p><img src="/2020/03/18/jdk1.7hashmap多线程下成环原因/ccc.png" alt></p><p>这个就是线程 1 的插入节奏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk1.7下hashmap的部分源码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void transfer(Entry[] newTable)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Entry[] src=table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int newCapacity=newTable.length;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int j=0;j&amp;lt;src.length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Entry&amp;lt;K, V&amp;gt; e=src[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(e!=null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                src[j]=null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Entry&amp;lt;K, V&amp;gt; next=e.next;// 保存下一次循环的 Entry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    // 在新的 table 中求得适合插入的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    int i=indexFor(e.hash, newCapacity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e.next=newTable[i];//  如果 I 位置原来没有值，则直接插入；有值，采用链头插入法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    newTable[i]=e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    // 轮替，下一次循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e=next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;while(e!=null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jar包的执行方式</title>
    <link href="http://yoursite.com/2020/03/17/jar%E5%8C%85%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/17/jar包的执行方式/</id>
    <published>2020-03-17T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:27.696Z</updated>
    
    <content type="html"><![CDATA[<p>System.getProperty(“user.home”);//当前登录用户目录<br>System.getProperty(“user.dir”);//jar包所在目录名</p><p>java -cp执行jar包的时候，可以指定外部依赖<br>java -cp aaa.jar(要执行的jar包):/data/apps/ilb/*(要执行jar包所依赖的jar文件) com.chinacache.Main(jar包运行的主类)</p><a id="more"></a><p>JDK6 支持 java -cp 后面跟通配符 ‘*’，试了一下发现还是需要注意：</p><p>错误方式（Wrong way）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  -cp aaa.jar:/data/apps/lib/*.jar com.chinacache.Main</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java  -cp aaa.jar:/data/apps/ilb/ com.chinacache.Main</span><br></pre></td></tr></table></figure><p>正确方式（right way）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp aaa.jar:/data/apps/ilb/* com.chinacache.Main</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;System.getProperty(“user.home”);//当前登录用户目录&lt;br&gt;System.getProperty(“user.dir”);//jar包所在目录名&lt;/p&gt;
&lt;p&gt;java -cp执行jar包的时候，可以指定外部依赖&lt;br&gt;java -cp aaa.jar(要执行的jar包):/data/apps/ilb/*(要执行jar包所依赖的jar文件) com.chinacache.Main(jar包运行的主类)&lt;/p&gt;
    
    </summary>
    
    
      <category term="jar包" scheme="http://yoursite.com/categories/jar%E5%8C%85/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://yoursite.com/2020/03/10/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/10/String源码学习/</id>
    <published>2020-03-10T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:23.430Z</updated>
    
    <content type="html"><![CDATA[<p>调用String stringValue = new String(“asdre”);时，才会调用构造方法执行 value 的赋值操作，值是来自于字符串字面量 “asdre” 这个 String 对象的。<br>比较好奇的是在调用构造之前 “asdre” 是怎么被初始化的，事实上这段字符串是写在 Java 代码里的，编译器遇到这段字符串后会将字符串字面量的内容编译到 class bytecode 二进制文件中。当虚拟机加载这个 class 文件时，这种字符串字面量会被 JVM 初始化成一个 String 对象，存储在字符串常量池中。</p><p>也就是说这个 String 对象是虚拟机进行初始化产生的，而字符串内容的来源是二进制的 class 文件，而二进制文件中的来源就是您在 java 源码文本中写入的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用String stringValue = new String(“asdre”);时，才会调用构造方法执行 value 的赋值操作，值是来自于字符串字面量 “asdre” 这个 String 对象的。&lt;br&gt;比较好奇的是在调用构造之前 “asdre” 是怎么被初始化的，
      
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hashmap中的干扰函数</title>
    <link href="http://yoursite.com/2020/03/10/hashmap%E4%B8%AD%E7%9A%84%E5%B9%B2%E6%89%B0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/10/hashmap中的干扰函数/</id>
    <published>2020-03-10T11:57:10.000Z</published>
    <updated>2020-03-20T07:42:12.157Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null；<br>jdk1.8中hashmap的代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面代码里的 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。<br>理论上散列值是一个 int 型，如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从 -2147483648 到 2147483648。前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。<br>但问题是一个 40 亿长度的数组，内存是放不下的。你想，HashMap 扩容之前的数组初始大小才 16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算如下<br><img src="/2020/03/10/hashmap中的干扰函数/aaa.png" alt></p><p>那么这也就明白了为什么 HashMap 的数组长度是 2 的整数幂。比如以初始长度为 16 为例，16-1 = 15，15 的二进制数位 00000000 00000000 00001111。可以看出一个基数二进制最后一位必然位 1，当与一个 hash 值进行与运算时，最后一位可能是 0 也可能是 1。但偶数与一个 hash 值进行与运算最后一位必然为 0，造成有些位置永远映射不上值。<br>但是这时，又出现了一个问题，即使散列函数很松散，但只取最后几位碰撞也会很严重。这时候 hash 算法的价值就体现出来了，<br><img src="/2020/03/10/hashmap中的干扰函数/bbb.png" alt><br>hashCode 右移 16 位，正好是 32bit 的一半。与自己本身做异或操作（相同为 0，不同为 1）。就是为了混合哈希值的高位和地位，增加低位的随机性。并且混合后的值也变相保持了高位的特征。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null；&lt;br&gt;jdk1.8中hashmap的代码片段&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static final int hash(Object key) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hbase学习</title>
    <link href="http://yoursite.com/2020/03/09/Idea%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/03/09/Idea编译器使用技巧/</id>
    <published>2020-03-09T11:57:10.000Z</published>
    <updated>2020-03-12T06:07:23.491Z</updated>
    
    <content type="html"><![CDATA[<p>新版idea复制错误信息<br>windows：按着 alt 左键点击错误信息<br>mac：按着 option 左键点击错误信息</p><p>返回上次代码跳转的方向：command+alt+左右方向键</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新版idea复制错误信息&lt;br&gt;windows：按着 alt 左键点击错误信息&lt;br&gt;mac：按着 option 左键点击错误信息&lt;/p&gt;
&lt;p&gt;返回上次代码跳转的方向：command+alt+左右方向键&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="编译器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
      <category term="编译器使用技巧" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>hbase学习</title>
    <link href="http://yoursite.com/2020/03/03/hbase%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/03/hbase学习/</id>
    <published>2020-03-03T11:57:10.000Z</published>
    <updated>2020-03-20T07:43:28.976Z</updated>
    
    <content type="html"><![CDATA[<p>查看某张表全部rowkey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count &apos;表名&apos;, INTETVAL=1&lt;表示rowkey之间的间隔&gt;</span><br><span class="line">count &apos;&lt;tablename&gt;&apos;, CACHE =&gt; 1000&lt;表示rowkey之间的间隔&gt;</span><br></pre></td></tr></table></figure><p>查询服务器状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure><p>查询Hbase版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version</span><br></pre></td></tr></table></figure><p>查看所有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create &lt;table&gt;, &#123;NAME =&gt; &lt;family&gt;, VERSIONS =&gt; &lt;VERSIONS&gt;&#125;</span><br><span class="line">例如：创建表 t1，有两个 family name：f1，f2，且版本数均为 2</span><br><span class="line">create &apos;t1&apos;,&#123;NAME =&gt; &apos;f1&apos;, VERSIONS =&gt; 2&#125;,&#123;NAME =&gt; &apos;f2&apos;, VERSIONS =&gt; 2&#125;</span><br><span class="line">或者 create &apos;t1&apos;, &apos;f1&apos;(默认版本是1)</span><br></pre></td></tr></table></figure><p>获得表的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe &apos;member&apos;</span><br></pre></td></tr></table></figure><p>增加一个列族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;member&apos;, &apos;id&apos;</span><br></pre></td></tr></table></figure><p>删除一个列族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;member&apos;, &#123;NAME =&gt; &apos;member_id&apos;, METHOD =&gt; &apos;delete’&#125;</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 delete 命令，我们可以删除 id 为某个值的‘info:age’字段</span><br><span class="line">delete &apos;member&apos;,&apos;debugo&apos;,&apos;info:age&apos;</span><br></pre></td></tr></table></figure><p>删除整行的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteall &apos;member&apos;,&apos;debugo&apos;</span><br></pre></td></tr></table></figure><p>使用 exists 来检查表是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists &apos;member&apos;</span><br></pre></td></tr></table></figure><p>删除表需要先将表 disable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disable &apos;member&apos;</span><br><span class="line"></span><br><span class="line">drop &apos;member&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void createTable(String tableName, String columnFamily, boolean bool)&#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        Admin admin = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn = ConnectionFactory.createConnection(conf);</span><br><span class="line">            admin = conn.getAdmin();</span><br><span class="line">            //表描述器构造器</span><br><span class="line">            TableDescriptorBuilder tdb  =TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName))  ;</span><br><span class="line">            //列族描述起构造器</span><br><span class="line">            ColumnFamilyDescriptorBuilder cdb = ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(columnFamily));</span><br><span class="line">            //设置为 true，将这个列存为 MOB.</span><br><span class="line">            cdb.setMobEnabled(bool);</span><br><span class="line">            //超过阈值大小的文件，就被当成 MOB 对待。默认阈值为 100KB。</span><br><span class="line">            cdb.setMobThreshold(102400L);</span><br><span class="line">            //获得列描述器</span><br><span class="line">            ColumnFamilyDescriptor cfd = cdb.build();</span><br><span class="line"></span><br><span class="line">            //添加列族</span><br><span class="line">            tdb.setColumnFamily(cfd);</span><br><span class="line">            //获得表描述器</span><br><span class="line">            TableDescriptor td = tdb.build();</span><br><span class="line">            //创建表</span><br><span class="line">            //admin.addColumnFamily(tableName, cfd);</span><br><span class="line">            admin.createTable(td);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;Method : createTable is failed !&quot;, e);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            closeAdmin(admin, conn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看某张表全部rowkey&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据技术" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>二零一九年终总结</title>
    <link href="http://yoursite.com/2019/12/31/%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/31/二零一九年终总结/</id>
    <published>2019-12-31T11:57:10.000Z</published>
    <updated>2019-12-25T01:58:14.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><blockquote><p>2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；<br>这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；<br>年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。</p></blockquote><a id="more"></a><p>这一年下来买了30多个专栏，想想自己还是很可怕的，因为从头看完的估计都不到一半；但是也不是完全没有收获，专栏中有的话是真的很有共鸣的，比如：越早的掌握底层知识，才能越早的享受知识的红利；所以今年一年主要学习的专栏还是都很基础的，比如数据结构，计算机组成原理，计算机网络；操作系统专栏还没看完(留到2020了，要学的专栏一直往后推，这个不是一个好习惯)。虽然要学的还有很多，但是这一年我自己感觉是进步最多的一年。虽然焦虑依然存在，但是消除焦虑的进步速度也在加快。虽然这一年也有一点收获，但是从10月份开始工作的很不舒服，甚至可以说的上是压抑；人在一种压抑中学习或者成长并不快；产生了想走的心；</p><ul><li>极客时间<br><img src="/2019/12/31/二零一九年终总结/ddd.png" alt><br><img src="/2019/12/31/二零一九年终总结/eee.jpg" alt></li><li>LeetCode<br><img src="/2019/12/31/二零一九年终总结/fff.png" alt></li><li>GitHub<br><img src="/2019/12/31/二零一九年终总结/ggg.png" alt><br>忽略了很重要的一点是今年自己搭建了博客，开始陆陆续续的写一些技术博客，虽然质量不是很高，但是贵在开始有写博客的意识了。有了持续的输出，才能有持续的进步；</li></ul><p>今年发现体重问题越来越严重了，体重一直在160上下浮动，最明显后果是买衣服不好买了，体重上来之后信心明显受到了打击(本来就丑，现在还变胖了)，三姐的话变成了真的，工作之后真的会变胖；今年意识到变胖之后，还跑了几天步，结果没坚持下来（我这人果然没有什么耐心）<br><img src="/2019/12/31/二零一九年终总结/aaa.webp" alt></p><p>感情经历依然<br><img src="/2019/12/31/二零一九年终总结/bbb.jpg" alt><br><img src="/2019/12/31/二零一九年终总结/ccc.jpg" alt></p><p>今年玩游戏不是很多了，减少到去年的一半不到，明年估计连今年的一半也不到，游戏渐渐玩的不多了，这是个好现象；</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>我就不去立什么flag，因为我知道我就是立flag也实现不了，还让自己有愧疚感（我倒是很会替自己着想啊）。虽然嘴上说不去立flag，但是心里还是有想法的。我就把想法说一下吧，能不能实现是另外一回事；想到什么就说什么了，减肥还是很有必要的，先定个小目标，先减它一斤试试，今年希望减肥成功；<br>还有就是把计算机基础课程再巩固一下，争取能看到相关知识点的时候可以联想到；LeetCode上还是要刷题的，在精不在多，在持之以恒，不再于某一天的突发奇想；今年要好好用用GitHub；最重要的一点是不要为了工作再压抑了；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；&lt;br&gt;这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；&lt;br&gt;年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://yoursite.com/2019/12/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/27/背包问题/</id>
    <published>2019-12-27T11:57:10.000Z</published>
    <updated>2019-12-27T09:13:13.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变形二分查找问题二</title>
    <link href="http://yoursite.com/2019/12/25/%E5%8F%98%E5%BD%A2%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/12/25/变形二分查找问题二/</id>
    <published>2019-12-25T11:57:10.000Z</published>
    <updated>2019-12-25T10:58:52.419Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变形二分查找问题</title>
    <link href="http://yoursite.com/2019/12/24/%E5%8F%98%E5%BD%A2%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/24/变形二分查找问题/</id>
    <published>2019-12-24T11:57:10.000Z</published>
    <updated>2020-01-03T07:46:05.318Z</updated>
    
    <content type="html"><![CDATA[<ul><li>二分查找依赖数组结构<br>二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。</li><li>二分查找针对的是有序数据<br>二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O (nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。<br>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。<br>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用</li><li>数据量太小不适合二分查找<br>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。</li><li>数据量太大不适合二分查找<br>二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如 1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。</li></ul><a id="more"></a><ul><li>Binary Search 模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] arr, int key) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = arr.length - 1;</span><br><span class="line">int mid = 0;</span><br><span class="line"></span><br><span class="line">if (key &lt; arr[low] || key &gt; arr[high] || low &gt; high)</span><br><span class="line">return -1;</span><br><span class="line">while (low &lt;= high)&#123;</span><br><span class="line">mid = (low + high) / 2;</span><br><span class="line">if (arr[mid] &gt; key)</span><br><span class="line">high = mid - 1;</span><br><span class="line">else if (arr[mid] &lt; key)</span><br><span class="line">low = mid + 1;</span><br><span class="line">else</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。</p><p>不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><p><strong><em>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky…</em></strong></p><p>这句话可以这样理解：<strong><em>思路很简单，细节是魔鬼。</em></strong></p><p>探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景就是本题，后两个场景可以解决这道算法题 在排序数组中查找元素的第一个和最后一个位置。</p><p>要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="二分查找框架："><a href="#二分查找框架：" class="headerlink" title="二分查找框架："></a>二分查找框架：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p><strong><em>另外声明一下，计算 mid 时需要技巧防止溢出，即 mid = left + (right - left) / 2。本文暂时忽略这个问题。</em></strong></p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 −1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？<br>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。<br>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。<br>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid] == target)</span><br><span class="line">    return mid;</span><br></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 −1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。<br>while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 −1 即可。<br>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 −1 就是错误的。<br>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">return nums[left] == target ? left : -1;</span><br></pre></td></tr></table></figure><p>2.为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？<br>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。<br>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？<br>当然是 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。<br>3.此算法有什么缺陷？<br>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。<br>比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。<br>这样的需求很常见。你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) </span><br><span class="line">        return -1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length; // 注意</span><br><span class="line">    </span><br><span class="line">    while (left &lt; right) &#123; // 注意</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么 while(left &lt; right) 而不是 &lt;= ?<br>答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right)左闭右开。<br>while(left &lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。<br>2.为什么没有返回 −1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：<br><img src="/2019/12/24/变形二分查找问题/aaa.png" alt><br>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。<br>比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。<br>再比如说 nums 不变，target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。<br>综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">// target 比所有数都大</span><br><span class="line">if (left == nums.length) return -1;</span><br><span class="line">// 类似之前算法的处理方式</span><br><span class="line">return nums[left] == target ? left : -1;</span><br></pre></td></tr></table></figure><p>3.为什么 left = mid + 1，right = mid？和之前的算法不一样？<br>答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。<br>4.为什么该算法能够搜索左侧边界？<br>答：关键在于对于 nums[mid] == target 这种情况的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。<br>5.为什么返回 left 而不是 right？<br>答：都是一样的，因为 while 终止的条件是 left == right。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) return -1;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left - 1; // 注意</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么这个算法能够找到右侧边界？<br>答：类似地，关键点还是这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + 1;</span><br></pre></td></tr></table></figure><p>当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。<br>2.为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。<br>答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。<br>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + 1;</span><br><span class="line">    // 这样想: left = mid + 1 =&gt; mid = left - 1</span><br></pre></td></tr></table></figure><p><img src="/2019/12/24/变形二分查找问题/bbb.png" alt><br>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。<br>至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。<br>3.为什么没有返回 −1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br>答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 −1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">if (left == 0) return -1;</span><br><span class="line">return nums[left-1] == target ? (left-1) : -1;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一个，最基本的二分查找算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 while (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+1 和 right = mid-1</span><br><span class="line">​</span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure><p>第二个，寻找左侧边界的二分查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">​</span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure><p>第三个，寻找右侧边界的二分查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">​</span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line">​</span><br><span class="line">又因为收紧左侧边界时必须 left = mid + 1</span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure><p>1.分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p>2.注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>3.如需要搜索左右边界，只要在 nums [mid] == target 时做修改即可。搜索右侧时需要减一。<br>[参考链接]<a href="https://juejin.im/post/5d510f76f265da039a287a30" target="_blank" rel="noopener">https://juejin.im/post/5d510f76f265da039a287a30</a><br>[参考链接]<a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;二分查找依赖数组结构&lt;br&gt;二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。&lt;/li&gt;
&lt;li&gt;二分查找针对的是有序数据&lt;br&gt;二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O (nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。&lt;br&gt;但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。&lt;br&gt;所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用&lt;/li&gt;
&lt;li&gt;数据量太小不适合二分查找&lt;br&gt;如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。&lt;/li&gt;
&lt;li&gt;数据量太大不适合二分查找&lt;br&gt;二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如 1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双指针问题</title>
    <link href="http://yoursite.com/2019/12/22/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/22/双指针问题/</id>
    <published>2019-12-22T11:57:10.000Z</published>
    <updated>2020-01-02T06:25:16.104Z</updated>
    
    <content type="html"><![CDATA[<p>双指针一般可以分为两类，一类是快慢指针问题，一类是左右指针问题；</p><a id="more"></a><h3 id="一、快慢指针的常见算法"><a href="#一、快慢指针的常见算法" class="headerlink" title="一、快慢指针的常见算法"></a>一、快慢指针的常见算法</h3><p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。</p><h4 id="1-判定链表中是否含有环"><a href="#1-判定链表中是否含有环" class="headerlink" title="1.判定链表中是否含有环"></a>1.判定链表中是否含有环</h4><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。<br>如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    while (head != null)</span><br><span class="line">        head = head.next;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。</p><p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">​</span><br><span class="line">        if (fast == slow) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-已知链表中含有环，返回这个环的起始位置"><a href="#2-已知链表中含有环，返回这个环的起始位置" class="headerlink" title="2.已知链表中含有环，返回这个环的起始位置"></a>2.已知链表中含有环，返回这个环的起始位置</h4><p><img src="/2019/12/22/双指针问题/aaa.png" alt><br>这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (fast == slow) break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 上面的代码类似 hasCycle 函数</span><br><span class="line">    slow = head;</span><br><span class="line">    while (slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p><p>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。<br><img src="/2019/12/22/双指针问题/bbb.png" alt></p><p>设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。<br><img src="/2019/12/22/双指针问题/ccc.png" alt></p><p>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。</p><h4 id="3-寻找链表的中点"><a href="#3-寻找链表的中点" class="headerlink" title="3.寻找链表的中点"></a>3.寻找链表的中点</h4><p>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line">// slow 就在中间位置</span><br><span class="line">return slow;</span><br></pre></td></tr></table></figure><p>当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：<br><img src="/2019/12/22/双指针问题/ddd.png" alt></p><p>寻找链表中点的一个重要作用是对链表进行归并排序。</p><p>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p><p>但是现在你学会了找到链表的中点，就能实现链表的二分了。</p><h4 id="4-寻找链表的倒数第-k-个元素"><a href="#4-寻找链表的倒数第-k-个元素" class="headerlink" title="4.寻找链表的倒数第 k 个元素"></a>4.寻找链表的倒数第 k 个元素</h4><p>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode slow, fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line">while (k-- &gt; 0) </span><br><span class="line">    fast = fast.next;</span><br><span class="line">​</span><br><span class="line">while (fast != null) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br></pre></td></tr></table></figure><h3 id="二、左右指针的常用算法"><a href="#二、左右指针的常用算法" class="headerlink" title="二、左右指针的常用算法"></a>二、左右指针的常用算法</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。</p><h4 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h4><p>前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1;</span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; </span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2.两数之和"></a>2.两数之和</h4><p>直接看一道 LeetCode 题目吧：</p><p><img src="/2019/12/22/双指针问题/fff.png" alt><br>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int sum = nums[left] + nums[right];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            // 题目要求的索引是从 1 开始的</span><br><span class="line">            return new int[]&#123;left + 1, right + 1&#125;;</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            left++; // 让 sum 大一点</span><br><span class="line">        &#125; else if (sum &gt; target) &#123;</span><br><span class="line">            right--; // 让 sum 小一点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new int[]&#123;-1, -1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-反转数组"><a href="#3-反转数组" class="headerlink" title="3.反转数组"></a>3.反转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void reverse(int[] nums) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        // swap(nums[left], nums[right])</span><br><span class="line">        int temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++; right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-滑动窗口算法"><a href="#4-滑动窗口算法" class="headerlink" title="4.滑动窗口算法"></a>4.滑动窗口算法</h4><p>具体内容见滑动窗口问题这篇；</p><p>[参考链接]<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;双指针一般可以分为两类，一类是快慢指针问题，一类是左右指针问题；&lt;/p&gt;
    
    </summary>
    
    
      <category term="双指针技巧" scheme="http://yoursite.com/categories/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题二</title>
    <link href="http://yoursite.com/2019/12/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/12/20/滑动窗口问题二/</id>
    <published>2019-12-20T11:57:10.000Z</published>
    <updated>2020-01-06T10:01:47.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int slidingWindowTemplate(String[] a, ...) &#123;</span><br><span class="line">    // 输入参数有效性判断</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 申请一个散列，用于记录窗口中具体元素的个数情况</span><br><span class="line">    // 这里用数组的形式呈现，也可以考虑其他数据结构</span><br><span class="line">    int[] hash = new int[...];</span><br><span class="line">    </span><br><span class="line">    // 预处理(可省), 一般情况是改变 hash</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // l 表示左指针</span><br><span class="line">    // count 记录当前的条件，具体根据题目要求来定义</span><br><span class="line">    // result 用来存放结果</span><br><span class="line">    int l = 0, count = ..., result = ...;</span><br><span class="line">    for (int r = 0; r &lt; A.length; ++r) &#123;</span><br><span class="line">        // 更新新元素在散列中的数量</span><br><span class="line">        hash[A[r]]--;</span><br><span class="line">        </span><br><span class="line">        // 根据窗口的变更结果来改变条件值</span><br><span class="line">        if (hash[A[r]] == ...) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果当前条件不满足，移动左指针直至条件满足为止</span><br><span class="line">        while (count &gt; K || ...) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (...) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[A[l]]++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更新结果</span><br><span class="line">        results = ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line"></span><br><span class="line">    //如果待匹配的子串比原始串长，直接返回空集合；</span><br><span class="line">    if (s.length() &lt; p.length()) &#123;</span><br><span class="line">        return new ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    //转换为字符数组</span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] pArr = p.toCharArray();</span><br><span class="line"></span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    //统计p字符串中每个字符出现的次数</span><br><span class="line">    for (int i = 0; i &lt; pArr.length; ++i) &#123;</span><br><span class="line">        hash[pArr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    int l = 0, count = 0, pLength = p.length();</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r] - &apos;a&apos;]--;</span><br><span class="line">        if (hash[sArr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r &gt; pLength - 1) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;a&apos;]++;</span><br><span class="line">            if (hash[sArr[l] - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count == pLength) &#123;</span><br><span class="line">            results.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">    if (s.length() &lt; t.length()) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] tArr = t.toCharArray();</span><br><span class="line">        </span><br><span class="line">    int[] hash = new int[256];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; tArr.length; ++i) &#123;</span><br><span class="line">        hash[tArr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int l = 0, count = tArr.length, max = s.length() + 1;</span><br><span class="line">    String result = &quot;&quot;;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]--;</span><br><span class="line">        </span><br><span class="line">        if (hash[sArr[r]] &gt;= 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (l &lt; r &amp;&amp; hash[sArr[l]] &lt; 0) &#123;</span><br><span class="line">            hash[sArr[l]]++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == 0 &amp;&amp; max &gt; r - l + 1) &#123;</span><br><span class="line">            max = r - l + 1;</span><br><span class="line">            result = s.substring(l, r + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    int[] hash = new int[256];</span><br><span class="line">    </span><br><span class="line">    int l = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]++;</span><br><span class="line">        </span><br><span class="line">        while (hash[sArr[r]] != 1) &#123;</span><br><span class="line">            hash[sArr[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] s1Arr = s1.toCharArray();</span><br><span class="line">    char[] s2Arr = s2.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s1Arr.length; ++i) &#123;</span><br><span class="line">        hash[s1Arr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int l = 0, count = 0;</span><br><span class="line">    for (int r = 0; r &lt; s2Arr.length; ++r) &#123;</span><br><span class="line">        hash[s2Arr[r] - &apos;a&apos;]--;</span><br><span class="line">        </span><br><span class="line">        if (hash[s2Arr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (r &gt;= s1Arr.length) &#123;</span><br><span class="line">            hash[s2Arr[l] - &apos;a&apos;]++;</span><br><span class="line">            </span><br><span class="line">            if (hash[s2Arr[l] - &apos;a&apos;] &gt;= 1) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == s1Arr.length) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br></pre></td></tr></table></figure><h4 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int subarraysWithKDistinct(int[] A, int K) &#123;</span><br><span class="line">    if (A == null || A.length &lt; K) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[A.length + 1];</span><br><span class="line">    </span><br><span class="line">    int l = 0, results = 0, count = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; A.length; ++r) &#123;</span><br><span class="line">        hash[A[r]]++;</span><br><span class="line">        </span><br><span class="line">        if (hash[A[r]] == 1) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (hash[A[l]] &gt; 1 || count &gt; K) &#123;</span><br><span class="line">            if (count &gt; K) &#123;</span><br><span class="line">                result = 1;</span><br><span class="line">                count--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[A[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == K) &#123;</span><br><span class="line">            results += result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    </span><br><span class="line">    int l = 0, maxCount = 0, result = 0;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r] - &apos;A&apos;]++;</span><br><span class="line">        </span><br><span class="line">        maxCount = Math.max(maxCount, hash[sArr[r] - &apos;A&apos;]);</span><br><span class="line">        </span><br><span class="line">        while (r - l + 1 - maxCount &gt; k) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;A&apos;]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(r - l + 1, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480. 滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. 滑动窗口中位数</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public double[] medianSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    if (nums == null || nums.length &lt; k ) &#123;</span><br><span class="line">        return new double[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double[] results = new double[nums.length - k + 1];</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        // add current element into queue</span><br><span class="line">        maxHeap.offer(nums[i]);</span><br><span class="line">        minHeap.offer(maxHeap.poll());</span><br><span class="line">        </span><br><span class="line">        if (minHeap.size() &gt; maxHeap.size()) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // record answer</span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            results[i - k + 1] = minHeap.size() &lt; maxHeap.size() </span><br><span class="line">                    ? maxHeap.peek() : ((long)maxHeap.peek() + minHeap.peek()) * 0.5;</span><br><span class="line"></span><br><span class="line">            if (maxHeap.contains(nums[i - k + 1])) &#123;</span><br><span class="line">                maxHeap.remove(nums[i - k + 1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minHeap.remove(nums[i - k + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://juejin.im/post/5cccc9d1f265da0384129e5f" target="_blank" rel="noopener">https://juejin.im/post/5cccc9d1f265da0384129e5f</a><br>[参考链接]<a href="https://leetcode-cn.com/problems/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;滑动窗口模板&quot;&gt;&lt;a href=&quot;#滑动窗口模板&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口模板&quot;&gt;&lt;/a&gt;滑动窗口模板&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="http://yoursite.com/2019/12/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/19/滑动窗口问题/</id>
    <published>2019-12-19T11:57:10.000Z</published>
    <updated>2020-01-03T07:49:26.603Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239. 滑动窗口最大值"></a>LeetCode <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h4><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p></blockquote><ul><li>题目解析<br>利用一个 双端队列，在队列中存储元素在数组中的位置， 并且维持队列的严格递减，，也就说维持队首元素是 <strong>最大的</strong>，当遍历到一个新元素时，如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。</li></ul><p>Deque 继承自 Queue（队列）(详情见下方参考链接)，它的直接实现有 ArrayDeque、LinkedList 等。</p><a id="more"></a><p><img src="/2019/12/19/滑动窗口问题/aaa.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">    //测试用例里面有nums = [], k = 0，所以只好加上这个判断</span><br><span class="line">    if (nums == null || nums.length &lt; k || k == 0) return new int[0];</span><br><span class="line">    //最大值组成的数组大小为nums.length-k+1;</span><br><span class="line">    int[] res = new int[nums.length - k + 1];</span><br><span class="line">    //创建双端队列,双端队列中存储的是nums数组的下标；</span><br><span class="line">    ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        //在尾部添加元素，并保证左边元素都比尾部大</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.getLast()] &lt; nums[i]) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(i);</span><br><span class="line">        //在头部移除元素</span><br><span class="line">        if (deque.getFirst() == i - k) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果</span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            res[i - k + 1] = nums[deque.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><blockquote><p>题目描述 ：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>题目解析:输入只有一个字符串，要求子串里面不能够有重复的元素，这里 count 都不需要定义，直接判断哈希散列里面的元素是不是在窗口内即可，是的话得移动左指针去重。</p><p>具体操作如下：</p><p>建立一个 128 位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。<br>1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；<br>2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；<br>3）重复（1）（2），直到左边索引无法再移动；<br>4）维护一个结果 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法一:</span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    int[] hash = new int[128];</span><br><span class="line"></span><br><span class="line">    int l = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]++;</span><br><span class="line"></span><br><span class="line">        while (hash[sArr[r]] != 1) &#123;</span><br><span class="line">            hash[sArr[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Math.max(result, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int n = s.length(), ans = 0;</span><br><span class="line">        //创建map窗口,i为左区间，j为右区间，右边界移动</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int j = 0, i = 0; j &lt; n; j++) &#123;</span><br><span class="line">            // 如果窗口中包含当前字符，</span><br><span class="line">            if (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                //左边界移动到 相同字符的下一个位置和i当前位置中更靠右的位置，这样是为了防止i向左移动</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            //比对当前无重复字段长度和储存的长度，选最大值并替换</span><br><span class="line">            //j-i+1是因为此时i,j索引仍处于不重复的位置，j还没有向后移动，取的[i,j]长度</span><br><span class="line">            ans = Math.max(ans, j - i + 1);</span><br><span class="line">            // 将当前字符为key，下一个索引为value放入map中</span><br><span class="line">            // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了</span><br><span class="line">            map.put(s.charAt(j), j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode 438. 找到字符串中所有字母异位词"></a>LeetCode <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>题目描述:给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。<br>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100 。</p><p>如果限定你在 O (n) 时间复杂度内实现呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line"></span><br><span class="line">字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line">不考虑答案输出的顺序。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">    // 输入参数有效性判断</span><br><span class="line">    if (s.length() &lt; p.length()) &#123;</span><br><span class="line">        return new ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 申请一个散列，用于记录窗口中具体元素的个数情况</span><br><span class="line">    // 这里用数组的形式呈现，也可以考虑其他数据结构</span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] pArr = p.toCharArray();</span><br><span class="line"></span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; pArr.length; ++i) &#123;</span><br><span class="line">        hash[pArr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // l 表示左指针</span><br><span class="line">    // count 记录当前的条件，具体根据题目要求来定义</span><br><span class="line">    // result 用来存放结果</span><br><span class="line">    List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    int l = 0, count = 0, pLength = p.length();</span><br><span class="line"></span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        // 更新新元素在散列中的数量</span><br><span class="line">        hash[sArr[r] - &apos;a&apos;]--;</span><br><span class="line"></span><br><span class="line">        // 根据窗口的变更结果来改变条件值</span><br><span class="line">        if (hash[sArr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前条件不满足，移动左指针直至条件满足为止</span><br><span class="line">        if (r &gt; pLength - 1) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;a&apos;]++;</span><br><span class="line"></span><br><span class="line">            if (hash[sArr[l] - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新结果</span><br><span class="line">        if (count == pLength) &#123;</span><br><span class="line">            results.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://blog.jrwang.me/2016/java-collections-deque-arraydeque/" target="_blank" rel="noopener">https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</a><br>[参考链接]<a href="https://www.cnblogs.com/lxyit/p/9080590.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxyit/p/9080590.html</a><br>[参考链接]<a href="https://cloud.tencent.com/developer/article/1448920" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1448920</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-239-滑动窗口最大值&quot;&gt;&lt;a href=&quot;#LeetCode-239-滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 239. 滑动窗口最大值&quot;&gt;&lt;/a&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/sliding-window-maximum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;239. 滑动窗口最大值&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;br&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目解析&lt;br&gt;利用一个 双端队列，在队列中存储元素在数组中的位置， 并且维持队列的严格递减，，也就说维持队首元素是 &lt;strong&gt;最大的&lt;/strong&gt;，当遍历到一个新元素时，如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deque 继承自 Queue（队列）(详情见下方参考链接)，它的直接实现有 ArrayDeque、LinkedList 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>刷LeetCode常用函数</title>
    <link href="http://yoursite.com/2019/12/18/%E5%88%B7LeetCode%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/18/刷LeetCode常用函数/</id>
    <published>2019-12-18T11:57:10.000Z</published>
    <updated>2020-01-16T07:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">float[] height = new float[20]；</span><br><span class="line">java.util.Arrays.fill( height, 175.5f );</span><br><span class="line">表示用 float 型的值 175.5f 初始化数组 height [20] ，即用此值填充所有数组项。</span><br><span class="line"></span><br><span class="line">Arrays.fill（）函数</span><br><span class="line"></span><br><span class="line">用法 1：接受 2 个参数</span><br><span class="line">Arrays.fill（ a1, value ）;</span><br><span class="line">注：a1 是一个数组变量，value 是一个 a1 中元素数据类型的值，作用：填充 a1 数组中的每个元素都是 value</span><br><span class="line">例如：</span><br><span class="line">boolean[] a1 = new boolean[5];</span><br><span class="line">Arrays.fill( a1,true );</span><br><span class="line">结果 a1 [] = &#123;true,true,true,true,true&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用法 2：接受 4 个参数</span><br><span class="line">例如：</span><br><span class="line">String[] a9 = new String[6];</span><br><span class="line">Arrays.fill(a9, &quot;Hello&quot;);</span><br><span class="line">Arrays.fill(a9, 3, 5,&quot;World&quot;);</span><br><span class="line">结果是 a9 [] = &#123;Hello,Hello,Hello,World,World,Hello&#125;;</span><br><span class="line">第一个参数指操作的数组，第二个和第三个指在该数组的某个区域插入第四个参数，第二个参数指起始元素下标（包含该下标），第三个参数指结束下标（不包含该下标），注意：java 的数组下标从 0 开始</span><br></pre></td></tr></table></figure><ul><li>Math求最大最小值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max( , ) : 计算最大值</span><br><span class="line">Math.min( , ) : 计算最小值</span><br></pre></td></tr></table></figure></li></ul><p>求两个集合交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;();</span><br><span class="line">// for (Integer n : nums1) set1.add(n);</span><br><span class="line">// HashSet&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;();</span><br><span class="line">// for (Integer n : nums2) set2.add(n);</span><br><span class="line">// set1.retainAll(set2);</span><br></pre></td></tr></table></figure><p>当 Map 集合中有这个 key 时，就使用这个 key 值，如果没有就使用默认值 defaultValue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getOrDefault(Object key, V defaultValue)</span><br></pre></td></tr></table></figure><p>判断整数是不是回文数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String reversedStr = (new StringBuilder(x + &quot;&quot;)).reverse().toString();</span><br><span class="line">return (x + &quot;&quot;).equals(reversedStr);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java常用方法" scheme="http://yoursite.com/tags/Java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树叶子节点数</title>
    <link href="http://yoursite.com/2019/12/17/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/17/完全二叉树叶子节点数/</id>
    <published>2019-12-17T11:57:10.000Z</published>
    <updated>2019-12-18T01:31:24.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例题：假如⼀个完全⼆叉树中有 743 个节点，则该⼆叉树中的叶子节点个数为？</span><br><span class="line"></span><br><span class="line">假设完全二叉树中，度为 0 的叶子结点为 n0，度为 1 的结点为 n1，度为 2 的结点为 n2，总结点数为 n。</span><br><span class="line">则 n=n0+n1+n2;</span><br><span class="line">并且有 n-1=2n2+n1;</span><br><span class="line">如果总结点数为奇数，则 n1 为 0，为偶数，则 n1 为 1；</span><br><span class="line">带入式子求得 n0：371</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之接雨水</title>
    <link href="http://yoursite.com/2019/12/16/LeetCode%E4%B9%8B%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://yoursite.com/2019/12/16/LeetCode之接雨水/</id>
    <published>2019-12-16T11:57:10.000Z</published>
    <updated>2019-12-16T07:02:20.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><a id="more"></a><p><img src="/2019/12/16/LeetCode之接雨水/aaa.jpg" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>黑色的看成墙，蓝色的看成水，宽度一样，给定一个数组，每个数代表从左到右墙的高度，求出能装多少单位的水。也就是图中蓝色正方形的个数。</p><h3 id="解法一：按列求"><a href="#解法一：按列求" class="headerlink" title="解法一：按列求"></a>解法一：按列求</h3><p>求每一列的水，我们只需要关注当前列，以及左边最高的墙，右边最高的墙就够了。装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以分为三种情况。</p><ul><li>较矮的墙的高度大于当前列的墙的高度</li></ul><p><img src="/2019/12/16/LeetCode之接雨水/bbb.jpg" alt><br>把正在求的列左边最高的墙和右边最高的墙确定后，然后为了方便理解，我们把无关的墙去掉。<br><img src="/2019/12/16/LeetCode之接雨水/ccc.jpg" alt></p><p>这样就很清楚了，现在想象一下，往两边最高的墙之间注水。正在求的列会有多少水？很明显，较矮的一边，也就是左边的墙的高度，减去当前列的高度就可以了，也就是 2 - 1 = 1，可以存一个单位的水。</p><ul><li>较矮的墙的高度小于当前列的墙的高度<br><img src="/2019/12/16/LeetCode之接雨水/ddd.jpg" alt></li></ul><p>同样的，我们把其他无关的列去掉。<br><img src="/2019/12/16/LeetCode之接雨水/eee.jpg" alt></p><p>想象下，往两边最高的墙之间注水。正在求的列会有多少水？</p><p>正在求的列不会有水，因为它大于了两边较矮的墙。</p><ul><li>较矮的墙的高度等于当前列的墙的高度。</li></ul><p>和上一种情况是一样的，不会有水。<br><img src="/2019/12/16/LeetCode之接雨水/fff.jpg" alt><br>明白了这三种情况，程序就很好写了，遍历每一列，然后分别求出这一列两边最高的墙。找出较矮的一端，和当前列的高度比较，结果就是上边的三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int max_left = 0;</span><br><span class="line">        //找出左边最高</span><br><span class="line">        for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (height[j] &gt; max_left) &#123;</span><br><span class="line">                max_left = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max_right = 0;</span><br><span class="line">        //找出右边最高</span><br><span class="line">        for (int j = i + 1; j &lt; height.length; j++) &#123;</span><br><span class="line">            if (height[j] &gt; max_right) &#123;</span><br><span class="line">                max_right = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出两端较小的</span><br><span class="line">        int min = Math.min(max_left, max_right);</span><br><span class="line">        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： [公式]，遍历每一列需要 [公式] ，找出左边最高和右边最高的墙加起来刚好又是一个 [公式] ，所以是 [公式] 。</p><p>​空间复杂度：O (1）。</p><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的）</p><p>对于 max_left 我们其实可以这样求。</p><p>max_left [i] = Max(max_left [i-1],height[i-1])。i前边的墙(即i-1)的左边的最高高度和它前边的墙(即i-1)的高度选一个较大的，就是当前列左边最高的墙了。对于 max_right 我们可以这样求。max_right[i] = Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int[] max_left = new int[height.length];</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int min = Math.min(max_left[i], max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。</p><p>空间复杂度：O (n)，用来保存每一列左边最高的墙和右边最高的墙。</p><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>动态规划中，我们常常可以对空间复杂度进行进一步的优化。</p><p>例如这道题中，可以看到，max_left [ i ] 和 max_right [ i ] 数组中的元素我们其实只用一次，然后就再也不会用到了。所以我们可以不用数组，只用一个元素就行了。我们先改造下 max_left。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left = Math.max(max_left, height[i - 1]);</span><br><span class="line">        int min = Math.min(max_left, max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们成功将 max_left 数组去掉了。但是会发现我们不能同时把 max_right 的数组去掉，因为最后的 for 循环是从左到右遍历的，而 max_right 的更新是从右向左的。</p><p>所以这里要用到两个指针，left 和 right，从两个方向去遍历。</p><p>那么什么时候从左到右，什么时候从右到左呢？根据下边的代码的更新规则，我们可以知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_left = Math.max(max_left, height[i - 1]);</span><br></pre></td></tr></table></figure><p>height [ left - 1] 是可能成为 max_left 的变量，同理，height [ right + 1 ] 是可能成为 right_max 的变量。</p><p>只要保证 height [ left - 1 ] &lt; height [ right + 1 ] ，那么 max_left 就一定小于 max_right。</p><p>因为 max_left 是由 height [ left - 1] 更新过来的，而 height [ left - 1 ] 是小于 height [ right + 1] 的，而 height [ right + 1 ] 会更新 max_right，所以间接的得出 max_left 一定小于 max_right。</p><p>反之，我们就从右到左更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int max_right = 0;</span><br><span class="line">    int left = 1;</span><br><span class="line">    int right = height.length - 2; // 加右指针进去</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        //从左到右更</span><br><span class="line">        if (height[left - 1] &lt; height[right + 1]) &#123;</span><br><span class="line">            max_left = Math.max(max_left, height[left - 1]);</span><br><span class="line">            int min = max_left;</span><br><span class="line">            if (min &gt; height[left]) &#123;</span><br><span class="line">                sum = sum + (min - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        //从右到左更</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            max_right = Math.max(max_right, height[right + 1]);</span><br><span class="line">            int min = max_right;</span><br><span class="line">            if (min &gt; height[right]) &#123;</span><br><span class="line">                sum = sum + (min - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。<br>空间复杂度：O (1)。</p><p>​### 解法四：栈</p><p><img src="/2019/12/16/LeetCode之接雨水/ggg.jpg" alt></p><p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p><p>我们用栈保存每堵墙。</p><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>总体的原则就是，<br>1.当前高度小于等于栈顶高度，入栈，指针后移。<br>2.当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p><p>我们看具体的例子。</p><ul><li><p>首先将 height [ 0 ] 入栈。然后 current 指向的高度大于栈顶高度，所以把栈顶 height [ 0 ] 出栈，然后栈空了，再把 height [ 1 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/hhh.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶高度，height [ 2 ] 入栈，current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/jjj.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，栈顶 height [ 2 ] 出栈。计算 height [ 3 ] 和新的栈顶之间的水。计算完之后继续判断 current 和新的栈顶的关系。<br><img src="/2019/12/16/LeetCode之接雨水/kkk.jpg" alt></p></li><li><p>current 指向的高度大于栈顶高度，栈顶 height [ 1 ] 出栈，栈空。所以把 height [ 3 ] 入栈。currtent 后移。<br><img src="/2019/12/16/LeetCode之接雨水/lll.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 3 ] 的高度，height [ 4 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/zzz.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 4 ] 的高度，height [ 5 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/xxx.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶 height [ 5 ] 的高度，将栈顶 height [ 5 ] 出栈，然后计算 current 指向的墙和新栈顶 height [ 4 ] 之间的水。计算完之后继续判断 current 的指向和新栈顶的关系。此时 height [ 6 ] 不大于栈顶 height [ 4 ] ，所以将 height [ 6 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/vvv.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，将栈顶 height [ 6 ] 出栈。计算和新的栈顶 height [ 4 ] 组成两个边界中的水。然后判断 current 和新的栈顶 height [ 4 ] 的关系，依旧是大于，所以把 height [ 4 ] 出栈。计算 current 和 新的栈顶 height [ 3 ] 之间的水。然后判断 current 和新的栈顶 height [ 3 ] 的关系，依旧是大于，所以把 height [ 3 ] 出栈，栈空。将 current 指向的 height [ 7 ] 入栈。current 后移。<br>其实不停的出栈，可以看做是在找与 7 匹配的墙，也就是 3 。</p></li></ul><p><img src="/2019/12/16/LeetCode之接雨水/nnn.jpg" alt><br>而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离。可以看下代码继续理解下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int trap6(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    int current = 0;</span><br><span class="line">    while (current &lt; height.length) &#123;</span><br><span class="line">        //如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span><br><span class="line">        while (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            int h = height[stack.peek()]; //取出要出栈的元素</span><br><span class="line">            stack.pop(); //出栈</span><br><span class="line">            if (stack.empty()) &#123; // 栈空就出去</span><br><span class="line">                break; </span><br><span class="line">            &#125;</span><br><span class="line">            int distance = current - stack.peek() - 1; //两堵墙之前的距离。</span><br><span class="line">            int min = Math.min(height[stack.peek()], height[current]);</span><br><span class="line">            sum = sum + distance * (min - h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current); //当前指向的墙入栈</span><br><span class="line">        current++; //指针后移</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：虽然 while 循环里套了一个 while 循环，但是考虑到每个元素最多访问两次，入栈一次和出栈一次，所以时间复杂度是 [n] 。</p><p>空间复杂度： [n] 。栈的空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈、双指针、动态规划" scheme="http://yoursite.com/categories/%E6%A0%88%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2019/12/15/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/12/15/三次握手和四次挥手/</id>
    <published>2019-12-15T11:57:10.000Z</published>
    <updated>2019-12-26T08:43:14.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。</p><a id="more"></a><h3 id="TCP-服务模型"><a href="#TCP-服务模型" class="headerlink" title="TCP 服务模型"></a>TCP 服务模型</h3><p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p><p>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</p><p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而 IP 不提供重复消除或者保证次序正确的功能。另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>客户端和服务端通信前要进行连接，“3 次握手” 的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的 “响应” 是由于第一次的 “请求” 触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表面上看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的 “指令” 是上层应用层给出的，我只是一个 “搬运工”，我无法了解 “上层的意志”。</p><ul><li>TCP 的三次握手改成两次握手可以吗？</li></ul><p>不可以，一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><p>在谢希仁著《计算机网络》第四版中讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲 “三次握手” 的目的是为了解决 “网络中存在延迟的重复分组” 的问题。这两种不用的表述其实阐明的是同一个问题。<br>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”。主要目的防止 server 端一直等待，浪费资源。</p><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53374516</a><br>[参考链接]<a href="https://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="noopener">https://blog.csdn.net/xifeijian/article/details/12777187</a><br>[参考链接]<a href="https://ioscaff.com/articles/252" target="_blank" rel="noopener">https://ioscaff.com/articles/252</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h3&gt;&lt;p&gt;TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。&lt;/p&gt;
&lt;p&gt;TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。&lt;/p&gt;
&lt;p&gt;TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tcp协议" scheme="http://yoursite.com/categories/tcp%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
</feed>
