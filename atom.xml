<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-25T01:58:14.007Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二零一九年终总结</title>
    <link href="http://yoursite.com/2019/12/31/%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B9%9D%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/31/二零一九年终总结/</id>
    <published>2019-12-31T11:57:10.000Z</published>
    <updated>2019-12-25T01:58:14.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><blockquote><p>2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；<br>这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；<br>年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。</p></blockquote><a id="more"></a><p>这一年下来买了30多个专栏，想想自己还是很可怕的，因为从头看完的估计都不到一半；但是也不是完全没有收获，专栏中有的话是真的很有共鸣的，比如：越早的掌握底层知识，才能越早的享受知识的红利；所以今年一年主要学习的专栏还是都很基础的，比如数据结构，计算机组成原理，计算机网络；操作系统专栏还没看完(留到2020了，要学的专栏一直往后推，这个不是一个好习惯)。虽然要学的还有很多，但是这一年我自己感觉是进步最多的一年。虽然焦虑依然存在，但是消除焦虑的进步速度也在加快。虽然这一年也有一点收获，但是从10月份开始工作的很不舒服，甚至可以说的上是压抑；人在一种压抑中学习或者成长并不快；产生了想走的心；</p><ul><li>极客时间<br><img src="/2019/12/31/二零一九年终总结/ddd.png" alt><br><img src="/2019/12/31/二零一九年终总结/eee.jpg" alt></li><li>LeetCode<br><img src="/2019/12/31/二零一九年终总结/fff.png" alt></li><li>GitHub<br><img src="/2019/12/31/二零一九年终总结/ggg.png" alt><br>忽略了很重要的一点是今年自己搭建了博客，开始陆陆续续的写一些技术博客，虽然质量不是很高，但是贵在开始有写博客的意识了。有了持续的输出，才能有持续的进步；</li></ul><p>今年发现体重问题越来越严重了，体重一直在160上下浮动，最明显后果是买衣服不好买了，体重上来之后信心明显受到了打击(本来就丑，现在还变胖了)，三姐的话变成了真的，工作之后真的会变胖；今年意识到变胖之后，还跑了几天步，结果没坚持下来（我这人果然没有什么耐心）<br><img src="/2019/12/31/二零一九年终总结/aaa.webp" alt></p><p>感情经历依然<br><img src="/2019/12/31/二零一九年终总结/bbb.jpg" alt><br><img src="/2019/12/31/二零一九年终总结/ccc.jpg" alt></p><p>今年玩游戏不是很多了，减少到去年的一半不到，明年估计连今年的一半也不到，游戏渐渐玩的不多了，这是个好现象；</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>我就不去立什么flag，因为我知道我就是立flag也实现不了，还让自己有愧疚感（我倒是很会替自己着想啊）。虽然嘴上说不去立flag，但是心里还是有想法的。我就把想法说一下吧，能不能实现是另外一回事；想到什么就说什么了，减肥还是很有必要的，先定个小目标，先减它一斤试试，今年希望减肥成功；<br>还有就是把计算机基础课程再巩固一下，争取能看到相关知识点的时候可以联想到；LeetCode上还是要刷题的，在精不在多，在持之以恒，不再于某一天的突发奇想；今年要好好用用GitHub；最重要的一点是不要为了工作再压抑了；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2019年马上就要过去了，回顾这一年感觉时间过的是真快啊；这一年有收获也有遗憾，总结出来就是忙忙碌碌，碌碌无为；&lt;br&gt;这一年不知为何突然很怀念大学(虽然大学没怎么学习)，这感觉很莫名其妙，也许是大学学的不怎么好，现在想好好学吧；&lt;br&gt;年初的时候不知为何想起来重学数据结构和算法了，于是买了好几本数据结构和算法的书，但是一年下来看完的没几本，算是一个遗憾吧；但是学习了关于数据结构和算法的几个专栏，在十月份还报了一个算法班，这也算是一个收获吧；学下来感觉数据结构也没有那么难，古人总结的很到位，但手熟尔，要想熟悉必须要进行可以练习，关于刻意练习今年还是有点收获的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://yoursite.com/2019/12/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/27/背包问题/</id>
    <published>2019-12-27T11:57:10.000Z</published>
    <updated>2019-12-27T09:13:13.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变形二分查找问题二</title>
    <link href="http://yoursite.com/2019/12/25/%E5%8F%98%E5%BD%A2%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/12/25/变形二分查找问题二/</id>
    <published>2019-12-25T11:57:10.000Z</published>
    <updated>2019-12-25T10:58:52.419Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>变形二分查找问题</title>
    <link href="http://yoursite.com/2019/12/24/%E5%8F%98%E5%BD%A2%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/24/变形二分查找问题/</id>
    <published>2019-12-24T11:57:10.000Z</published>
    <updated>2020-01-03T07:46:05.318Z</updated>
    
    <content type="html"><![CDATA[<ul><li>二分查找依赖数组结构<br>二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。</li><li>二分查找针对的是有序数据<br>二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O (nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。<br>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。<br>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用</li><li>数据量太小不适合二分查找<br>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。</li><li>数据量太大不适合二分查找<br>二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如 1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。</li></ul><a id="more"></a><ul><li>Binary Search 模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int binarySearch(int[] arr, int key) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = arr.length - 1;</span><br><span class="line">int mid = 0;</span><br><span class="line"></span><br><span class="line">if (key &lt; arr[low] || key &gt; arr[high] || low &gt; high)</span><br><span class="line">return -1;</span><br><span class="line">while (low &lt;= high)&#123;</span><br><span class="line">mid = (low + high) / 2;</span><br><span class="line">if (arr[mid] &gt; key)</span><br><span class="line">high = mid - 1;</span><br><span class="line">else if (arr[mid] &lt; key)</span><br><span class="line">low = mid + 1;</span><br><span class="line">else</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。</p><p>不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><p><strong><em>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky…</em></strong></p><p>这句话可以这样理解：<strong><em>思路很简单，细节是魔鬼。</em></strong></p><p>探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景就是本题，后两个场景可以解决这道算法题 在排序数组中查找元素的第一个和最后一个位置。</p><p>要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="二分查找框架："><a href="#二分查找框架：" class="headerlink" title="二分查找框架："></a>二分查找框架：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中 … 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p><strong><em>另外声明一下，计算 mid 时需要技巧防止溢出，即 mid = left + (right - left) / 2。本文暂时忽略这个问题。</em></strong></p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 −1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？<br>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。<br>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。<br>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。<br>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid] == target)</span><br><span class="line">    return mid;</span><br></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 −1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。<br>while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 −1 即可。<br>while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 −1 就是错误的。<br>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">return nums[left] == target ? left : -1;</span><br></pre></td></tr></table></figure><p>2.为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？<br>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。<br>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？<br>当然是 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。<br>3.此算法有什么缺陷？<br>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。<br>比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。<br>这样的需求很常见。你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) </span><br><span class="line">        return -1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length; // 注意</span><br><span class="line">    </span><br><span class="line">    while (left &lt; right) &#123; // 注意</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; // 注意</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么 while(left &lt; right) 而不是 &lt;= ?<br>答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right)左闭右开。<br>while(left &lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。<br>2.为什么没有返回 −1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：<br><img src="/2019/12/24/变形二分查找问题/aaa.png" alt><br>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。<br>比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。<br>再比如说 nums 不变，target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。<br>综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">// target 比所有数都大</span><br><span class="line">if (left == nums.length) return -1;</span><br><span class="line">// 类似之前算法的处理方式</span><br><span class="line">return nums[left] == target ? left : -1;</span><br></pre></td></tr></table></figure><p>3.为什么 left = mid + 1，right = mid？和之前的算法不一样？<br>答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。<br>4.为什么该算法能够搜索左侧边界？<br>答：关键在于对于 nums[mid] == target 这种情况的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。<br>5.为什么返回 left 而不是 right？<br>答：都是一样的，因为 while 终止的条件是 left == right。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) return -1;</span><br><span class="line">    int left = 0, right = nums.length;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left - 1; // 注意</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.为什么这个算法能够找到右侧边界？<br>答：类似地，关键点还是这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + 1;</span><br></pre></td></tr></table></figure><p>当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。<br>2.为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。<br>答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。<br>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + 1;</span><br><span class="line">    // 这样想: left = mid + 1 =&gt; mid = left - 1</span><br></pre></td></tr></table></figure><p><img src="/2019/12/24/变形二分查找问题/bbb.png" alt><br>因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。<br>至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。<br>3.为什么没有返回 −1 的操作？如果 nums 中不存在 target 这个值，怎么办？<br>答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 −1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">if (left == 0) return -1;</span><br><span class="line">return nums[left-1] == target ? (left-1) : -1;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一个，最基本的二分查找算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 while (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+1 和 right = mid-1</span><br><span class="line">​</span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure><p>第二个，寻找左侧边界的二分查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">​</span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure><p>第三个，寻找右侧边界的二分查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">​</span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line">​</span><br><span class="line">又因为收紧左侧边界时必须 left = mid + 1</span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure><p>1.分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p>2.注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>3.如需要搜索左右边界，只要在 nums [mid] == target 时做修改即可。搜索右侧时需要减一。<br>[参考链接]<a href="https://juejin.im/post/5d510f76f265da039a287a30" target="_blank" rel="noopener">https://juejin.im/post/5d510f76f265da039a287a30</a><br>[参考链接]<a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;二分查找依赖数组结构&lt;br&gt;二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。&lt;/li&gt;
&lt;li&gt;二分查找针对的是有序数据&lt;br&gt;二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O (nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。&lt;br&gt;但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。&lt;br&gt;所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用&lt;/li&gt;
&lt;li&gt;数据量太小不适合二分查找&lt;br&gt;如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。&lt;/li&gt;
&lt;li&gt;数据量太大不适合二分查找&lt;br&gt;二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如 1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="二分查找" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>双指针问题</title>
    <link href="http://yoursite.com/2019/12/22/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/22/双指针问题/</id>
    <published>2019-12-22T11:57:10.000Z</published>
    <updated>2020-01-02T06:25:16.104Z</updated>
    
    <content type="html"><![CDATA[<p>双指针一般可以分为两类，一类是快慢指针问题，一类是左右指针问题；</p><a id="more"></a><h3 id="一、快慢指针的常见算法"><a href="#一、快慢指针的常见算法" class="headerlink" title="一、快慢指针的常见算法"></a>一、快慢指针的常见算法</h3><p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。</p><h4 id="1-判定链表中是否含有环"><a href="#1-判定链表中是否含有环" class="headerlink" title="1.判定链表中是否含有环"></a>1.判定链表中是否含有环</h4><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。<br>如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    while (head != null)</span><br><span class="line">        head = head.next;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。</p><p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean hasCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">​</span><br><span class="line">        if (fast == slow) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-已知链表中含有环，返回这个环的起始位置"><a href="#2-已知链表中含有环，返回这个环的起始位置" class="headerlink" title="2.已知链表中含有环，返回这个环的起始位置"></a>2.已知链表中含有环，返回这个环的起始位置</h4><p><img src="/2019/12/22/双指针问题/aaa.png" alt><br>这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (fast == slow) break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 上面的代码类似 hasCycle 函数</span><br><span class="line">    slow = head;</span><br><span class="line">    while (slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p><p>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。<br><img src="/2019/12/22/双指针问题/bbb.png" alt></p><p>设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。<br><img src="/2019/12/22/双指针问题/ccc.png" alt></p><p>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。</p><h4 id="3-寻找链表的中点"><a href="#3-寻找链表的中点" class="headerlink" title="3.寻找链表的中点"></a>3.寻找链表的中点</h4><p>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line">// slow 就在中间位置</span><br><span class="line">return slow;</span><br></pre></td></tr></table></figure><p>当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：<br><img src="/2019/12/22/双指针问题/ddd.png" alt></p><p>寻找链表中点的一个重要作用是对链表进行归并排序。</p><p>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p><p>但是现在你学会了找到链表的中点，就能实现链表的二分了。</p><h4 id="4-寻找链表的倒数第-k-个元素"><a href="#4-寻找链表的倒数第-k-个元素" class="headerlink" title="4.寻找链表的倒数第 k 个元素"></a>4.寻找链表的倒数第 k 个元素</h4><p>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode slow, fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line">while (k-- &gt; 0) </span><br><span class="line">    fast = fast.next;</span><br><span class="line">​</span><br><span class="line">while (fast != null) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br></pre></td></tr></table></figure><h3 id="二、左右指针的常用算法"><a href="#二、左右指针的常用算法" class="headerlink" title="二、左右指针的常用算法"></a>二、左右指针的常用算法</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。</p><h4 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h4><p>前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1;</span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; </span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2.两数之和"></a>2.两数之和</h4><p>直接看一道 LeetCode 题目吧：</p><p><img src="/2019/12/22/双指针问题/fff.png" alt><br>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int sum = nums[left] + nums[right];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            // 题目要求的索引是从 1 开始的</span><br><span class="line">            return new int[]&#123;left + 1, right + 1&#125;;</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            left++; // 让 sum 大一点</span><br><span class="line">        &#125; else if (sum &gt; target) &#123;</span><br><span class="line">            right--; // 让 sum 小一点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new int[]&#123;-1, -1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-反转数组"><a href="#3-反转数组" class="headerlink" title="3.反转数组"></a>3.反转数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void reverse(int[] nums) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        // swap(nums[left], nums[right])</span><br><span class="line">        int temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++; right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-滑动窗口算法"><a href="#4-滑动窗口算法" class="headerlink" title="4.滑动窗口算法"></a>4.滑动窗口算法</h4><p>具体内容见滑动窗口问题这篇；</p><p>[参考链接]<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;双指针一般可以分为两类，一类是快慢指针问题，一类是左右指针问题；&lt;/p&gt;
    
    </summary>
    
    
      <category term="双指针技巧" scheme="http://yoursite.com/categories/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题二</title>
    <link href="http://yoursite.com/2019/12/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/12/20/滑动窗口问题二/</id>
    <published>2019-12-20T11:57:10.000Z</published>
    <updated>2020-01-06T10:01:47.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int slidingWindowTemplate(String[] a, ...) &#123;</span><br><span class="line">    // 输入参数有效性判断</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 申请一个散列，用于记录窗口中具体元素的个数情况</span><br><span class="line">    // 这里用数组的形式呈现，也可以考虑其他数据结构</span><br><span class="line">    int[] hash = new int[...];</span><br><span class="line">    </span><br><span class="line">    // 预处理(可省), 一般情况是改变 hash</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // l 表示左指针</span><br><span class="line">    // count 记录当前的条件，具体根据题目要求来定义</span><br><span class="line">    // result 用来存放结果</span><br><span class="line">    int l = 0, count = ..., result = ...;</span><br><span class="line">    for (int r = 0; r &lt; A.length; ++r) &#123;</span><br><span class="line">        // 更新新元素在散列中的数量</span><br><span class="line">        hash[A[r]]--;</span><br><span class="line">        </span><br><span class="line">        // 根据窗口的变更结果来改变条件值</span><br><span class="line">        if (hash[A[r]] == ...) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果当前条件不满足，移动左指针直至条件满足为止</span><br><span class="line">        while (count &gt; K || ...) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (...) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[A[l]]++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更新结果</span><br><span class="line">        results = ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line"></span><br><span class="line">    //如果待匹配的子串比原始串长，直接返回空集合；</span><br><span class="line">    if (s.length() &lt; p.length()) &#123;</span><br><span class="line">        return new ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    //转换为字符数组</span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] pArr = p.toCharArray();</span><br><span class="line"></span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    //统计p字符串中每个字符出现的次数</span><br><span class="line">    for (int i = 0; i &lt; pArr.length; ++i) &#123;</span><br><span class="line">        hash[pArr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    int l = 0, count = 0, pLength = p.length();</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r] - &apos;a&apos;]--;</span><br><span class="line">        if (hash[sArr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r &gt; pLength - 1) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;a&apos;]++;</span><br><span class="line">            if (hash[sArr[l] - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count == pLength) &#123;</span><br><span class="line">            results.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">    if (s.length() &lt; t.length()) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] tArr = t.toCharArray();</span><br><span class="line">        </span><br><span class="line">    int[] hash = new int[256];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; tArr.length; ++i) &#123;</span><br><span class="line">        hash[tArr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int l = 0, count = tArr.length, max = s.length() + 1;</span><br><span class="line">    String result = &quot;&quot;;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]--;</span><br><span class="line">        </span><br><span class="line">        if (hash[sArr[r]] &gt;= 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (l &lt; r &amp;&amp; hash[sArr[l]] &lt; 0) &#123;</span><br><span class="line">            hash[sArr[l]]++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == 0 &amp;&amp; max &gt; r - l + 1) &#123;</span><br><span class="line">            max = r - l + 1;</span><br><span class="line">            result = s.substring(l, r + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    int[] hash = new int[256];</span><br><span class="line">    </span><br><span class="line">    int l = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]++;</span><br><span class="line">        </span><br><span class="line">        while (hash[sArr[r]] != 1) &#123;</span><br><span class="line">            hash[sArr[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(result, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] s1Arr = s1.toCharArray();</span><br><span class="line">    char[] s2Arr = s2.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s1Arr.length; ++i) &#123;</span><br><span class="line">        hash[s1Arr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int l = 0, count = 0;</span><br><span class="line">    for (int r = 0; r &lt; s2Arr.length; ++r) &#123;</span><br><span class="line">        hash[s2Arr[r] - &apos;a&apos;]--;</span><br><span class="line">        </span><br><span class="line">        if (hash[s2Arr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (r &gt;= s1Arr.length) &#123;</span><br><span class="line">            hash[s2Arr[l] - &apos;a&apos;]++;</span><br><span class="line">            </span><br><span class="line">            if (hash[s2Arr[l] - &apos;a&apos;] &gt;= 1) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == s1Arr.length) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return false;</span><br></pre></td></tr></table></figure><h4 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int subarraysWithKDistinct(int[] A, int K) &#123;</span><br><span class="line">    if (A == null || A.length &lt; K) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[A.length + 1];</span><br><span class="line">    </span><br><span class="line">    int l = 0, results = 0, count = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; A.length; ++r) &#123;</span><br><span class="line">        hash[A[r]]++;</span><br><span class="line">        </span><br><span class="line">        if (hash[A[r]] == 1) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (hash[A[l]] &gt; 1 || count &gt; K) &#123;</span><br><span class="line">            if (count &gt; K) &#123;</span><br><span class="line">                result = 1;</span><br><span class="line">                count--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[A[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (count == K) &#123;</span><br><span class="line">            results += result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    </span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line">    </span><br><span class="line">    int l = 0, maxCount = 0, result = 0;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r] - &apos;A&apos;]++;</span><br><span class="line">        </span><br><span class="line">        maxCount = Math.max(maxCount, hash[sArr[r] - &apos;A&apos;]);</span><br><span class="line">        </span><br><span class="line">        while (r - l + 1 - maxCount &gt; k) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;A&apos;]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = Math.max(r - l + 1, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="480-滑动窗口中位数"><a href="#480-滑动窗口中位数" class="headerlink" title="480. 滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. 滑动窗口中位数</a></h4><p><strong><em>题解</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public double[] medianSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    if (nums == null || nums.length &lt; k ) &#123;</span><br><span class="line">        return new double[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double[] results = new double[nums.length - k + 1];</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        // add current element into queue</span><br><span class="line">        maxHeap.offer(nums[i]);</span><br><span class="line">        minHeap.offer(maxHeap.poll());</span><br><span class="line">        </span><br><span class="line">        if (minHeap.size() &gt; maxHeap.size()) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // record answer</span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            results[i - k + 1] = minHeap.size() &lt; maxHeap.size() </span><br><span class="line">                    ? maxHeap.peek() : ((long)maxHeap.peek() + minHeap.peek()) * 0.5;</span><br><span class="line"></span><br><span class="line">            if (maxHeap.contains(nums[i - k + 1])) &#123;</span><br><span class="line">                maxHeap.remove(nums[i - k + 1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minHeap.remove(nums[i - k + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://juejin.im/post/5cccc9d1f265da0384129e5f" target="_blank" rel="noopener">https://juejin.im/post/5cccc9d1f265da0384129e5f</a><br>[参考链接]<a href="https://leetcode-cn.com/problems/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;滑动窗口模板&quot;&gt;&lt;a href=&quot;#滑动窗口模板&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口模板&quot;&gt;&lt;/a&gt;滑动窗口模板&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="http://yoursite.com/2019/12/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/19/滑动窗口问题/</id>
    <published>2019-12-19T11:57:10.000Z</published>
    <updated>2020-01-03T07:49:26.603Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239. 滑动窗口最大值"></a>LeetCode <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h4><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回滑动窗口中的最大值。</p></blockquote><ul><li>题目解析<br>利用一个 双端队列，在队列中存储元素在数组中的位置， 并且维持队列的严格递减，，也就说维持队首元素是 <strong>最大的</strong>，当遍历到一个新元素时，如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。</li></ul><p>Deque 继承自 Queue（队列）(详情见下方参考链接)，它的直接实现有 ArrayDeque、LinkedList 等。</p><a id="more"></a><p><img src="/2019/12/19/滑动窗口问题/aaa.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">    //测试用例里面有nums = [], k = 0，所以只好加上这个判断</span><br><span class="line">    if (nums == null || nums.length &lt; k || k == 0) return new int[0];</span><br><span class="line">    //最大值组成的数组大小为nums.length-k+1;</span><br><span class="line">    int[] res = new int[nums.length - k + 1];</span><br><span class="line">    //创建双端队列,双端队列中存储的是nums数组的下标；</span><br><span class="line">    ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        //在尾部添加元素，并保证左边元素都比尾部大</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.getLast()] &lt; nums[i]) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(i);</span><br><span class="line">        //在头部移除元素</span><br><span class="line">        if (deque.getFirst() == i - k) &#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果</span><br><span class="line">        if (i &gt;= k - 1) &#123;</span><br><span class="line">            res[i - k + 1] = nums[deque.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><blockquote><p>题目描述 ：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>题目解析:输入只有一个字符串，要求子串里面不能够有重复的元素，这里 count 都不需要定义，直接判断哈希散列里面的元素是不是在窗口内即可，是的话得移动左指针去重。</p><p>具体操作如下：</p><p>建立一个 128 位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。<br>1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；<br>2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；<br>3）重复（1）（2），直到左边索引无法再移动；<br>4）维护一个结果 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法一:</span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    int[] hash = new int[128];</span><br><span class="line"></span><br><span class="line">    int l = 0, result = 1;</span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        hash[sArr[r]]++;</span><br><span class="line"></span><br><span class="line">        while (hash[sArr[r]] != 1) &#123;</span><br><span class="line">            hash[sArr[l]]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Math.max(result, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int n = s.length(), ans = 0;</span><br><span class="line">        //创建map窗口,i为左区间，j为右区间，右边界移动</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int j = 0, i = 0; j &lt; n; j++) &#123;</span><br><span class="line">            // 如果窗口中包含当前字符，</span><br><span class="line">            if (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                //左边界移动到 相同字符的下一个位置和i当前位置中更靠右的位置，这样是为了防止i向左移动</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            //比对当前无重复字段长度和储存的长度，选最大值并替换</span><br><span class="line">            //j-i+1是因为此时i,j索引仍处于不重复的位置，j还没有向后移动，取的[i,j]长度</span><br><span class="line">            ans = Math.max(ans, j - i + 1);</span><br><span class="line">            // 将当前字符为key，下一个索引为value放入map中</span><br><span class="line">            // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了</span><br><span class="line">            map.put(s.charAt(j), j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode 438. 找到字符串中所有字母异位词"></a>LeetCode <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>题目描述:给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。<br>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100 。</p><p>如果限定你在 O (n) 时间复杂度内实现呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line"></span><br><span class="line">字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line">不考虑答案输出的顺序。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">    // 输入参数有效性判断</span><br><span class="line">    if (s.length() &lt; p.length()) &#123;</span><br><span class="line">        return new ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 申请一个散列，用于记录窗口中具体元素的个数情况</span><br><span class="line">    // 这里用数组的形式呈现，也可以考虑其他数据结构</span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] pArr = p.toCharArray();</span><br><span class="line"></span><br><span class="line">    int[] hash = new int[26];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; pArr.length; ++i) &#123;</span><br><span class="line">        hash[pArr[i] - &apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // l 表示左指针</span><br><span class="line">    // count 记录当前的条件，具体根据题目要求来定义</span><br><span class="line">    // result 用来存放结果</span><br><span class="line">    List&lt;Integer&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">    int l = 0, count = 0, pLength = p.length();</span><br><span class="line"></span><br><span class="line">    for (int r = 0; r &lt; sArr.length; ++r) &#123;</span><br><span class="line">        // 更新新元素在散列中的数量</span><br><span class="line">        hash[sArr[r] - &apos;a&apos;]--;</span><br><span class="line"></span><br><span class="line">        // 根据窗口的变更结果来改变条件值</span><br><span class="line">        if (hash[sArr[r] - &apos;a&apos;] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前条件不满足，移动左指针直至条件满足为止</span><br><span class="line">        if (r &gt; pLength - 1) &#123;</span><br><span class="line">            hash[sArr[l] - &apos;a&apos;]++;</span><br><span class="line"></span><br><span class="line">            if (hash[sArr[l] - &apos;a&apos;] &gt; 0) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新结果</span><br><span class="line">        if (count == pLength) &#123;</span><br><span class="line">            results.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://blog.jrwang.me/2016/java-collections-deque-arraydeque/" target="_blank" rel="noopener">https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</a><br>[参考链接]<a href="https://www.cnblogs.com/lxyit/p/9080590.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxyit/p/9080590.html</a><br>[参考链接]<a href="https://cloud.tencent.com/developer/article/1448920" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1448920</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-239-滑动窗口最大值&quot;&gt;&lt;a href=&quot;#LeetCode-239-滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 239. 滑动窗口最大值&quot;&gt;&lt;/a&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/sliding-window-maximum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;239. 滑动窗口最大值&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;br&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目解析&lt;br&gt;利用一个 双端队列，在队列中存储元素在数组中的位置， 并且维持队列的严格递减，，也就说维持队首元素是 &lt;strong&gt;最大的&lt;/strong&gt;，当遍历到一个新元素时，如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deque 继承自 Queue（队列）(详情见下方参考链接)，它的直接实现有 ArrayDeque、LinkedList 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>刷LeetCode常用函数</title>
    <link href="http://yoursite.com/2019/12/18/%E5%88%B7LeetCode%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/18/刷LeetCode常用函数/</id>
    <published>2019-12-18T11:57:10.000Z</published>
    <updated>2019-12-27T06:31:54.948Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">float[] height = new float[20]；</span><br><span class="line">java.util.Arrays.fill( height, 175.5f );</span><br><span class="line">表示用 float 型的值 175.5f 初始化数组 height [20] ，即用此值填充所有数组项。</span><br><span class="line"></span><br><span class="line">Arrays.fill（）函数</span><br><span class="line"></span><br><span class="line">用法 1：接受 2 个参数</span><br><span class="line">Arrays.fill（ a1, value ）;</span><br><span class="line">注：a1 是一个数组变量，value 是一个 a1 中元素数据类型的值，作用：填充 a1 数组中的每个元素都是 value</span><br><span class="line">例如：</span><br><span class="line">boolean[] a1 = new boolean[5];</span><br><span class="line">Arrays.fill( a1,true );</span><br><span class="line">结果 a1 [] = &#123;true,true,true,true,true&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用法 2：接受 4 个参数</span><br><span class="line">例如：</span><br><span class="line">String[] a9 = new String[6];</span><br><span class="line">Arrays.fill(a9, &quot;Hello&quot;);</span><br><span class="line">Arrays.fill(a9, 3, 5,&quot;World&quot;);</span><br><span class="line">结果是 a9 [] = &#123;Hello,Hello,Hello,World,World,Hello&#125;;</span><br><span class="line">第一个参数指操作的数组，第二个和第三个指在该数组的某个区域插入第四个参数，第二个参数指起始元素下标（包含该下标），第三个参数指结束下标（不包含该下标），注意：java 的数组下标从 0 开始</span><br></pre></td></tr></table></figure><ul><li>Math求最大最小值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max( , ) : 计算最大值</span><br><span class="line">Math.min( , ) : 计算最小值</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;java.util.Arrays.fill () 方法只适合于把数组用同一个值初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="LeetCode算法" scheme="http://yoursite.com/categories/LeetCode%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java常用方法" scheme="http://yoursite.com/tags/Java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树叶子节点数</title>
    <link href="http://yoursite.com/2019/12/17/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2019/12/17/完全二叉树叶子节点数/</id>
    <published>2019-12-17T11:57:10.000Z</published>
    <updated>2019-12-18T01:31:24.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例题：假如⼀个完全⼆叉树中有 743 个节点，则该⼆叉树中的叶子节点个数为？</span><br><span class="line"></span><br><span class="line">假设完全二叉树中，度为 0 的叶子结点为 n0，度为 1 的结点为 n1，度为 2 的结点为 n2，总结点数为 n。</span><br><span class="line">则 n=n0+n1+n2;</span><br><span class="line">并且有 n-1=2n2+n1;</span><br><span class="line">如果总结点数为奇数，则 n1 为 0，为偶数，则 n1 为 1；</span><br><span class="line">带入式子求得 n0：371</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之接雨水</title>
    <link href="http://yoursite.com/2019/12/16/LeetCode%E4%B9%8B%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://yoursite.com/2019/12/16/LeetCode之接雨水/</id>
    <published>2019-12-16T11:57:10.000Z</published>
    <updated>2019-12-16T07:02:20.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><a id="more"></a><p><img src="/2019/12/16/LeetCode之接雨水/aaa.jpg" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>黑色的看成墙，蓝色的看成水，宽度一样，给定一个数组，每个数代表从左到右墙的高度，求出能装多少单位的水。也就是图中蓝色正方形的个数。</p><h3 id="解法一：按列求"><a href="#解法一：按列求" class="headerlink" title="解法一：按列求"></a>解法一：按列求</h3><p>求每一列的水，我们只需要关注当前列，以及左边最高的墙，右边最高的墙就够了。装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以分为三种情况。</p><ul><li>较矮的墙的高度大于当前列的墙的高度</li></ul><p><img src="/2019/12/16/LeetCode之接雨水/bbb.jpg" alt><br>把正在求的列左边最高的墙和右边最高的墙确定后，然后为了方便理解，我们把无关的墙去掉。<br><img src="/2019/12/16/LeetCode之接雨水/ccc.jpg" alt></p><p>这样就很清楚了，现在想象一下，往两边最高的墙之间注水。正在求的列会有多少水？很明显，较矮的一边，也就是左边的墙的高度，减去当前列的高度就可以了，也就是 2 - 1 = 1，可以存一个单位的水。</p><ul><li>较矮的墙的高度小于当前列的墙的高度<br><img src="/2019/12/16/LeetCode之接雨水/ddd.jpg" alt></li></ul><p>同样的，我们把其他无关的列去掉。<br><img src="/2019/12/16/LeetCode之接雨水/eee.jpg" alt></p><p>想象下，往两边最高的墙之间注水。正在求的列会有多少水？</p><p>正在求的列不会有水，因为它大于了两边较矮的墙。</p><ul><li>较矮的墙的高度等于当前列的墙的高度。</li></ul><p>和上一种情况是一样的，不会有水。<br><img src="/2019/12/16/LeetCode之接雨水/fff.jpg" alt><br>明白了这三种情况，程序就很好写了，遍历每一列，然后分别求出这一列两边最高的墙。找出较矮的一端，和当前列的高度比较，结果就是上边的三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int max_left = 0;</span><br><span class="line">        //找出左边最高</span><br><span class="line">        for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (height[j] &gt; max_left) &#123;</span><br><span class="line">                max_left = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max_right = 0;</span><br><span class="line">        //找出右边最高</span><br><span class="line">        for (int j = i + 1; j &lt; height.length; j++) &#123;</span><br><span class="line">            if (height[j] &gt; max_right) &#123;</span><br><span class="line">                max_right = height[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出两端较小的</span><br><span class="line">        int min = Math.min(max_left, max_right);</span><br><span class="line">        //只有较小的一段大于当前列的高度才会有水，其他情况不会有水</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度： [公式]，遍历每一列需要 [公式] ，找出左边最高和右边最高的墙加起来刚好又是一个 [公式] ，所以是 [公式] 。</p><p>​空间复杂度：O (1）。</p><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的）</p><p>对于 max_left 我们其实可以这样求。</p><p>max_left [i] = Max(max_left [i-1],height[i-1])。i前边的墙(即i-1)的左边的最高高度和它前边的墙(即i-1)的高度选一个较大的，就是当前列左边最高的墙了。对于 max_right 我们可以这样求。max_right[i] = Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int[] max_left = new int[height.length];</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left[i] = Math.max(max_left[i - 1], height[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        int min = Math.min(max_left[i], max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。</p><p>空间复杂度：O (n)，用来保存每一列左边最高的墙和右边最高的墙。</p><h3 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h3><p>动态规划中，我们常常可以对空间复杂度进行进一步的优化。</p><p>例如这道题中，可以看到，max_left [ i ] 和 max_right [ i ] 数组中的元素我们其实只用一次，然后就再也不会用到了。所以我们可以不用数组，只用一个元素就行了。我们先改造下 max_left。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int[] max_right = new int[height.length];</span><br><span class="line">    for (int i = height.length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + 1], height[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        max_left = Math.max(max_left, height[i - 1]);</span><br><span class="line">        int min = Math.min(max_left, max_right[i]);</span><br><span class="line">        if (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们成功将 max_left 数组去掉了。但是会发现我们不能同时把 max_right 的数组去掉，因为最后的 for 循环是从左到右遍历的，而 max_right 的更新是从右向左的。</p><p>所以这里要用到两个指针，left 和 right，从两个方向去遍历。</p><p>那么什么时候从左到右，什么时候从右到左呢？根据下边的代码的更新规则，我们可以知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_left = Math.max(max_left, height[i - 1]);</span><br></pre></td></tr></table></figure><p>height [ left - 1] 是可能成为 max_left 的变量，同理，height [ right + 1 ] 是可能成为 right_max 的变量。</p><p>只要保证 height [ left - 1 ] &lt; height [ right + 1 ] ，那么 max_left 就一定小于 max_right。</p><p>因为 max_left 是由 height [ left - 1] 更新过来的，而 height [ left - 1 ] 是小于 height [ right + 1] 的，而 height [ right + 1 ] 会更新 max_right，所以间接的得出 max_left 一定小于 max_right。</p><p>反之，我们就从右到左更。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int max_left = 0;</span><br><span class="line">    int max_right = 0;</span><br><span class="line">    int left = 1;</span><br><span class="line">    int right = height.length - 2; // 加右指针进去</span><br><span class="line">    for (int i = 1; i &lt; height.length - 1; i++) &#123;</span><br><span class="line">        //从左到右更</span><br><span class="line">        if (height[left - 1] &lt; height[right + 1]) &#123;</span><br><span class="line">            max_left = Math.max(max_left, height[left - 1]);</span><br><span class="line">            int min = max_left;</span><br><span class="line">            if (min &gt; height[left]) &#123;</span><br><span class="line">                sum = sum + (min - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        //从右到左更</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            max_right = Math.max(max_right, height[right + 1]);</span><br><span class="line">            int min = max_right;</span><br><span class="line">            if (min &gt; height[right]) &#123;</span><br><span class="line">                sum = sum + (min - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n)。<br>空间复杂度：O (1)。</p><p>​### 解法四：栈</p><p><img src="/2019/12/16/LeetCode之接雨水/ggg.jpg" alt></p><p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p><p>我们用栈保存每堵墙。</p><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>总体的原则就是，<br>1.当前高度小于等于栈顶高度，入栈，指针后移。<br>2.当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p><p>我们看具体的例子。</p><ul><li><p>首先将 height [ 0 ] 入栈。然后 current 指向的高度大于栈顶高度，所以把栈顶 height [ 0 ] 出栈，然后栈空了，再把 height [ 1 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/hhh.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶高度，height [ 2 ] 入栈，current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/jjj.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，栈顶 height [ 2 ] 出栈。计算 height [ 3 ] 和新的栈顶之间的水。计算完之后继续判断 current 和新的栈顶的关系。<br><img src="/2019/12/16/LeetCode之接雨水/kkk.jpg" alt></p></li><li><p>current 指向的高度大于栈顶高度，栈顶 height [ 1 ] 出栈，栈空。所以把 height [ 3 ] 入栈。currtent 后移。<br><img src="/2019/12/16/LeetCode之接雨水/lll.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 3 ] 的高度，height [ 4 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/zzz.jpg" alt></p></li><li><p>然后 current 指向的高度小于栈顶 height [ 4 ] 的高度，height [ 5 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/xxx.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶 height [ 5 ] 的高度，将栈顶 height [ 5 ] 出栈，然后计算 current 指向的墙和新栈顶 height [ 4 ] 之间的水。计算完之后继续判断 current 的指向和新栈顶的关系。此时 height [ 6 ] 不大于栈顶 height [ 4 ] ，所以将 height [ 6 ] 入栈。current 后移。<br><img src="/2019/12/16/LeetCode之接雨水/vvv.jpg" alt></p></li><li><p>然后 current 指向的高度大于栈顶高度，将栈顶 height [ 6 ] 出栈。计算和新的栈顶 height [ 4 ] 组成两个边界中的水。然后判断 current 和新的栈顶 height [ 4 ] 的关系，依旧是大于，所以把 height [ 4 ] 出栈。计算 current 和 新的栈顶 height [ 3 ] 之间的水。然后判断 current 和新的栈顶 height [ 3 ] 的关系，依旧是大于，所以把 height [ 3 ] 出栈，栈空。将 current 指向的 height [ 7 ] 入栈。current 后移。<br>其实不停的出栈，可以看做是在找与 7 匹配的墙，也就是 3 。</p></li></ul><p><img src="/2019/12/16/LeetCode之接雨水/nnn.jpg" alt><br>而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离。可以看下代码继续理解下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int trap6(int[] height) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    int current = 0;</span><br><span class="line">    while (current &lt; height.length) &#123;</span><br><span class="line">        //如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span><br><span class="line">        while (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            int h = height[stack.peek()]; //取出要出栈的元素</span><br><span class="line">            stack.pop(); //出栈</span><br><span class="line">            if (stack.empty()) &#123; // 栈空就出去</span><br><span class="line">                break; </span><br><span class="line">            &#125;</span><br><span class="line">            int distance = current - stack.peek() - 1; //两堵墙之前的距离。</span><br><span class="line">            int min = Math.min(height[stack.peek()], height[current]);</span><br><span class="line">            sum = sum + distance * (min - h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current); //当前指向的墙入栈</span><br><span class="line">        current++; //指针后移</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：虽然 while 循环里套了一个 while 循环，但是考虑到每个元素最多访问两次，入栈一次和出栈一次，所以时间复杂度是 [n] 。</p><p>空间复杂度： [n] 。栈的空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈、双指针、动态规划" scheme="http://yoursite.com/categories/%E6%A0%88%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2019/12/15/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/12/15/三次握手和四次挥手/</id>
    <published>2019-12-15T11:57:10.000Z</published>
    <updated>2019-12-26T08:43:14.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。</p><a id="more"></a><h3 id="TCP-服务模型"><a href="#TCP-服务模型" class="headerlink" title="TCP 服务模型"></a>TCP 服务模型</h3><p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p><p>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</p><p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而 IP 不提供重复消除或者保证次序正确的功能。另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>客户端和服务端通信前要进行连接，“3 次握手” 的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的 “响应” 是由于第一次的 “请求” 触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表面上看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的 “指令” 是上层应用层给出的，我只是一个 “搬运工”，我无法了解 “上层的意志”。</p><ul><li>TCP 的三次握手改成两次握手可以吗？</li></ul><p>不可以，一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><p>在谢希仁著《计算机网络》第四版中讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲 “三次握手” 的目的是为了解决 “网络中存在延迟的重复分组” 的问题。这两种不用的表述其实阐明的是同一个问题。<br>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”。主要目的防止 server 端一直等待，浪费资源。</p><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53374516</a><br>[参考链接]<a href="https://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="noopener">https://blog.csdn.net/xifeijian/article/details/12777187</a><br>[参考链接]<a href="https://ioscaff.com/articles/252" target="_blank" rel="noopener">https://ioscaff.com/articles/252</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h3&gt;&lt;p&gt;TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的 “连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。&lt;/p&gt;
&lt;p&gt;TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。&lt;/p&gt;
&lt;p&gt;TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tcp协议" scheme="http://yoursite.com/categories/tcp%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>学习两个月算法之后的总结</title>
    <link href="http://yoursite.com/2019/12/14/%E5%AD%A6%E4%B9%A0%E4%B8%A4%E4%B8%AA%E6%9C%88%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/14/学习两个月算法之后的总结/</id>
    <published>2019-12-14T11:57:10.000Z</published>
    <updated>2019-12-15T16:52:49.129Z</updated>
    
    <content type="html"><![CDATA[<ul><li>克服焦虑，不再心急<br>首先要承认自己这两个月学算法学的有点焦虑，所有视频只过了一遍；焦虑是由于自己处理不好学习算法和项目的时间转换，也是有点心急，但是后来一想算法是个持久战，不能心急，慢慢的；越是心急越是陷入了死循环；</li><li>馒头要一口一口吃<br>尽管学的有点焦虑，也还是学到了很多东西，画递归图虽然有点傻，但是也不失为理解递归的好方法，馒头总要一口一口吃；我愿再花上两个月的时间跨过算法这道坎；</li><li>观念转变<br>通过两个月的时间学习算法，发现很多题都是有模板，也就是按照一定的套路就可以做出来，这个思想的转变很重要，使得不再恐惧算法；</li><li>承认自己不是天才<br>承认自己不是天才这点非常重要，有时候我们就是太自信了，学什么都是按照自己想象的有效的方法进行学习（本来就是高手的除外），自己的方法无效，何不去试试别人有效的方法呢，它山之石可以攻玉；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;克服焦虑，不再心急&lt;br&gt;首先要承认自己这两个月学算法学的有点焦虑，所有视频只过了一遍；焦虑是由于自己处理不好学习算法和项目的时间转换，也是有点心急，但是后来一想算法是个持久战，不能心急，慢慢的；越是心急越是陷入了死循环；&lt;/li&gt;
&lt;li&gt;馒头要一口一口吃&lt;b
      
    
    </summary>
    
    
      <category term="算法总结" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="算法总结" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2019/12/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2019/12/13/动态规划/</id>
    <published>2019-12-13T11:57:10.000Z</published>
    <updated>2019-12-13T08:16:46.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划的三大步骤"><a href="#动态规划的三大步骤" class="headerlink" title="动态规划的三大步骤"></a>动态规划的三大步骤</h2><blockquote><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p></blockquote><a id="more"></a><ul><li><p>第一步骤</p><blockquote><blockquote><p>定义数组元素的含义，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp [] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp [i] 是代表什么意思？</p></blockquote></blockquote></li><li><p>第二步骤</p><blockquote><blockquote><p>找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp [n] 时，是可以利用 dp [n-1]，dp [n-2]…..dp [1]，来推出 dp [n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说</p></blockquote></blockquote></li><li><p>第三步骤</p><blockquote><blockquote><p>找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，我们可以通过 dp [n-1] 和 dp [n-2] 来计算 dp [n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp [3] = dp [2] + dp [1]。而 dp [2] 和 dp [1] 是不能再分解的了，所以我们必须要能够直接获得 dp [2] 和 dp [1] 的值，而这，就是所谓的初始值。</p></blockquote></blockquote></li></ul><p><strong>有了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp [n] 的值了，而 dp [n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。</strong></p><h2 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h2><h3 id="案例一-简单的一维-DP"><a href="#案例一-简单的一维-DP" class="headerlink" title="案例一: 简单的一维 DP"></a>案例一: 简单的一维 DP</h3><blockquote><p>问题描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote><ul><li><p>定义数组元素的含义</p><blockquote><blockquote><p>按我上面的步骤说的，首先我们来定义 dp [i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp [i] 的含义为：跳上一个 i 级的台阶总共有 dp [i] 种跳法。这样，如果我们能够算出 dp [n]，不就是我们要求的答案吗？所以第一步定义完成。</p></blockquote></blockquote></li><li><p>找出数组元素间的关系式</p><blockquote><blockquote><p>我们的目的是要求 dp [n]，动态规划的题，如你们经常听说的那样，就是把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。也就是说，dp [n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp [n] 一定会和 dp [n-1], dp [n-2]…. 存在某种关系的。我们要找出他们的关系。</p></blockquote></blockquote></li></ul><p>那么问题来了，怎么找？<br>这个怎么找，是最核心最难的一个，我们必须回到问题本身来了，来寻找他们的关系式，dp [n] 究竟会等于什么呢？<br>对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</p><p><strong><em>一种是从第 n-1 级跳上来</em></strong><br><strong><em>一种是从第 n-2 级跳上来</em></strong><br>由于我们是要算所有可能的跳法的，所以有 dp [n] = dp [n-1] + dp [n-2]。</p><ul><li>找出初始条件<blockquote><blockquote><p>当 n = 1 时，dp [1] = dp [0] + dp [-1]，而我们是数组是不允许下标为负数的，所以对于 dp [1]，我们必须要直接给出它的数值，相当于初始值，显然，dp [1] = 1。一样，dp [0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：</p></blockquote></blockquote></li></ul><p>dp [0] = 0. dp [1] = 1. 即 n &lt;= 1 时，dp [n] = n.</p><p>三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f( int n )&#123;</span><br><span class="line">    if(n &lt;= 1)&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 先创建一个数组来保存历史数据</span><br><span class="line">    int[] dp = new int[n+1];</span><br><span class="line">    // 给出初始值</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    // 通过关系式来计算出 dp[n]</span><br><span class="line">    for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把最终结果返回</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再说初始化</li></ul><p>大家先想以下，你觉得，上面的代码有没有问题？<br>答是有问题的，还是错的，错在对初始值的寻找不够严谨，这也是我故意这样弄的，意在告诉你们，关于初始值的严谨性。例如对于上面的题，当 n = 2 时，dp [2] = dp [1] + dp [0] = 1。这显然是错误的，你可以模拟一下，应该是 dp [2] = 2。</p><p><strong><em>也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp [2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。</em></strong></p><h3 id="案例二-二维数组的-DP"><a href="#案例二-二维数组的-DP" class="headerlink" title="案例二: 二维数组的 DP"></a>案例二: 二维数组的 DP</h3><p><strong><em>我做了几十道 DP 的算法题，可以说，80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。</em></strong>这里的我指的是别人，不是指的本我</p><blockquote><p>问题描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。问总共有多少条不同的路径？<br><img src="/2019/12/13/动态规划/aaa.png" alt></p></blockquote><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp [i] [j] 的含义为：当机器人从左上角走到 (i, j) 这个位置时，一共有 dp [i] [j] 种路径。那么，dp [m-1] [n-1] 就是我们要的答案了。</p><blockquote><blockquote><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp [m-1] [n-1] 就是我们要找的答案。</p></blockquote></blockquote><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><blockquote><blockquote><p>一种是从 (i-1, j) 这个位置走一步到达<br>一种是从 (i, j - 1) 这个位置走一步到达</p></blockquote></blockquote><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp [i] [j] = dp [i-1] [j] + dp [i] [j-1]。</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n-1] 和所有的 dp [0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><blockquote><blockquote><p>dp [0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走<br>dp [0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquePaths(int m, int n) &#123;</span><br><span class="line">    if (m &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n]; // </span><br><span class="line">    // 初始化</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">      dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 推导出 dp[m-1][n-1]</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例三、二维数组-DP"><a href="#案例三、二维数组-DP" class="headerlink" title="案例三、二维数组 DP"></a>案例三、二维数组 DP</h3><blockquote><p>问题描述：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">输入:</span><br><span class="line">arr = [</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>我还是要按照步骤来写，让那些不大懂的加深理解。有人可能觉得，这些题太简单了吧，别慌，小白先入门，这些属于 medium 级别的，后面在给几道 hard 级别的。</p><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp [i] [j] 的含义为：当机器人从左上角走到 (i, j) 这个位置时，最下的路径和是 dp [i] [j]。那么，dp [m-1] [n-1] 就是我们要的答案了。</p><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp [m-1] [n-1] 就是我们要走的答案。</p><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><blockquote><blockquote><p>一种是从 (i-1, j) 这个位置走一步到达</p></blockquote></blockquote><blockquote><blockquote><p>一种是从 (i, j - 1) 这个位置走一步到达</p></blockquote></blockquote><p>不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，那么我们要从这两种方式中，选择一种，使得 dp [i] [j] 的值是最小的，显然有</p><p>dp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];// arr[i][j] 表示网格中的值</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n-1] 和所有的 dp [0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><blockquote><p>dp [0] [j] = arr [0] [j] + dp [0] [j-1]; // 相当于最上面一行，机器人只能一直往左走<br>dp [i] [0] = arr [i] [0] + dp [i] [0]; // 相当于最左面一列，机器人只能一直往下走案例三、二维数组 DP</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquePaths(int[][] arr) &#123;</span><br><span class="line">    int m = arr.length;</span><br><span class="line">    int n = arr[0].length;</span><br><span class="line">    if (m &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n]; // </span><br><span class="line">    // 初始化</span><br><span class="line">    dp[0][0] = arr[0][0];</span><br><span class="line">    // 初始化最左边的列</span><br><span class="line">    for(int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][0] = dp[i-1][0] + arr[i][0];</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化最上边的行</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">      dp[0][i] = dp[0][i-1] + arr[0][i];</span><br><span class="line">    &#125;</span><br><span class="line">        // 推导出 dp[m-1][n-1]</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例-4：编辑距离"><a href="#案例-4：编辑距离" class="headerlink" title="案例 4：编辑距离"></a>案例 4：编辑距离</h3><p>这次给的这道题比上面的难一些，在 leetcdoe 的定位是 hard 级别。</p><blockquote><p>问题描述:给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line">插入一个字符 删除一个字符 替换一个字符</span><br><span class="line">示例：</span><br><span class="line">输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p>按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且 90% 是采用二维数组。</p><ul><li>步骤一、定义数组元素的含义</li></ul><p>由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp [i] [j] 的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp [i] [j]。</p><ul><li>步骤二：找出关系数组元素间的关系式</li></ul><p>接下来我们就要找 dp [i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp [i] [j] 和 dp [i-1] [j]、dp [i] [j-1]、dp [i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，从规模小的，通过一些操作，推导出规模大的。对于这道题，我们可以对 word1 进行三种操作</p><blockquote><blockquote><p>插入一个字符 删除一个字符 替换一个字符</p></blockquote></blockquote><p>由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：</p><p>一、如果我们 word1 [i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp [i] [j] = dp [i-1] [j-1]。（别忘了 dp [i] [j] 的含义哈）。</p><p>二、如果我们 word1 [i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：<br>（1）如果把字符 word1 [i] 替换成与 word2 [j] 相等，则有 dp [i] [j] = dp [i-1] [j-1] + 1;</p><p>（2）如果在字符串 word1 末尾插入一个与 word2 [j] 相等的字符，则有 dp [i] [j] = dp [i] [j-1] + 1;</p><p>（3）如果把字符 word1 [i] 删除，则有 dp [i] [j] = dp [i-1] [j] + 1;</p><p>那么我们应该选择一种操作，使得 dp [i] [j] 的值最小，显然有</p><p>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</p><p>于是，我们的关系式就推出来了，</p><ul><li>步骤三、找出初始值</li></ul><p>显然，当 dp [i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp [0] [0….n] 和所有的 dp [0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">    int n1 = word1.length();</span><br><span class="line">    int n2 = word2.length();</span><br><span class="line">    int[][] dp = new int[n1 + 1][n2 + 1];</span><br><span class="line">    // dp[0][0...n2]的初始值</span><br><span class="line">    for (int j = 1; j &lt;= n2; j++) </span><br><span class="line">        dp[0][j] = dp[0][j - 1] + 1;</span><br><span class="line">    // dp[0...n1][0] 的初始值</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) </span><br><span class="line">        dp[i][0] = dp[i - 1][0] + 1;</span><br><span class="line">        // 通过公式推出 dp[n1][n2]</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n2; j++) &#123;</span><br><span class="line">            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span><br><span class="line">            if (word1.charAt(i - 1) == word2.charAt(j - 1))&#123;</span><br><span class="line">                p[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n1][n2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划的三大步骤&quot;&gt;&lt;a href=&quot;#动态规划的三大步骤&quot; class=&quot;headerlink&quot; title=&quot;动态规划的三大步骤&quot;&gt;&lt;/a&gt;动态规划的三大步骤&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤，&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="递归、栈" scheme="http://yoursite.com/categories/%E9%80%92%E5%BD%92%E3%80%81%E6%A0%88/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归详解</title>
    <link href="http://yoursite.com/2019/12/12/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/12/递归详解/</id>
    <published>2019-12-12T11:57:10.000Z</published>
    <updated>2019-12-26T08:43:44.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p></blockquote></blockquote><a id="more"></a><blockquote><blockquote><p>说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>题目给出的算法结构为：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>首先题目要求返回的类型为 List&lt;List<integer>&gt;，那么我们就新建一个 List&lt;List<integer>&gt; 作为全局变量，最后将其返回。</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line"></span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>再看看返回的结构，List&lt;List<integer>&gt;。因此我们需要写一个包含 List<integer> 的辅助函数，加上一些判断条件，此时结构变成了：</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>重点就是如何进行递归。递归的第一步，当然是写递归的终止条件啦，没有终止条件的递归会进入死循环。那么有 哪些终止条件呢？由于条件中说了都是正整数。。因此，如果 target&lt;0, 当然是要终止了，如果 target==0，说明此时找到了一组数的和为 target，将其加进去。此时代码结构变成了这样。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>我们是要求组成 target 的组合。因此需要一个循环来进行遍历。每遍历一次，将此数加入 list，然后进行下一轮递归。代码结构如下。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process( candidates, target - candidates[i], list);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/递归详解/fff.jpg" alt><br>似乎初具规模，测试一把结果如下：<br><img src="/2019/12/12/递归详解/aaa.jpg" alt></p><blockquote><blockquote><p>结果差距有点大，为何会出现如此大的反差。而且发现一个规律，后面的一个组合会包含前面一个组合的所有的数字，而且这些数加起来和 target 也不相等啊。原因出在哪呢？java 中除了几个基本类型，其他的类型可以算作引用传递。这就是导致 list 数字一直变多的原因。因此，在每次递归完成，我们要进行一次回溯。把最新加的那个数删除。此时代码结构变成这样。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process( candidates, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再测一下，结果如下：<br><img src="/2019/12/12/递归详解/bbb.jpg" alt></p><blockquote><blockquote><p>还是不对。这次加起来都等于 7 了，和上次结果相比算是一个很大的进步了。分析下测试结果。不难能看出，本次结果的主要问题包含了重复的组合。为什么会有重复的组合呢？因为每次递归我们都是从 0 开始，所有数字都遍历一遍。所以会出现重复的组合。改进一下，只需加一个 start 变量即可。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        if (candidates == null || candidates.length == 0 || target &lt; 0) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        process(0, candidates, target, list);</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(int start, int[] candidates, int target, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        //递归的终止条件</span><br><span class="line">        if (target &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span><br><span class="line">                process(i, candidates, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后再测一下。<br><img src="/2019/12/12/递归详解/ccc.jpg" alt></p><blockquote><blockquote><p>代码通过，但是效率并不高。本题有效果更好的动态规划的解法。本文主要展示递归回溯，就不做具体介绍了。是不是有点感觉了，那么再来一题。</p></blockquote></blockquote><blockquote><blockquote><p>题目描述:给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题目给出的算法结构为</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>按照前面的套路，首先建一个 ArrayList&lt;List<integer>&gt; res 作为全局变量。顺带建一个含有 List<integer>list 的辅助函数。</integer></integer></p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">此时结构变成如下所示。</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>对于辅助递归函数。第一步当然是列出终止条件，避免进入死循环。由于题目要求是所有 k 个数的组合。那么很容易知道递归的终止条件为 list.size() == k。因此，代码结构可变为如下所示。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>接下来要进入重头戏了，递归回溯的整个过程。整个递归过程不就是一直将数字加入 list 么。因此可以用一个循环。</p></blockquote></blockquote><p>在循环中主要做三件事</p><p>1.加此轮的数据加入 list。</p><p>2.递归进行下一步调用。</p><p>3.删除此轮加入的数据进行回溯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">此时代码结构如下：</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n ; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            generateCombinations(n,k,i+1,list);</span><br><span class="line">            list.remove(list.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>代码大致结构以及形成，测试一下，结果如下。</p></blockquote></blockquote><p>通过是通过了，但是真的慢啊。<br><img src="/2019/12/12/递归详解/ddd.jpg" alt></p><p>分析一下原因所在。假设 n = 100, k= 90, i = 15，按照上面的代码，我们还需要继续循环 85 次。但是想一下，即使后面的循环每次都加一个数据，最后也才 85 个数据。</p><p>不能形成一组解。也就是说这些循环都是在做无用功，因此引出一个很重要的知识点。 剪枝循环的终止条件不应该是 i&lt;=n, 应该是 i-1 +(k-list.size()) &lt;= n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">因此代码如下:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">     private ArrayList&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    // 求解C(n,k), 当前已经找到的组合存储在c中, 需要从start开始搜索新的元素</span><br><span class="line">    private void generateCombinations(int n, int k, int start, List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(list.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = start; i &lt;= n-(k-list.size())+1 ; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            generateCombinations(n,k,i+1,list);</span><br><span class="line">            list.remove(list.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line"></span><br><span class="line">        res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(n&lt;=0 || k&lt;=0 || k&gt;n)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        generateCombinations(n,k,1,list);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果如下。<br><img src="/2019/12/12/递归详解/eee.jpg" alt></p><blockquote><blockquote><p>当一个问题可以被不断分解为一个个更加简单的问题的时候，并且在最终会有一个明确的终点的时候，这个时候便是考虑运用递归的时候了。举一个栗子 ： 非常经典的斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… 在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F (n-1)+F (n-2)（n&gt;=2，n∈N*）。</p></blockquote></blockquote><p>//这里我们用两种递归方法来解决，一种是最初的简单递归，二是对简单递归的优化</p><p>int fib(int n){//求出数列第n项的数值</p><pre><code>if(n==1||n==2){    return 1;//回溯的条件}else {    return fib(n-1)+fib(n-2);//向下递进}</code></pre><p>}</p><blockquote><blockquote><p>这里我们看 fib(5) = fib(4)+fib(3) fib(4) = fib(3)+fib(2) fib(3) = fib(2)+fib(1)<br>这里有很多的计算是重复的，所以这也是递归的缺点之一,在这里我们可以看到递归的思路，第n项为前两项的和，那么我们便可以不断地向前推进直到已知项,这里还有一种对于上述递归解法的优化方法<br>我们看前几项分别为1 1 2 3 5<br>fiber(1,1,5) = fiber(1,2,4) = fiber(2,3,3)<br>解释上述表达式 前两项分别为1 1的第五项与前两项分别为 1 2的第四项与前两项分别为 2 3 的第3项相等 所以我们运用这种思路来避免重复的计算来降低计算的复杂度;</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fiber(1,1,5) = fiber(1,2,4) = fiber(2,3,3)</span><br><span class="line"></span><br><span class="line">1, 1, 2, 3, 5</span><br><span class="line">1, 2, 3, 5</span><br><span class="line">2, 3, 5</span><br><span class="line"></span><br><span class="line">int fiber(int first,int second,int num)&#123;</span><br><span class="line">if(n&gt;0)&#123;</span><br><span class="line">if(num==1||num==2)</span><br><span class="line">return 1;</span><br><span class="line">else if(num==3)</span><br><span class="line">return first+second;</span><br><span class="line">else</span><br><span class="line">return fiber(second,first+second,--num);</span><br><span class="line">&#125;else</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>将斐波那契数列改为非递归方式实现：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">  if (n == 2) &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  int ret = 0;</span><br><span class="line">  int pre = 2;</span><br><span class="line">  int prepre = 1;</span><br><span class="line">  for (int i = 3; i &lt; n; i++) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/34841160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34841160</a><br>[参考链接]<a href="https://zhuanlan.zhihu.com/p/92782083" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92782083</a><br>[参考链接]<a href="https://zhuanlan.zhihu.com/p/88760014" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88760014</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="递归、栈" scheme="http://yoursite.com/categories/%E9%80%92%E5%BD%92%E3%80%81%E6%A0%88/"/>
    
    
      <category term="数据结构、算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Jackson注解</title>
    <link href="http://yoursite.com/2019/12/11/Jackson%E4%B8%AD%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/11/Jackson中注解使用/</id>
    <published>2019-12-11T11:57:10.000Z</published>
    <updated>2019-12-26T08:44:01.213Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使Jackson 序列化和反序列化字段不一致</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;aa&quot;)</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @JsonProperty(&quot;bb&quot;)</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>办法就是 set 和 get 方法上 JsonProperty 分别指定反序列化和序列化的字段名称假如 name 的值为 test 这样一来就可以以 “{“bb”:”test”}” 来反序列化，然后序列化的输出是 “{“aa”:”test”}”</p></blockquote></blockquote><ul><li>作用在属性上，序列化输出时，使用别名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如下：输出 json 串时，用的是 loginname 别名。</span><br><span class="line">@JsonProperty(&quot;loginname&quot;)</span><br><span class="line">private String loginName;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使Jackson 序列化和反序列化字段不一致&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="序列化与反序列化" scheme="http://yoursite.com/categories/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
      <category term="序列化与反序列化" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>定时任务实现</title>
    <link href="http://yoursite.com/2019/12/10/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/10/定时任务实现/</id>
    <published>2019-12-10T11:57:10.000Z</published>
    <updated>2019-12-26T08:44:18.262Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通过 Timer 来实现<blockquote><blockquote><p>自定义一个任务，继承于 TimerTask，重写 run 方法;利用 java.util.Timer 实现任务调度</p></blockquote></blockquote></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedule &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line">        long delay = 2000;</span><br><span class="line">        long interval = 1000;</span><br><span class="line"></span><br><span class="line">        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次</span><br><span class="line">        timer.schedule(new JobTask(), delay, interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JobTask extends TimerTask &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Test: &quot; + Calendar.getInstance().getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。</p><p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。<br>例如我们指定每隔 1000 毫秒执行一次任务，但是可能某个任务执行花了 5000 毫秒，因此导致后续的任务并不能按时启动执行。</p><ul><li>通过 ScheduledExecutorService 来实现</li></ul><blockquote><blockquote><p>鉴于 Timer 的上述缺陷，Java 5 推出了基于线程池设计的 ScheduledExecutorService。<br>其设计思想是，每一个被调度的任务都会 由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。<br>需要注意的是，只有当任务的执行时间到来时，ScheduledExecutorService 才会真正启动一个线程，其余时间 ScheduledExecutorService 都是在轮询任务的状态。</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class JobSchedule &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);</span><br><span class="line">        long delay = 2;</span><br><span class="line">        long interval = 1;</span><br><span class="line"></span><br><span class="line">        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次</span><br><span class="line">        service.scheduleAtFixedRate(</span><br><span class="line">                new JobTask(), delay,</span><br><span class="line">                interval, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JobTask implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Test: &quot; + Calendar.getInstance().getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;通过 Timer 来实现&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义一个任务，继承于 TimerTask，重写 run 方法;利用 java.util.Timer 实现任务调度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor学习</title>
    <link href="http://yoursite.com/2019/12/09/supervisor%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/09/supervisor学习/</id>
    <published>2019-12-09T11:57:10.000Z</published>
    <updated>2019-12-19T02:51:07.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ul><li>下载相应版本进行源码安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">tar -zxvf supervisor-3.1.3.tar.gz</span><br><span class="line">cd supervisor-3.1.3</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p><img src="/2019/12/09/supervisor学习/aaa.jpg" alt></p><ul><li>生成配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /opt/supervisor-3.1.3/supervisord.conf</span><br><span class="line">###为了不将所有新增配置信息全写在一个配置文件里，这里新建一个文件夹，每个程序(需要使用supervisor管理的程序)设置一个配置文件，相互隔离</span><br><span class="line">mkdir /opt/supervisor-3.1.3/supervisord.d/</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/12/09/supervisor学习/bbb.jpg" alt><br><img src="/2019/12/09/supervisor学习/ccc.jpg" alt></p><ul><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">### 修改配置文件</span><br><span class="line">vim supervisord.conf</span><br><span class="line"></span><br><span class="line">### 加入以下配置信息</span><br><span class="line">[include]</span><br><span class="line">files = /opt/supervisor-3.1.3/supervisord.d/*.conf</span><br><span class="line"></span><br><span class="line">### 在supervisord.conf中设置通过web可以查看管理的进程，加入以下代码（默认即有，取消注释即可）    </span><br><span class="line">[inet_http_server] </span><br><span class="line">port=9001</span><br><span class="line">username=user      </span><br><span class="line">password=123</span><br><span class="line"></span><br><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/opt/beh/supervisor/log/supervisord.log  ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</span><br><span class="line">logfile_backups=10          ; (num of main logfile rotation backups;default 10)</span><br><span class="line">loglevel=info               ; (log level;default info; others: debug,warn,trace)</span><br><span class="line">pidfile=supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">nodaemon=false              ; (start in foreground if true;default false)</span><br><span class="line">minfds=1024                 ; (min. avail startup file descriptors;default 1024)</span><br><span class="line">minprocs=200                ; (min. avail process descriptors;default 200)</span><br><span class="line">;supervisor启动用户设置</span><br><span class="line">user=chrism                 ; (default is current user, required if root)</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">;serverurl=unix://./supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line">serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket</span><br></pre></td></tr></table></figure></li><li><p>移动配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/supervisorctl  /opt/supervisor-3.1.3</span><br><span class="line">mv /usr/bin/supervisord  /opt/supervisor-3.1.3</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/12/09/supervisor学习/ddd.jpg" alt></p><ul><li>启动服务端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /opt/supervisor-3.1.3/supervisord.conf</span><br></pre></td></tr></table></figure></li></ul><p>[参考文章]<a href="https://www.cnblogs.com/mhq-martin/p/8649621.html" target="_blank" rel="noopener">https://www.cnblogs.com/mhq-martin/p/8649621.html</a></p><p>[参考文章]<a href="https://www.jianshu.com/p/f8735b039c67" target="_blank" rel="noopener">https://www.jianshu.com/p/f8735b039c67</a></p><p>[参考文章]<a href="https://www.jianshu.com/p/bf2b3f4dec73" target="_blank" rel="noopener">https://www.jianshu.com/p/bf2b3f4dec73</a></p><p>[参考文章]<a href="https://juejin.im/post/5d80da83e51d45620c1c5471" target="_blank" rel="noopener">https://juejin.im/post/5d80da83e51d45620c1c5471</a></p><p>[参考文章]<a href="https://www.huweihuang.com/article/linux/supervisor-usage/" target="_blank" rel="noopener">https://www.huweihuang.com/article/linux/supervisor-usage/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;源码安装&quot;&gt;&lt;a href=&quot;#源码安装&quot; class=&quot;headerlink&quot; title=&quot;源码安装&quot;&gt;&lt;/a&gt;源码安装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载相应版本进行源码安装&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /opt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf supervisor-3.1.3.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd supervisor-3.1.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo python setup.py install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>GitHub搜索小技巧</title>
    <link href="http://yoursite.com/2019/12/03/GitHub%E6%90%9C%E7%B4%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/12/03/GitHub搜索小技巧/</id>
    <published>2019-12-03T11:57:10.000Z</published>
    <updated>2019-12-17T01:30:30.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h3><p>传统的搜索就是直接使用关键词，但是 GitHub 的搜索功能远远不止如此，还可以：</p><a id="more"></a><h4 id="名称包含"><a href="#名称包含" class="headerlink" title="名称包含"></a>名称包含</h4><ul><li><p>xxx in:name 项目名包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/aaa.png" alt></p></li><li><p>xxx in:description 项目描述包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/bbb.png" alt></p></li><li><p>xxx in:readme 项目的 README 文件中包含 xxx 的<br><img src="/2019/12/03/GitHub搜索小技巧/ccc.png" alt></p></li></ul><h4 id="仓库统计范围"><a href="#仓库统计范围" class="headerlink" title="仓库统计范围"></a>仓库统计范围</h4><p>比如：</p><ul><li><p>Django stars:&gt;=2048<br>要查找 Stars 数不小于 2048 的 Django 项目<br><img src="/2019/12/03/GitHub搜索小技巧/ddd.png" alt></p></li><li><p>Django forks:&gt;2048<br>Forks 大于等于 2048<br><img src="/2019/12/03/GitHub搜索小技巧/eee.png" alt></p></li><li><p>Django forks:100..200 stars:80..100<br>查找 Forks 在 100 到 200 之间 且 Star 数在 80 到 100 之间的 Django 项目<br><img src="/2019/12/03/GitHub搜索小技巧/fff.png" alt></p></li></ul><p>[参考链接]<a href="https://zhuanlan.zhihu.com/p/79434481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79434481</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;搜索技巧&quot;&gt;&lt;a href=&quot;#搜索技巧&quot; class=&quot;headerlink&quot; title=&quot;搜索技巧&quot;&gt;&lt;/a&gt;搜索技巧&lt;/h3&gt;&lt;p&gt;传统的搜索就是直接使用关键词，但是 GitHub 的搜索功能远远不止如此，还可以：&lt;/p&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="http://yoursite.com/categories/GitHub/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>bdmg部署</title>
    <link href="http://yoursite.com/2019/12/02/bdmg%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/12/02/bdmg部署/</id>
    <published>2019-12-02T09:28:24.000Z</published>
    <updated>2019-12-09T08:20:02.273Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>从git上下载bdmg代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://git@code.bonc.com.cn:10022/bdev/bdm.git</span><br></pre></td></tr></table></figure></li><li><p>下载下来注释掉App.java中部分代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//if(isAuthorized())&#123;</span><br><span class="line">SpringApplication.run(App.class, args);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>在application-bdmg.yml中添加EPM的配置以及修改bdds的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">epm:</span><br><span class="line">    path: /epm/**</span><br><span class="line">    stripPrefix: 1</span><br><span class="line">    uri: http://172.16.13.148:8800  // epm部署所在节点</span><br><span class="line"></span><br><span class="line">bdds:</span><br><span class="line">    path: /bdds/**</span><br><span class="line">    stripPrefix: 1</span><br><span class="line">    uri: http://172.16.13.147:19910  //bdds部署所在节点</span><br></pre></td></tr></table></figure></li><li><p>在BdmgProperties.java文件中添加如下代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//epm配置</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.path&#125;&quot;)</span><br><span class="line">private String epmGateWayPath;</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.stripPrefix&#125;&quot;)</span><br><span class="line">private String epmGateWayStripPrefix;</span><br><span class="line">@Value(&quot;$&#123;gateway.routes.epm.uri&#125;&quot;)</span><br><span class="line">private String epmGateWayStripUri;</span><br></pre></td></tr></table></figure><ul><li>在GatewayRouteConfiguration.java文件中添加如下代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> .route(&quot;epm_route&quot;, r -&gt; r.path(bdmgProperties.getEpmGateWayPath())</span><br><span class="line">                        .filters(f -&gt; &#123;</span><br><span class="line">                            f.stripPrefix(Integer.valueOf(bdmgProperties.getEpmGateWayStripPrefix()));</span><br><span class="line">                            return f;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .uri(bdmgProperties.getEpmGateWayStripUri()))</span><br><span class="line"></span><br><span class="line">.route(&quot;bdds_route&quot;, r -&gt; r.path(bdmgProperties.getBddsGateWayPath())</span><br><span class="line">                        .filters(f -&gt; &#123;</span><br><span class="line">//                            f.filter(new GatewayPreFilter(bdmgProperties));</span><br><span class="line">                            f.stripPrefix(Integer.valueOf(bdmgProperties.getBddsGateWayStripPrefix()));</span><br><span class="line">                            return f;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .uri(bdmgProperties.getBddsGateWayStripUri()))</span><br></pre></td></tr></table></figure><ul><li><p>打包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure></li><li><p>启动命令</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /home/bdc/beh-director/share/jdk/jdk1.8.0_131/bin/java -jar bdmg-1.3.0.jar &gt;bdmg.log &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;从git上下载bdmg代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone ssh://git@code.bonc.com.cn:10022/bdev/bdm.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载下来注释掉App.java中部分代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//		if(isAuthorized())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			SpringApplication.run(App.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="项目日记" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="项目笔记" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>springMVC中controller接收list类型参数</title>
    <link href="http://yoursite.com/2019/11/06/springMVC%E4%B8%ADcontroller%E6%8E%A5%E6%94%B6list%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/06/springMVC中controller接收list类型参数/</id>
    <published>2019-11-06T11:57:10.000Z</published>
    <updated>2019-12-31T06:46:15.848Z</updated>
    
    <content type="html"><![CDATA[<p>1、客户端使用 post或patch方式提交；</p><p>2、客户端请求 header 设置：Content-Type：application/json;charset=utf-8；</p><p>3、客户端请求参数为 json 格式：[“abc”,”cba”]；</p><p>4、controller 参数增加声明：@RequestBody；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PatchMapping(&quot;/all/deployment/status&quot;)</span><br><span class="line">public void delFileInfo(@RequestBody List&lt;String&gt; bacthAgent) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">    for(String agentId :bacthAgent)&#123;</span><br><span class="line">        System.out.println(agentId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、客户端使用 post或patch方式提交；&lt;/p&gt;
&lt;p&gt;2、客户端请求 header 设置：Content-Type：application/json;charset=utf-8；&lt;/p&gt;
&lt;p&gt;3、客户端请求参数为 json 格式：[“abc”,”cba”]；&lt;/p
      
    
    </summary>
    
    
      <category term="springMVC" scheme="http://yoursite.com/categories/springMVC/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
</feed>
