<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-17T02:09:41.445Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我没以前帅了</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/08/25/go%E8%AF%AD%E8%A8%80%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>http://yoursite.com/2020/08/25/go语言命名返回值/</id>
    <published>2020-08-25T03:45:02.118Z</published>
    <updated>2020-09-17T02:09:41.445Z</updated>
    
    <content type="html"><![CDATA[<p>查看全部索引：curl -XGET ‘172.16.48.1:9200/_cat/indices?v’</p><p>查看索引数据：curl -XGET ‘172.16.48.1:9200/posts/_search?pretty’</p><p>删除索引：curl -XDELETE ‘172.16.48.1:9200/posts’</p><p>​    iostat -x 3</p><p>​    sar -n DEV 3</p><p>Ip addr show 查看本机ip</p><p>curl -X PUT 172.16.48.1:9200/posts  -H ‘Content-Type: application/json’ -d ‘{“settings”: {“number_of_shards”: 3,”number_of_replicas”: “0”}}’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看全部索引：curl -XGET ‘172.16.48.1:9200/_cat/indices?v’&lt;/p&gt;
&lt;p&gt;查看索引数据：curl -XGET ‘172.16.48.1:9200/posts/_search?pretty’&lt;/p&gt;
&lt;p&gt;删除索引：curl -XD
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go语言闭包</title>
    <link href="http://yoursite.com/2020/08/19/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2020/08/19/go语言闭包/</id>
    <published>2020-08-19T11:57:10.000Z</published>
    <updated>2020-09-22T02:15:16.730Z</updated>
    
    <content type="html"><![CDATA[<p>删除当前行 command + shift + k</p><p>向上/向下复制当前行 shift + alt + ⏬/⏫</p><p>补全代码 alt + /</p><p>快速修复 alt + /</p><p>快速格式化代码 shift + alt + f</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;删除当前行 command + shift + k&lt;/p&gt;
&lt;p&gt;向上/向下复制当前行 shift + alt + ⏬/⏫&lt;/p&gt;
&lt;p&gt;补全代码 alt + /&lt;/p&gt;
&lt;p&gt;快速修复 alt + /&lt;/p&gt;
&lt;p&gt;快速格式化代码 shift + alt + f&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go语言值传递和引用传递</title>
    <link href="http://yoursite.com/2020/08/18/go%E8%AF%AD%E8%A8%80%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2020/08/18/go语言值传递和引用传递/</id>
    <published>2020-08-18T11:57:10.000Z</published>
    <updated>2020-08-19T02:25:44.280Z</updated>
    
    <content type="html"><![CDATA[<p>其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。</p><a id="more"></a><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>1) 值类型:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；变量直接存储的值；内存通常在栈中分配；</p><p>2) 引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型 ；变量存储的是一个地址，这个地址存储最终的值；内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，通过GC回收；</p><h3 id="值传递和引用传递使用特点"><a href="#值传递和引用传递使用特点" class="headerlink" title="值传递和引用传递使用特点"></a>值传递和引用传递使用特点</h3><p>定义了一个数组a，它是值类型，复制给b是copy，当b发生变化后a并不会发生任何变化；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go语言defer详解</title>
    <link href="http://yoursite.com/2020/08/17/go%E8%AF%AD%E8%A8%80defer%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/17/go语言defer详解/</id>
    <published>2020-08-17T11:57:10.000Z</published>
    <updated>2020-08-18T01:09:50.970Z</updated>
    
    <content type="html"><![CDATA[<p>在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p><a id="more"></a><p>为了更好的学习defer的行为，我们首先来看下面一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">written, err = io.Copy(dst, src)</span><br><span class="line">dst.Close()</span><br><span class="line">src.Close()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以运行，但存在’安全隐患’。如果调用dst, err := os.Create(dstName)失败，则函数会执行return退出运行。但之前创建的src(文件句柄)没有被释放。 上面这段代码很简单，所以我们可以一眼看出存在文件未被释放的问题。 如果我们的逻辑复杂或者代码调用过多时，这样的错误未必会被及时发现。 而使用defer则可以避免这种情况的发生，下面是使用defer的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer src.Close()</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dst.Close()</span><br><span class="line"></span><br><span class="line">return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过defer，我们可以在代码中优雅的关闭/清理代码中所使用的变量。defer作为golang清理变量的特性，有其独有且明确的行为。以下是defer三条使用规则。</p><h2 id="规则一-当defer被声明时，其参数就会被实时解析"><a href="#规则一-当defer被声明时，其参数就会被实时解析" class="headerlink" title="规则一 当defer被声明时，其参数就会被实时解析"></a>规则一 当defer被声明时，其参数就会被实时解析</h2><p>我们通过以下代码来解释这条规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们说过，defer函数会在return之后被调用。那么这段函数执行完之后，是不用应该输出1呢？</p><p>读者自行编译看一下，结果输出的是0. why？</p><p>这是因为虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量(i)在defer被声明的时候，就已经确定其确定的值了。 换言之，上面的代码等同于下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(0) //因为i=0，所以此时就明确告诉golang在程序退出时，执行输出0的操作</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更为明确的说明这个问题，我们继续定义一个defer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i) //输出0，因为i此时就是0</span><br><span class="line">i++</span><br><span class="line">defer fmt.Println(i) //输出1，因为i此时就是1</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行结果，可以看到defer输出的值，就是定义时的值。<strong>而不是defer真正执行时的变量值(很重要，搞不清楚的话就会产生于预期不一致的结果)</strong></p><p>但为什么是先输出1，在输出0呢？ 看下面的规则二。</p><h2 id="规则二-defer执行顺序为先进后出"><a href="#规则二-defer执行顺序为先进后出" class="headerlink" title="规则二 defer执行顺序为先进后出"></a>规则二 defer执行顺序为先进后出</h2><p>当同时定义了多个defer代码块时，golang安装<strong>先定义后执行</strong>的顺序依次调用defer。不要为什么，golang就是这么定义的。我们用下面的代码加深记忆和理解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func b() &#123;</span><br><span class="line">for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">defer fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环中，依次定义了四个defer代码块。结合规则一，我们可以明确得知每个defer代码块应该输出什么值。 安装先进后出的原则，我们可以看到依次输出了3210.</p><h2 id="规则三-defer可以读取有名返回值"><a href="#规则三-defer可以读取有名返回值" class="headerlink" title="规则三 defer可以读取有名返回值"></a>规则三 defer可以读取有名返回值</h2><p>先看下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func c() (i int) &#123;</span><br><span class="line">defer func() &#123; i++ &#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是2. 在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢….)。</p><p>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p><p>掌握了defer以上三条使用规则，那么当我们遇到defer代码块时，就可以明确得知defer的预期结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go基础知识</title>
    <link href="http://yoursite.com/2020/08/16/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/08/16/go基础知识/</id>
    <published>2020-08-16T11:57:10.000Z</published>
    <updated>2020-09-22T02:28:07.017Z</updated>
    
    <content type="html"><![CDATA[<ul><li>go语言中“++”、“–”从运算符降级为语句；</li><li>Golang 的++ 和 – 只能写在变量的后面，不能写在变量的前面，即:只有 a++ a– 没有 ++a –a</li><li>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；</li><li>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的；</li><li>字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的；</li><li>Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换；</li><li>被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化；</li><li>值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推；</li><li>值类型包括:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；</li><li>引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型；</li><li>值类型:变量直接存储值，内存通常在栈中分配；</li><li>引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆 上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收;</li><li>case/switch 后是一个表达式( 即:常量值、变量、一个有返回值的函数等都可以);</li><li>break 语句用于终止某个语句块的执行，用于中断当前 for 循环（不再执行余下的循环）或跳出 switch 语句；</li></ul><a id="more"></a><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;go语言中“++”、“–”从运算符降级为语句；&lt;/li&gt;
&lt;li&gt;Golang 的++ 和 – 只能写在变量的后面，不能写在变量的前面，即:只有 a++ a– 没有 ++a –a&lt;/li&gt;
&lt;li&gt;Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；&lt;/li&gt;
&lt;li&gt;字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的；&lt;/li&gt;
&lt;li&gt;字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的；&lt;/li&gt;
&lt;li&gt;Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换；&lt;/li&gt;
&lt;li&gt;被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化；&lt;/li&gt;
&lt;li&gt;值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推；&lt;/li&gt;
&lt;li&gt;值类型包括:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；&lt;/li&gt;
&lt;li&gt;引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型；&lt;/li&gt;
&lt;li&gt;值类型:变量直接存储值，内存通常在栈中分配；&lt;/li&gt;
&lt;li&gt;引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆 上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收;&lt;/li&gt;
&lt;li&gt;case/switch 后是一个表达式( 即:常量值、变量、一个有返回值的函数等都可以);&lt;/li&gt;
&lt;li&gt;break 语句用于终止某个语句块的执行，用于中断当前 for 循环（不再执行余下的循环）或跳出 switch 语句；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go指针</title>
    <link href="http://yoursite.com/2020/08/15/go%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/08/15/go指针/</id>
    <published>2020-08-15T11:57:10.000Z</published>
    <updated>2020-09-22T02:27:33.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识指针地址和指针类型"><a href="#认识指针地址和指针类型" class="headerlink" title="认识指针地址和指针类型"></a>认识指针地址和指针类型</h2><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。</p><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加<code>&amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight plain"><figcaption><span>:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为`*T`，称做 T 的指针类型，`*`代表指针。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">指针实际用法，可以通过下面的例子了解：</span><br></pre></td></tr></table></figure><p>package main<br>import (<br>    “fmt”<br>)<br>func main() {<br>    var cat int = 1<br>    var str string = “banana”<br>    fmt.Printf(“%p %p”, &amp;cat, &amp;str)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>0xc042052088 0xc0420461b0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 8 行，声明整型变量 cat。</span><br><span class="line">- 第 9 行，声明字符串变量 str。</span><br><span class="line">- 第 10 行，使用 fmt.Printf 的动词`%p`打印 cat 和 str 变量的内存地址，指针的值是带有`0x`十六进制前缀的一组数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</span><br><span class="line"></span><br><span class="line">## 从指针获取指针指向的值</span><br><span class="line"></span><br><span class="line">当使用`&amp;`操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用`*`操作符，也就是指针取值，代码如下。</span><br></pre></td></tr></table></figure><p>package main<br>import (<br>    “fmt”<br>)<br>func main() {<br>    // 准备一个字符串类型<br>    var house = “Malibu Point 10880, 90265”<br>    // 对字符串取地址, ptr类型为*string<br>    ptr := &amp;house<br>    // 打印ptr的类型<br>    fmt.Printf(“ptr type: %T\n”, ptr)<br>    // 打印ptr的指针地址<br>    fmt.Printf(“address: %p\n”, ptr)<br>    // 对指针进行取值操作    value := *ptr<br>    // 取值后的类型<br>    fmt.Printf(“value type: %T\n”, value)<br>    // 指针取值后就是指向变量的值<br>    fmt.Printf(“value: %s\n”, value)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>ptr type: *string<br>address: 0xc0420401b0<br>value type: string<br>value: Malibu Point 10880, 90265</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 10 行，准备一个字符串并赋值。</span><br><span class="line">- 第 13 行，对字符串取地址，将指针保存到变量 ptr 中。</span><br><span class="line">- 第 16 行，打印变量 ptr 的类型，其类型为 *string。</span><br><span class="line">- 第 19 行，打印 ptr 的指针地址，地址每次运行都会发生变化。</span><br><span class="line">- 第 22 行，对 ptr 指针变量进行取值操作，变量 value 的类型为 string。</span><br><span class="line">- 第 25 行，打印取值后 value 的类型。</span><br><span class="line">- 第 28 行，打印 value 的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">取地址操作符`&amp;`和取值操作符`*`是一对互补操作符，`&amp;`取出地址，`*`根据地址取出地址指向的值。</span><br><span class="line"></span><br><span class="line">变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</span><br><span class="line"></span><br><span class="line">- 对变量进行取地址操作使用`&amp;`操作符，可以获得这个变量的指针变量。</span><br><span class="line">- 指针变量的值是指针地址。</span><br><span class="line">- 对指针变量进行取值操作使用`*`操作符，可以获得指针变量指向的原变量的值。</span><br><span class="line"></span><br><span class="line">## 使用指针修改值</span><br><span class="line"></span><br><span class="line">通过指针不仅可以取值，也可以修改值。</span><br><span class="line"></span><br><span class="line">前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</span><br></pre></td></tr></table></figure><p>package main<br>import “fmt”<br>// 交换函数<br>func swap(a, b *int) {<br>        // 取a指针的值, 赋给临时变量t<br>        t := *a<br>        // 取b指针的值, 赋给a指针指向的变量<br>        *a = *b<br>        // 将a指针的值赋给b指针指向的变量<br>        *b = t<br>}<br>func main() {<br>            // 准备两个变量, 赋值1和2<br>            x, y := 1, 2<br>            // 交换变量值<br>            swap(&amp;x, &amp;y)<br>            // 输出变量值<br>            fmt.Println(x, y)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>2 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 6 行，定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。</span><br><span class="line">- 第 9 行，取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。</span><br><span class="line">- 第 12 行，取 b 的指针值，赋给指针 a 指向的变量。注意，此时`*a`的意思不是取 a 指针的值，而是“a 指向的变量”。</span><br><span class="line">- 第 15 行，将 t 的值赋给指针 b 指向的变量。</span><br><span class="line">- 第 21 行，准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。</span><br><span class="line">- 第 24 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。</span><br><span class="line">- 第 27 行，交换完毕时，输出 x 和 y 的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`*`操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，`*`操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</span><br><span class="line"></span><br><span class="line">如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</span><br></pre></td></tr></table></figure><p>package main<br>import “fmt”<br>func swap(a, b *int) {<br>        b, a = a, b<br>}<br>func main() {<br>        x, y := 1, 2<br>        swap(&amp;x, &amp;y)<br>        fmt.Println(x, y)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>1 2<br>```</p><p>结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识指针地址和指针类型&quot;&gt;&lt;a href=&quot;#认识指针地址和指针类型&quot; class=&quot;headerlink&quot; title=&quot;认识指针地址和指针类型&quot;&gt;&lt;/a&gt;认识指针地址和指针类型&lt;/h2&gt;&lt;p&gt;一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 
      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go中new和make区别</title>
    <link href="http://yoursite.com/2020/08/14/go%E4%B8%ADnew%E5%92%8Cmake%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/08/14/go中new和make区别/</id>
    <published>2020-08-14T11:57:10.000Z</published>
    <updated>2020-08-26T03:14:03.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/14/go中new和make区别/aaa.png" alt></p><p>Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二者都是用来分配空间.</p><p>Go 语言中 new 和 make 是内建的两个函数，主要用来创建分配类型内存. 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用.</p><a id="more"></a><h2 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h2><p>new (T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T, 该指针指向 T 的新分配的零值.</p><p>new 要点</p><ul><li>内置函数 new 分配空间.</li><li>传递给 new 函数的是一个类型，不是一个值.</li><li>返回值是 指向这个新分配的零值的指针.</li></ul><h2 id="2-make"><a href="#2-make" class="headerlink" title="2. make"></a>2. make</h2><p>make (T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T, 是经过初始化之后的 T 的引用. make 也是内建函数，你可以从 <a href="http://golang.org/pkg/builtin/#make" target="_blank" rel="noopener">http://golang.org/pkg/builtin/#make</a> 看到它， 它的函数原型 比 new 多了一个（长度）参数，返回值也不同.</p><p><strong><em>make 只能用于 slice,map,channel 三种类型\</em></strong> , 并且只能是这三种对象。和 new 一样，第一个参数是 类型，不是一个值. 但是 make 的返回值就是这个类型（即使一个引用类型）, 而不是指针。具体的返回值，依赖具体传入的类型.</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>new (T) 返回 T 的指针 *T 并指向 T 的零值.</li><li>make (T) 返回的初始化的 T, 只能用于 slice,map,channel, 要获得一个显式的指针，使用 new 进行分配，或者显式地使用一个变量的地址.</li><li>new 函数分配内存，make 函数初始化；</li></ul><p>下图给出了区别：</p><p><img src="/2020/08/14/go中new和make区别/bbb.png" alt></p><p>new 和 make 区别代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := new([]int) //p == nil; with len and cap 0</span><br><span class="line">    fmt.Println(p)</span><br><span class="line"></span><br><span class="line">    v := make([]int, 10, 50) // v is initialed with len 10, cap 50</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"></span><br><span class="line">    /*********Output****************</span><br><span class="line">        &amp;[]</span><br><span class="line">        [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">    *********************************/</span><br><span class="line"></span><br><span class="line">    (*p)[0] = 18        // panic: runtime error: index out of range</span><br><span class="line">                        // because p is a nil pointer, with len and cap 0</span><br><span class="line">    v[1] = 18           // ok</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/08/14/go中new和make区别/aaa.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二者都是用来分配空间.&lt;/p&gt;
&lt;p&gt;Go 语言中 new 和 make 是内建的两个函数，主要用来创建分配类型内存. 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用.&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>kill掉多个进程</title>
    <link href="http://yoursite.com/2020/08/11/kill%E6%8E%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/kill掉多个进程/</id>
    <published>2020-08-11T11:57:10.000Z</published>
    <updated>2020-08-11T07:06:29.091Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep beh-oss-minio-test-1.0-SNAPSHOT.jar | grep -v grep| awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux、进程" scheme="http://yoursite.com/tags/Linux%E3%80%81%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux下定时任务命令</title>
    <link href="http://yoursite.com/2020/08/10/linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/08/10/linux下定时任务命令/</id>
    <published>2020-08-10T11:57:10.000Z</published>
    <updated>2020-08-11T08:34:32.055Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、定时任务" scheme="http://yoursite.com/categories/Linux%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>grep命令使用</title>
    <link href="http://yoursite.com/2020/08/09/grep%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/09/grep命令使用/</id>
    <published>2020-08-09T11:57:10.000Z</published>
    <updated>2020-08-11T09:00:54.784Z</updated>
    
    <content type="html"><![CDATA[<p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、以递归的方式查找符合条件的文件。例如，查找指定目录 /etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串 “update” 的文件，并打印出该字符串所在行的内容，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update /etc/acpi</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update</span><br></pre></td></tr></table></figure><p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过 “-v” 参数可以打印出不符合条件行的内容。</p><p>查找文件名中包含 test 的文件中不包含 test 的行，此时，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure><p><strong>查找指定进程个数</strong></p><p><strong>命令：</strong></p><p>ps -ef|grep svn -c</p><p>ps -ef|grep -c svn</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef|grep svn -c</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ps -ef|grep -c svn </span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>从文件中读取关键词进行搜索</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -f test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -f test2.txt</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行</p><p><strong>从文件中读取关键词进行搜索 且显示行号</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -nf test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -nf test2.txt</span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">6:Redhat</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行，并显示每一行的行号</p><p><strong>从文件中查找关键词</strong></p><p><strong>命令：</strong></p><p>grep ‘linux’ test.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# grep &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# grep -n &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>找出以u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^u</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^u</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出非 u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^[^u]</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^[^u]</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出以 hat 结尾的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep hat$</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep hat$</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>显示包含 ed 或者 at 字符的内容行</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep -E “ed|at”</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;peida|com&quot;</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;ed|at&quot;</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grep test *file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;结果如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:Linux test #列出testfile_2 文件中包含test字符的行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux、grep" scheme="http://yoursite.com/categories/Linux%E3%80%81grep/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>sed命令使用</title>
    <link href="http://yoursite.com/2020/08/08/sed%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/08/sed命令使用/</id>
    <published>2020-08-08T11:57:10.000Z</published>
    <updated>2020-08-11T08:28:58.506Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、sed" scheme="http://yoursite.com/categories/Linux%E3%80%81sed/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>awk命令使用</title>
    <link href="http://yoursite.com/2020/08/07/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/07/awk命令使用/</id>
    <published>2020-08-07T11:57:10.000Z</published>
    <updated>2020-08-12T03:25:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>./java -jar /home/bdc/beh-oss.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin filetest 5.flv19 single</p><p>java -jar /home/bdc/beh-oss-minio-test-1.0-SNAPSHOT.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /home/bdc/test uploa<br>ad 10 10 10 420000</p><p>./mc ls mycloud/filetest/6.xml | wc -l</p><p>#!/bin/bash</p><p>sum_num=300000<br>for((i=0;i&lt;=10;i++));do<br>  echo $sum_num</p><p>  #java -cp beh-oss-minio-test-1.0-SNAPSHOT.jar com.bonc.beh.oss.MinioTest <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /opt/beh/core/MinIO/alone/ upload 10 10 10 $sum_num<br>  sum_num=<code>expr 10000 + $sum_num</code><br>done</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;./java -jar /home/bdc/beh-oss.jar &lt;a href=&quot;http://172.16.48.1:8000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://172.16.48.1:8000&lt;/a&gt; minioadmin
      
    
    </summary>
    
    
      <category term="Linux、awk" scheme="http://yoursite.com/categories/Linux%E3%80%81awk/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux上CPU内存使用查看</title>
    <link href="http://yoursite.com/2020/08/06/linux%E4%B8%8ACPU%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2020/08/06/linux上CPU内存使用查看/</id>
    <published>2020-08-06T11:57:10.000Z</published>
    <updated>2020-08-07T01:16:16.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top 命令的显示结果如下所示：</span><br><span class="line"></span><br><span class="line">top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 </span><br><span class="line">Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie </span><br><span class="line">Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si </span><br><span class="line">Mem: 191272k total, 173656k used, 17616k free, 22052k buffers </span><br><span class="line">Swap: 192772k total, 0k used, 192772k free, 123988k cached </span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </span><br><span class="line">1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd </span><br><span class="line">14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top </span><br><span class="line">1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init </span><br><span class="line">2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 </span><br><span class="line">3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>统计信息区</strong></p><p>前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p><table><thead><tr><th>01:06:48</th><th>当前时间</th></tr></thead><tbody><tr><td>up 1:22</td><td>系统运行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值。</td></tr></tbody></table><p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用 CPU 百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用 CPU 百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>98.7% id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><p>最后两行为内存信息。内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。 相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><p><strong><em>free [选项]</em></strong></p><p><strong>默认情况下，即在没有选项的情况下，\</strong>“*<em>free”命令显示内存的使用信息。默认按照k（b）的计数单位统计。*</em></p><ul><li>total：表示 总计物理内存的大小。</li><li>used：表示 已使用多少。</li><li>free：表示 可用内存多少。</li><li>Shared：表示多个进程共享的内存总额。</li><li>Buffers/cached：表示 磁盘缓存的大小。</li></ul><p><strong>注意：free命令的选项区分大小写，请认真对照上图中是大写还是小写</strong></p><ol><li>free -b：以bytes为单位来显示内存的信息。</li><li>free -k：以kb为单位来显示内存的信息。</li><li>free -m：以m为单位来显示内存的信息。</li><li>free -g：以G为单位来显示内存的信息。</li><li>free -h：以适于人类可读方式显示内存信息。-h与其他命令最大不同是<strong>-h</strong>选项会在数字后面加上适于人类可读的单位</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;top命令&quot;&gt;&lt;a href=&quot;#top命令&quot; class=&quot;headerlink&quot; title=&quot;top命令&quot;&gt;&lt;/a&gt;top命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;top 命令的显示结果如下所示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mem: 191272k total, 173656k used, 17616k free, 22052k buffers &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swap: 192772k total, 0k used, 192772k free, 123988k cached &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>NERDTree快捷键</title>
    <link href="http://yoursite.com/2020/07/23/NERDTree%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/23/NERDTree快捷键/</id>
    <published>2020-07-23T11:57:10.000Z</published>
    <updated>2020-08-04T09:35:20.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换工作台和目录"><a href="#切换工作台和目录" class="headerlink" title="切换工作台和目录"></a>切换工作台和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><h3 id="NerdTree-在-vimrc-中的常用配置"><a href="#NerdTree-在-vimrc-中的常用配置" class="headerlink" title="NerdTree 在 .vimrc 中的常用配置"></a>NerdTree 在 .vimrc 中的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="line">autocmd VimEnter * NERDTree</span><br><span class="line"></span><br><span class="line">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class="line">map  :silent! NERDTreeToggle</span><br><span class="line"></span><br><span class="line">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;切换工作台和目录&quot;&gt;&lt;a href=&quot;#切换工作台和目录&quot; class=&quot;headerlink&quot; title=&quot;切换工作台和目录&quot;&gt;&lt;/a&gt;切换工作台和目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + h    光标 focus 左侧树形目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + l    光标 focus 右侧文件显示窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + w    光标自动在左右侧窗口切换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + r    移动当前窗口的布局位置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>MacVim编辑器使用</title>
    <link href="http://yoursite.com/2020/07/22/MacVim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/22/MacVim编辑器使用/</id>
    <published>2020-07-22T11:57:10.000Z</published>
    <updated>2020-09-18T03:31:03.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式区分"><a href="#Vim-模式区分" class="headerlink" title="Vim 模式区分"></a>Vim 模式区分</h3><h5 id="普通模式-Normal-mode"><a href="#普通模式-Normal-mode" class="headerlink" title="普通模式 (Normal mode)"></a>普通模式 (Normal mode)</h5><ul><li>Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑</li></ul><h5 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h5><ul><li>该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.</li></ul><h5 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h5><ul><li>与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式</li></ul><h5 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h5><ul><li>新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)</li></ul><h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><ul><li>在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启</li></ul><a id="more"></a><h3 id="元字符的存在"><a href="#元字符的存在" class="headerlink" title="元字符的存在"></a>元字符的存在</h3><p>元字符是 Vim 对模糊匹配的一个附加属性，通过元字符可以快速找出目标字段.</p><ul><li><code>.</code>: 表示匹配任意 <strong>一个</strong> 字符。例: <code>c..l</code> 表示任意以 c 开头，中间有两个任意字符，l 结尾的字段.</li><li><code>.*</code>: 表示匹配 <strong>任意多个</strong> 字符。例: <code>c.*l</code> 表示任意以 c 开头 l 结尾的字段 (不会将一个字段进行跨行处理，因此非常智能，很频繁使用)</li><li><code>$</code>: 匹配行尾。例: <code>/d.*$</code> 表示匹配到以 d 开头到行尾中的所有内容，<code>/123$</code> 表示以 123 结尾的所有字段</li><li><code>^</code>: 匹配行首。例: <code>^.*d</code> 表示匹配到行首到 d 的所有内容，<code>/^123</code> 表示以 123 开头的字段</li><li><code>\&lt;</code> : 匹配单词词首</li><li><code>\&gt;</code>: 匹配单词词尾。例: <code>/\&lt;f\&gt;</code> 表示只匹配 <code>f</code> 单词，如果其前有任何字符它就不是单词，不会被匹配到.</li><li><code>\( \)</code>: 括号内的内容可以在后面被引用，引用方式为 <code>\1</code>, <code>\2</code></li><li><code>*</code>: 表示其前字符可以重复 0~ 无数 次。如 <code>/be*</code> 会匹配到 <code>b</code>, <code>be</code>, <code>bee</code> …, 因为 e 重复零次就是没有，所以会返回 b</li><li><code>\+</code>: 表示其前字符必须重复 1~ 无数 次，如 <code>/be\+</code> 会匹配到 <code>be</code>, <code>bee</code>, <code>beee</code> …</li><li><code>\=</code>: 代表其前字符必须重复 0 或者 1 次.</li><li><code>\{n,m}</code> : 其前字符必须重复 n 到 m 次</li><li><code>[adz]</code>: 匹配 <code>a</code>, <code>d</code>, <code>z</code> 中的任意 <strong>一个</strong> , 括号内也可是数字，如 <code>[2-5]</code> 表示匹配 <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> 中的任意一个数字</li><li><code>\|</code>; 或的意思，表示只要符合其前或其后任意一个字符即可。例: <code>/one\|two\|three</code> 表示匹配 one, two, three 中的任意一个. <code>end\(if\|while\|for\)</code> 表示会查找到 endif, endwhile, endfor 中的任意一个.</li><li><code>[^a]</code>: 匹配除 <code>a</code> 以外的任意 <strong>字符</strong></li><li><code>[a-c]</code>: 匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个，递增的顺序</li><li><code>\d</code>: 匹配十进制数字中的任意一个，等同于 <code>[0-9]</code>. 例: <code>/\d\d:\d\d:\d\d</code> 表示查找如 <code>17:31:00</code> 格式的字符</li><li><code>\D</code>: 匹配除十进制数字外的任意一个字符，等同于 <code>[^0-9]</code></li><li><code>\x</code>: 匹配十六进制数字中的任意一个，等同于 <code>[0-9A-Fa-f]</code></li><li><code>\X</code>: 匹配除十六进制数字外的任意一个字符，等同于 <code>[^0-9A-Fa-f]</code></li><li><code>\w</code>: 匹配一个单词 (对中文来说非常鸡肋，因为只有 Vim 判定是单词的才会进行匹配，与 <code>w</code>, <code>b</code>, <code>e</code> , 的匹配规则相同)</li><li><code>\W</code>: 匹配除单词外的所有字符。因为在 vim 中中文全部不被认为是单词，因此，此匹配会选中所有中文字段.</li><li><code>\t</code>: 匹配 tab , 可使用此方法将所有 tab 替换为空格</li><li><code>\s</code>: 匹配空白字段，包含 tab 与空格，在 pattern 中使用此查找空白，在 string 中就可以直接使用空格或者 tab 来输入以替换了</li><li><code>\S</code>: 匹配非空白字段，等同于 <code>[^\s]</code></li><li><code>\n</code>: 匹配换行符</li><li><code>\r</code>: 换行，在 pattern 中使用 <code>\n</code> 作为搜索串，在 string 中使用 <code>\r</code> 作为换行命令 (如果在 string 中仍然使用 \n 的话会出错)</li><li><code>\_s</code>: 匹配换行或空白</li><li><code>\_a</code>: 匹配换行或单词 (因为是单词，vim 不会匹配中文)</li><li><code>\C</code>: 区分大小写地查找或替换，例: <code>/\CText</code> 表示只会查找 <code>Text</code>, 不会查找 <code>text</code> 或 <code>tExt</code> 等</li><li><code>\c</code>: 不区分大小写地查找替换 (已经在 vim 中设置了默认不区分了)</li></ul><p>如上所述，<code>.</code>, <code>*</code>, <code>[</code>, <code>]</code>, <code>^</code>, <code>%</code>, <code>/</code>, <code>?</code>, <code>~</code>, <code>$</code> 这十个字符有特殊含义，如果对这十个字符进行匹配，需要添加 <code>\</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h5 id="查找逻辑"><a href="#查找逻辑" class="headerlink" title="查找逻辑"></a>查找逻辑</h5><ul><li><code>/单词</code>: 全文查找 view 关键字 (n 为向下方向)</li><li><code>/\c单词</code>: 全文查找 view 关键字 (大小写不敏感)</li><li><code>?单词</code>: 全文查找 view 关键字 (n 为向上方向)</li><li><code>:noh</code> : 退出查找模式</li><li><code>*</code>: 全文查找光标处词组 (n 为向下方向)</li><li><code>#</code>: 全文查找光标处词组 (n 为向上方向)</li><li><code>n</code>: 下一个列出的关键字</li><li><code>N</code>: 上一个列出的关键字</li></ul><h5 id="查找实例"><a href="#查找实例" class="headerlink" title="查找实例"></a>查找实例</h5><p><code>/\&lt;单词\&gt;</code>: 查找只为 <code>单词</code> 的字符</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>假如有这么一行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thee best time to see thee flowers is in thee spring.</span><br></pre></td></tr></table></figure><ul><li>当我键入<code>:s/thee/the &lt;回车&gt;</code>，那么该行的第一 <code>thee</code> 就被我替换成了 <code>the</code></li><li>如果想将所有的 <code>thee</code> 替换，可以键入<code>:s/thee/the/g</code></li><li>要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :% s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :% s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li></ul><h2 id="文本编辑之删除"><a href="#文本编辑之删除" class="headerlink" title="文本编辑之删除"></a>文本编辑之删除</h2><p>只需要将光标移动到你想要删除的文本位置，按下 <code>x</code> 键即可</p><blockquote><p>提示：当我对某个操作不满意，想要撤回的时候，只要键入 u 即可</p></blockquote><h2 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h2><p>简单来说，如果我想要删除一个单词只需要键入 <code>dw</code>，如果我键入 <code>d$</code>，那么这一整行的内容都被我删了(dd也可以达到相同的效果)</p><h2 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h2><p><strong><em>假如 vim 打开的文件中某一个行有这样一句的内容</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is just a line with words you can move around in.</span><br></pre></td></tr></table></figure><p>我的光标在开头的 T 位置</p><ul><li>键入一次 e，我的光标位置就会出现在 This 这个单词的末尾 s 处，键入两次，就会出现在下一个单词的末尾。</li><li>键入 w，就会出现在下一个单词的开头，多次键入与 e 的效果雷同。</li><li>键入 0(数字0)，能使我的光标出现在行首。</li><li>键入 $，能使我的光标出现在行末。</li></ul><h2 id="使用计数已删除更多"><a href="#使用计数已删除更多" class="headerlink" title="使用计数已删除更多"></a>使用计数已删除更多</h2><p>上面已经提到过删除操作符和动作的组合，你可以在组合中动作之前插入一个数字以删除更多</p><p> d number (数字) motion</p><p>比如键入 <code>d2w</code>，我们就可以删除光标所在位置起的两个单词</p><h2 id="操作整行"><a href="#操作整行" class="headerlink" title="操作整行"></a>操作整行</h2><ul><li>之前用 <code>d$</code> 命令删除整行内容后，我们会发现这一行变成了一个空行，所以可能用清除整行内容来称呼它更加合适</li><li>如果我们要删除当前行，可以键入 <code>dd</code> 命令</li><li>你也可以键入 <code>2dd</code>，来删除当前行起的两行(向下)</li></ul><h2 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h2><ul><li>之前有提到过，如果你操作失误，可以键入 <code>u</code> 来撤销最后一次执行的命令</li><li>如果你嫌一次一次的撤销太麻烦，你可以键入 <code>U</code>，来使当前行恢复到初始状态</li></ul><h2 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h2><p>之前所说的 <code>dd</code> 命令删除了一整行内容，其实呢，并没有消失，而是保存在了 vim 的寄存器中。</p><ul><li>当使用 <code>dd</code> 命令删除了某一行内容后，光标移到某一行，键入 <code>p</code>，刚刚删除掉的那一行内容就会粘贴到当前行的下一行了</li></ul><h2 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h2><ul><li>键入 <code>cw</code>，然后输入正确的内容，我们就可以更改整个单词了。</li></ul><h2 id="复制一行"><a href="#复制一行" class="headerlink" title="复制一行"></a>复制一行</h2><ul><li><code>yy</code> 复制光标所在位置的一行， <code>yw</code>复制光标所在的单词， 使用<code>p</code>进行粘贴；</li></ul><h2 id="在-vim-内执行外部命令的方法"><a href="#在-vim-内执行外部命令的方法" class="headerlink" title="在 vim 内执行外部命令的方法"></a>在 vim 内执行外部命令的方法</h2><p>再用 vim 编程的时候，如果我想输入一个外部命令怎么办，难道我还需要新建个终端窗口吗？当然不需要</p><p>1、 按下我们所熟悉的 <code>:</code> 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。</p><p>2、 接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3、 我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样</p><p>经常遇到这样的场景，复制多行，然后粘贴。</p><ol><li>将光标移动到要复制的文本开始的地方，按<code>v</code>进入可视模式。</li><li>将光标移动到要复制的文本的结束的地方，按 y 复制。此时 vim 会自动将光标定位到选中文本的开始的地方，并退出可视模式。</li><li>我移动光标到文本结束的地方，按<code>p</code>粘贴。</li></ol><p>[参考链接]<a href="https://ruby-china.org/topics/4266" target="_blank" rel="noopener">https://ruby-china.org/topics/4266</a></p><p>[参考链接]<a href="https://juejin.im/post/5aed4b0651882567127868df#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5aed4b0651882567127868df#heading-14</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vim-模式区分&quot;&gt;&lt;a href=&quot;#Vim-模式区分&quot; class=&quot;headerlink&quot; title=&quot;Vim 模式区分&quot;&gt;&lt;/a&gt;Vim 模式区分&lt;/h3&gt;&lt;h5 id=&quot;普通模式-Normal-mode&quot;&gt;&lt;a href=&quot;#普通模式-Normal-mode&quot; class=&quot;headerlink&quot; title=&quot;普通模式 (Normal mode)&quot;&gt;&lt;/a&gt;普通模式 (Normal mode)&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;插入模式&quot;&gt;&lt;a href=&quot;#插入模式&quot; class=&quot;headerlink&quot; title=&quot;插入模式&quot;&gt;&lt;/a&gt;插入模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;可视模式&quot;&gt;&lt;a href=&quot;#可视模式&quot; class=&quot;headerlink&quot; title=&quot;可视模式&quot;&gt;&lt;/a&gt;可视模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;替换模式&quot;&gt;&lt;a href=&quot;#替换模式&quot; class=&quot;headerlink&quot; title=&quot;替换模式&quot;&gt;&lt;/a&gt;替换模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;命令行模式&quot;&gt;&lt;a href=&quot;#命令行模式&quot; class=&quot;headerlink&quot; title=&quot;命令行模式&quot;&gt;&lt;/a&gt;命令行模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>使用VIM打开文件报错</title>
    <link href="http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8VIM%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/21/使用VIM打开文件报错/</id>
    <published>2020-07-21T11:57:10.000Z</published>
    <updated>2020-08-18T01:01:00.021Z</updated>
    
    <content type="html"><![CDATA[<p>下载完vim的主题之后打开文件报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /Users/luxiaofeng/.vim/colors/molokai.vim</span><br><span class="line">Error detected while processing /Users/luxiaofeng/.vim/colors/molokai.vim:</span><br><span class="line">line   10:</span><br><span class="line">E411: highlight group not found: clear^M</span><br><span class="line">line   11:</span><br><span class="line">E15: Invalid expression: version &gt; 580^M</span><br><span class="line">line  275:</span><br><span class="line">E171: Missing :endif</span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开那个文件后：</span><br><span class="line">:set ff=unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载完vim的主题之后打开文件报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="linux、vim" scheme="http://yoursite.com/tags/linux%E3%80%81vim/"/>
    
  </entry>
  
  <entry>
    <title>vim安装插件之后的各种报错</title>
    <link href="http://yoursite.com/2020/07/20/vim%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/20/vim安装插件之后的各种报错/</id>
    <published>2020-07-20T11:57:10.000Z</published>
    <updated>2020-07-28T09:13:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件nerdtree"><a href="#安装插件nerdtree" class="headerlink" title="安装插件nerdtree"></a>安装插件nerdtree</h2><p>启动MacVim报错<code>Error detected while processing function &lt;SNR&gt;2_lod_cmd</code>或者<code>Error detected while processing function &lt;SNR&gt;3_lod_cmd</code></p><p>原因是在<code>.vimrc</code>中配置的插件为<code>Plug &#39;scrooloose/nerdtree&#39;, { &#39;on&#39;: &#39;NERDTreeToggle&#39; }</code>. 改为 <code>Plug &#39;scrooloose/nerdtree&#39;</code>之后报错消失；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装插件nerdtree&quot;&gt;&lt;a href=&quot;#安装插件nerdtree&quot; class=&quot;headerlink&quot; title=&quot;安装插件nerdtree&quot;&gt;&lt;/a&gt;安装插件nerdtree&lt;/h2&gt;&lt;p&gt;启动MacVim报错&lt;code&gt;Error detected
      
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim插件安装</title>
    <link href="http://yoursite.com/2020/07/19/Vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/07/19/Vim插件安装/</id>
    <published>2020-07-19T11:57:10.000Z</published>
    <updated>2020-08-05T01:36:27.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装vim-plug插件"><a href="#安装vim-plug插件" class="headerlink" title="安装vim-plug插件"></a>安装vim-plug插件</h2><ul><li><p>首先下载插件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:junegunn/vim-plug.git</span><br></pre></td></tr></table></figure></li><li><p>下载 plug.vim(<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a>) 并将其放在 “自动加载” 目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；</a></p></li><li><p>在<code>~/.vimrc</code>中添加一个 vim-plug 部分</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&apos;data&apos;) . &apos;/plugged&apos;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &apos;plugin&apos;</span><br><span class="line">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class="line"></span><br><span class="line">&quot; Make sure you use single quotes</span><br><span class="line"></span><br><span class="line">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br><span class="line">Plug &apos;junegunn/vim-easy-align&apos;</span><br><span class="line"></span><br><span class="line">&quot; Any valid git URL is allowed</span><br><span class="line">Plug &apos;https://github.com/junegunn/vim-github-dashboard.git&apos;</span><br><span class="line"></span><br><span class="line">&quot; Multiple Plug commands can be written in a single line using | separators</span><br><span class="line">Plug &apos;SirVer/ultisnips&apos; | Plug &apos;honza/vim-snippets&apos;</span><br><span class="line"></span><br><span class="line">&quot; On-demand loading</span><br><span class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;:  &apos;NERDTreeToggle&apos; &#125;</span><br><span class="line">Plug &apos;tpope/vim-fireplace&apos;, &#123; &apos;for&apos;: &apos;clojure&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a non-master branch</span><br><span class="line">Plug &apos;rdnetto/YCM-Generator&apos;, &#123; &apos;branch&apos;: &apos;stable&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br><span class="line">Plug &apos;fatih/vim-go&apos;, &#123; &apos;tag&apos;: &apos;*&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin options</span><br><span class="line">Plug &apos;nsf/gocode&apos;, &#123; &apos;tag&apos;: &apos;v.20150303&apos;, &apos;rtp&apos;: &apos;vim&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br><span class="line">Plug &apos;junegunn/fzf&apos;, &#123; &apos;dir&apos;: &apos;~/.fzf&apos;, &apos;do&apos;: &apos;./install --all&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Unmanaged plugin (manually installed and updated)</span><br><span class="line">Plug &apos;~/my-prototype-plugin&apos;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>重新加载.vimrc 并<code>:PlugInstall</code>安装插件,执行完成之后，使用vim打开文件有报错的话，一般是因为Windows下的换行符和Linux下的换行符不一样导致的，那个文件报错就使用vim打开那个文件，使用命令:set ff=unix修改换行符；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装vim-plug插件&quot;&gt;&lt;a href=&quot;#安装vim-plug插件&quot; class=&quot;headerlink&quot; title=&quot;安装vim-plug插件&quot;&gt;&lt;/a&gt;安装vim-plug插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载插件 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:junegunn/vim-plug.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载 plug.vim(&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/a&gt;) 并将其放在 “自动加载” 目录中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;~/.vimrc&lt;/code&gt;中添加一个 vim-plug 部分&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap1.7源码详解</title>
    <link href="http://yoursite.com/2020/07/18/ConcurrentHashMap1.7%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/18/ConcurrentHashMap1.7源码详解/</id>
    <published>2020-07-18T11:57:10.000Z</published>
    <updated>2020-07-21T09:47:02.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.</span><br></pre></td></tr></table></figure><p>大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。</p><a id="more"></a><h4 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h4><p>HashEntry 是 ConcurrentHashMap 的基础单元 (节点)，是实际数据的载体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Sets next field with volatile write semantics.  (See above</span><br><span class="line">         * about use of putOrderedObject.)</span><br><span class="line">         */</span><br><span class="line">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">            UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Unsafe mechanics</span><br><span class="line">        static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        static final long nextOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class k = HashEntry.class;</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(&quot;next&quot;));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>Segment 继承 ReentrantLock 锁，用于存放数组 HashEntry[]。在这里可以看出，无论 1.7 还是 1.8 版本，ConcurrentHashMap 底层并不是对 HashMap 的扩展，而是同样从底层基于数组 + 链表进行功能实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = 2249069246763182397L;</span><br><span class="line"></span><br><span class="line">        static final int MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line"></span><br><span class="line">        // 数据节点存储在这里(基础单元是数组)</span><br><span class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        transient int count;</span><br><span class="line"></span><br><span class="line">        transient int modCount;</span><br><span class="line"></span><br><span class="line">        transient int threshold;</span><br><span class="line"></span><br><span class="line">        final float loadFactor;</span><br><span class="line"></span><br><span class="line">        Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            this.loadFactor = lf;</span><br><span class="line">            this.threshold = threshold;</span><br><span class="line">            this.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Creates a new, empty map with a default initial capacity (16),</span><br><span class="line">* load factor (0.75) and concurrencyLevel (16).</span><br><span class="line">*/</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line">//static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 对于concurrencyLevel的理解, 可以理解为segments数组的长度，即理论上多线程并发数(分段锁), 默认16</span><br><span class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        // Find power-of-two sizes best matching arguments</span><br><span class="line">        int sshift = 0;</span><br><span class="line">        int ssize = 1;</span><br><span class="line">        // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span><br><span class="line">        // ssize = 2^sshift 即 ssize = 1 &lt;&lt; sshift</span><br><span class="line">        while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 段偏移量，32是因为hash是int值，int值32位，默认值情况下此时segmentShift = 28</span><br><span class="line">        this.segmentShift = 32 - sshift;</span><br><span class="line">        // 散列算法的掩码，默认值情况下segmentMask = 15, 定位segment的时候需要根据segment[]长度取模, 即hash(key)&amp;(ssize - 1)</span><br><span class="line">        this.segmentMask = ssize - 1;</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        // 计算每个segment中table的容量, 初始容量=16, 并发数=16。</span><br><span class="line">        int c = initialCapacity / ssize;</span><br><span class="line">        // 处理无法整除的情况，取上限</span><br><span class="line">        if (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        // MIN_SEGMENT_TABLE_CAPACITY默认时2，cap必须是2的n次方</span><br><span class="line">        int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        // 确保cap是2^n</span><br><span class="line">        while (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= 1;</span><br><span class="line">        // create segments and segments[0]</span><br><span class="line">        // 创建segments并初始化第一个segment数组,其余的segment延迟初始化</span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">        // 默认并发数=16</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br><span class="line">        this.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h4><p>put 方法实际上只有两步：1. 根据键的值定位键值对在那个 segment 片段 2. 调用 Segment 的 put 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s;</span><br><span class="line">      if (value == null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">//计算键的hash值</span><br><span class="line">      int hash = hash(key);</span><br><span class="line">//通过hash值运算把键值对定位到segment[j]片段上</span><br><span class="line">      int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">//检查segment[j]是否已经初始化了，没有的话调用ensureSegment初始化segment[j]</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br><span class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br><span class="line">          s = ensureSegment(j);</span><br><span class="line">//向片段中插入键值对</span><br><span class="line">      return s.put(key, hash, value, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;</span><br><span class="line">    int h = hashSeed;       // 这个 hashSeed 是和 虚拟机的参数有关.. 在不配置的情况下 默认为 0 . 我们就是用默认的分析吧</span><br><span class="line"></span><br><span class="line">    if ((0 != h) &amp;&amp; (k instanceof String)) &#123;    // 如果配置了参数.. 且是 String 类型的，就使用 hash32</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //k.hashCode ... 这里可以看出.. 虽然 key 没有明确判断不能为 null .. 但是 一旦是 null</span><br><span class="line">    // 这里就会空指针了...</span><br><span class="line">    h ^= k.hashCode ();      //hashmap 一样的操作..</span><br><span class="line"></span><br><span class="line">    // Spread bits to regularize both segment and index locations,</span><br><span class="line">    // using variant of single-word Wang/Jenkins hash.</span><br><span class="line">    </span><br><span class="line">    h += (h &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 10);</span><br><span class="line">    h += (h &lt;&lt;   3);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  6);</span><br><span class="line">    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ensureSegment(int k)<br>  我们从 ConcurrentHashMap 的构造函数可以发现 Segment 数组只初始化了 Segment [0], 其余的 Segment 是用到了再初始化，用了延迟加载的策略，而延迟加载调用的就是 ensureSegment 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">      final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">      long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">      Segment&lt;K,V&gt; seg;</span><br><span class="line">//按照segment[0]的HashEntry数组长度和加载因子初始化Segment[k]</span><br><span class="line">      if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</span><br><span class="line">          int cap = proto.table.length;</span><br><span class="line">          float lf = proto.loadFactor;</span><br><span class="line">          int threshold = (int)(cap * lf);</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">          if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">              == null) &#123; // recheck</span><br><span class="line">              Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">              while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                     == null) &#123;</span><br><span class="line">                  if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                      break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return seg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="put(K key, int hash, V value, boolean onlyIfAbsent)"></a>put(K key, int hash, V value, boolean onlyIfAbsent)</h4><p>调用 Segment 的 put 方法插入键值对到 Segment 的 HashEntry 数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">//Segment继承ReentrantLock，尝试获取独占锁</span><br><span class="line">      HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">              scanAndLockForPut(key, hash, value);</span><br><span class="line">      V oldValue;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">//定位键值对在HashEntry数组上的位置</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">//获取这个位置的第一个键值对</span><br><span class="line">          HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">              if (e != null) &#123;//此处有链表结构，一直循环到e==null</span><br><span class="line">                  K k;</span><br><span class="line">//存在与待插入键值对相同的键，则替换value</span><br><span class="line">                  if ((k = e.key) == key ||</span><br><span class="line">                          (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                      oldValue = e.value;</span><br><span class="line">                      if (!onlyIfAbsent) &#123;//onlyIfAbsent默认为false</span><br><span class="line">                          e.value = value;</span><br><span class="line">                          ++modCount;</span><br><span class="line">                      &#125;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">                  e = e.next;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">//node不为null,设置node的next为first，node为当前链表的头节点</span><br><span class="line">                  if (node != null)</span><br><span class="line">                      node.setNext(first);</span><br><span class="line">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span><br><span class="line">                  else</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                  int c = count + 1;</span><br><span class="line">//扩容条件 (1)entry数量大于阈值 (2) 当前数组tab长度小于最大容量。满足以上条件就扩容</span><br><span class="line">                  if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">//扩容</span><br><span class="line">                      rehash(node);</span><br><span class="line">                  else</span><br><span class="line">//tab的index位置设置为node,</span><br><span class="line">                      setEntryAt(tab, index, node);</span><br><span class="line">                  ++modCount;</span><br><span class="line">                  count = c;</span><br><span class="line">                  oldValue = null;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">场景：线程 A 和线程 B 同时执行相同 Segment 对象的 put 方法;</span><br><span class="line">线程 A 执行 tryLock () 方法成功获取锁，则把 HashEntry 对象插入到相应的位置;</span><br><span class="line">线程 B 获取锁失败，则执行 scanAndLockForPut () 方法，在 scanAndLockForPut 方法中，会通过重复执行 tryLock () 方法尝试获取锁，在多处理器环境下，重复次数为 64，单处理器重复次数为 1，当执行 tryLock () 方法的次数超过上限时，则执行 lock () 方法挂起线程 B;</span><br><span class="line">当线程 A 执行完插入操作时，会通过 unlock () 方法释放锁，接着唤醒线程 B 继续执行;</span><br></pre></td></tr></table></figure><ul><li><p>scanAndLockForPut(K key, int hash, V value)<br>在不超过最大重试次数 MAX_SCAN_RETRIES 通过 CAS 尝试获取锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">//first,e:键值对的hash值定位到数组tab的第一个键值对</span><br><span class="line">      HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">      HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">      HashEntry&lt;K,V&gt; node = null;</span><br><span class="line">      int retries = -1; // negative while locating node</span><br><span class="line">//线程尝试通过CAS获取锁</span><br><span class="line">      while (!tryLock()) &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt; f; // to recheck first below</span><br><span class="line">          if (retries &lt; 0) &#123;</span><br><span class="line">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span><br><span class="line">              if (e == null) &#123;</span><br><span class="line">                  if (node == null) // speculatively create node</span><br><span class="line">//初始化键值对，next指向null</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                  retries = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              else if (key.equals(e.key))</span><br><span class="line">                  retries = 0;</span><br><span class="line">              else</span><br><span class="line">                  e = e.next;</span><br><span class="line">          &#125;</span><br><span class="line">//超过最大自旋次数，阻塞</span><br><span class="line">          else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">              lock();</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">//头节点发生变化，重新遍历</span><br><span class="line">          else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                  (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">              e = first = f; // re-traverse if entry changed</span><br><span class="line">              retries = -1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>rehash(HashEntry&lt;K,V&gt; node)<br>用于对 Segment 的 table 数组进行扩容，扩容后的数组长度是原数组的两倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">//扩容前的旧tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">//扩容前数组长度</span><br><span class="line">      int oldCapacity = oldTable.length;</span><br><span class="line">//扩容后数组长度（扩容前两倍）</span><br><span class="line">      int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">//计算新的阈值</span><br><span class="line">      threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">//新的tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">              (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">//新的掩码</span><br><span class="line">      int sizeMask = newCapacity - 1;</span><br><span class="line">//遍历旧的数组</span><br><span class="line">      for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">//遍历数组的每一个元素</span><br><span class="line">          HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">//元素e指向的下一个节点，如果存在hash冲突那么e不为空</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//计算元素在新数组的索引</span><br><span class="line">              int idx = e.hash &amp; sizeMask;</span><br><span class="line">// 桶中只有一个元素，把当前的e设置给新的table</span><br><span class="line">              if (next == null)   //  Single node on list</span><br><span class="line">                  newTable[idx] = e;</span><br><span class="line">//桶中有布置一个元素的链表</span><br><span class="line">              else &#123; // Reuse consecutive sequence at same slot</span><br><span class="line">                  HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">// idx 是当前链表的头结点 e 的新位置</span><br><span class="line">                  int lastIdx = idx;</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                       last != null;</span><br><span class="line">                       last = last.next) &#123;</span><br><span class="line">//k是单链表元素在新数组的位置</span><br><span class="line">                      int k = last.hash &amp; sizeMask;</span><br><span class="line">                      //lastRun是最后一个扩容后不在原桶处的Entry</span><br><span class="line">                      if (k != lastIdx) &#123;</span><br><span class="line">                          lastIdx = k;</span><br><span class="line">                          lastRun = last;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">//lastRun以及它后面的元素都在一个桶中</span><br><span class="line">                  newTable[lastIdx] = lastRun;</span><br><span class="line">                  // Clone remaining nodes</span><br><span class="line">                  //遍历到lastRun即可</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                      V v = p.value;</span><br><span class="line">                      int h = p.hash;</span><br><span class="line">                      int k = h &amp; sizeMask;</span><br><span class="line">                      HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                      newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//处理引起扩容的那个待添加的节点</span><br><span class="line">      int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br><span class="line">      node.setNext(newTable[nodeIndex]);</span><br><span class="line">      newTable[nodeIndex] = node;</span><br><span class="line">//把Segment的table指向扩容后的table</span><br><span class="line">      table = newTable;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h4><p> get 获取元素不需要加锁，效率高，获取 key 定位到的 segment 片段还是遍历 table 数组的 HashEntry 元素时使用了 UNSAFE.getObjectVolatile 保证了能够无锁且获取到最新的 volatile 变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public V get(Object key) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</span><br><span class="line">      HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">//计算key的hash值</span><br><span class="line">      int h = hash(key);</span><br><span class="line">//根据hash值计算key在哪个segment片段</span><br><span class="line">      long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">//获取segments[u]的table数组</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">          (tab = s.table) != null) &#123;</span><br><span class="line">//遍历table中的HashEntry元素</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                   (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">               e != null; e = e.next) &#123;</span><br><span class="line">              K k;</span><br><span class="line">//找到相同的key，返回value</span><br><span class="line">              if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                  return e.value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>size 方法用来计算 ConcurrentHashMap 中储存元素的个数。那么在统计所有的 segment 元素的个数是否都需要上锁呢？如果不上锁在统计的过程中可能存在其他线程并发存储 / 删除元素，而如果上锁又会降低读写效率。ConcurrentHashMap 在实现时使用了折中的方法，它会无锁遍历三次把所有的 segment 的 modCount 加到 sum 里面，如果与前一次遍历结果相比 sum 没有改变那么说明这两次遍历没有其他线程修改 ConcurrentHashMap, 返回 segment 的 count 的和；如果每次遍历与上一次相比都不一样那就上锁进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> public int size() &#123;</span><br><span class="line">     // Try a few times to get accurate count. On failure due to</span><br><span class="line">     // continuous async changes in table, resort to locking.</span><br><span class="line">     final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">     int size;</span><br><span class="line">     boolean overflow; // true if size overflows 32 bits</span><br><span class="line">     long sum;         // sum of modCounts</span><br><span class="line">     long last = 0L;   // previous sum</span><br><span class="line">     int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">     try &#123;</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">//达到RETRIES_BEFORE_LOCK，也就是三次</span><br><span class="line">             if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                 for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                     ensureSegment(j).lock(); // force creation</span><br><span class="line">             &#125;</span><br><span class="line">             sum = 0L;</span><br><span class="line">             size = 0;</span><br><span class="line">             overflow = false;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                 Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">//遍历计算segment的modCount和count的和</span><br><span class="line">                 if (seg != null) &#123;</span><br><span class="line">                     sum += seg.modCount;</span><br><span class="line">                     int c = seg.count;</span><br><span class="line">//是否溢出int范围</span><br><span class="line">                     if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                         overflow = true;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">//last是上一次的sum值，相等跳出循环</span><br><span class="line">             if (sum == last)</span><br><span class="line">                 break;</span><br><span class="line">             last = sum;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">//解锁</span><br><span class="line">         if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                 segmentAt(segments, j).unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h4><p>调用 Segment 的 remove 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    return s == null ? null : s.remove(key, hash, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key-int-hash-Object-value"><a href="#remove-Object-key-int-hash-Object-value" class="headerlink" title="remove(Object key, int hash, Object value)"></a>remove(Object key, int hash, Object value)</h4><p>获取同步锁，移除指定的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  final V remove(Object key, int hash, Object value) &#123;</span><br><span class="line">//获取同步锁</span><br><span class="line">      if (!tryLock())</span><br><span class="line">          scanAndLock(key, hash);</span><br><span class="line">      V oldValue = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">          HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">//遍历链表用来保存当前链表节点的前一个节点</span><br><span class="line">          HashEntry&lt;K,V&gt; pred = null;</span><br><span class="line">          while (e != null) &#123;</span><br><span class="line">              K k;</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//找到key对应的键值对</span><br><span class="line">              if ((k = e.key) == key ||</span><br><span class="line">                      (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                  V v = e.value;</span><br><span class="line">//键值对的值与传入的value相等</span><br><span class="line">                  if (value == null || value == v || value.equals(v)) &#123;</span><br><span class="line">//当前元素为头节点，把当前元素的下一个节点设为头节点</span><br><span class="line">                      if (pred == null)</span><br><span class="line">                          setEntryAt(tab, index, next);</span><br><span class="line">//不是头节点，把当前链表节点的前一个节点的next指向当前节点的下一个节点</span><br><span class="line">                      else</span><br><span class="line">                          pred.setNext(next);</span><br><span class="line">                      ++modCount;</span><br><span class="line">                      --count;</span><br><span class="line">                      oldValue = v;</span><br><span class="line">                  &#125;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              pred = e;</span><br><span class="line">              e = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>scanAndLock(Object key, int hash)<br>扫描是否含有指定的 key 并且获取同步锁，当方法执行完毕也就是跳出循环肯定成功获取到同步锁，跳出循环有两种方式：1.tryLock 方法尝试获取独占锁成功 2. 尝试获取超过最大自旋次数 MAX_SCAN_RETRIES 线程堵塞，当线程从等待队列中被唤醒获取到锁跳出循环。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p>检查 ConcurrentHashMap 是否为空。同样没有使用同步锁，通过两次遍历：1. 确定每个 segment 是否为 0, 其中任何一个 segment 的 count 不为 0, 就返回，都为 0, 就累加 modCount 为 sum.2. 第一个循环执行完还没有推出，map 可能为空，再做一次遍历，如果在这个过程中任何一个 segment 的 count 不为 0 返回 false，同时 sum 减去每个 segment 的 modCount，若循环执行完程序还没有退出，比较 sum 是否为 0，为 0 表示两次检查没有元素插入，map 确实为空，否则 map 不为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">//累计segment的modCount值</span><br><span class="line">      long sum = 0L;</span><br><span class="line">      final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">      for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">          if (seg != null) &#123;</span><br><span class="line">              if (seg.count != 0)</span><br><span class="line">                  return false;</span><br><span class="line">              sum += seg.modCount;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//再次检查</span><br><span class="line">      if (sum != 0L) &#123; // recheck unless no modifications</span><br><span class="line">          for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">              Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">              if (seg != null) &#123;</span><br><span class="line">                  if (seg.count != 0)</span><br><span class="line">                      return false;</span><br><span class="line">                  sum -= seg.modCount;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (sum != 0L)</span><br><span class="line">              return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ConcurrentHashMap 引入分段锁的概念提高了并发量，每当线程要修改哈希表时并不是锁住整个表，而是去操作某一个 segment 片段，只对 segment 做同步，通过细化锁的粒度提高了效率，相对与 HashTable 对整个哈希表做同步处理更实用与多线程环境</p><p>segments 数组的大小仅在上述初始化创建代码中确定，一旦 map 创建成功后分段个数不会改变，每次扩容也只针对某个分段内的桶进行扩容。</p><p>[参考链接]<a href="https://www.cnblogs.com/rain4j/p/10972090.html" target="_blank" rel="noopener">https://www.cnblogs.com/rain4j/p/10972090.html</a></p><p>“$VIM/vimrc”<br>     user vimrc file: “$HOME/.vimrc”<br> 2nd user vimrc file: “<del>/.vim/vimrc”<br>      user exrc file: “$HOME/.exrc”<br>  system gvimrc file: “$VIM/gvimrc”<br>    user gvimrc file: “$HOME/.gvimrc”<br>2nd user gvimrc file: “</del>/.vim/gvimrc”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/16/jdk%E6%BA%90%E7%A0%81%E5%8C%85/"/>
    <id>http://yoursite.com/2020/07/16/jdk源码包/</id>
    <published>2020-07-16T11:57:10.000Z</published>
    <updated>2020-07-17T01:42:22.411Z</updated>
    
    <content type="html"><![CDATA[<h5 id="需要阅读的源码包"><a href="#需要阅读的源码包" class="headerlink" title="需要阅读的源码包"></a>需要阅读的源码包</h5><ul><li>1、java.lang<br>这里面其实就是Java的基本语法，比如各种基本包装类型（Integer、Long、Double等）、基本类（Object，Class，Enum，Exception，Thread）等等…</li><li>2、java.lang.annotation<br>包含Java注解基本元素相关的源码</li><li>3、java.lang.reflect<br>包含Java反射基本元素相关的代码</li><li>4、java.util<br>这里面放的都是Java的基本工具，最典型和常用的就是各种容器和集合（List、Map、Set）</li><li>5、java.util.concurrent<br>大名鼎鼎的JUC包，里面包含了Java并发和多线程编程相关的代码</li><li>6、java.util.function +java.util.stream<br>包含Java函数式编程的常见接口和代码</li><li>7、java.io<br>包含Java传统I/O相关的源码，主要是面向字节和流的I/O</li><li>8、java.nio<br>包含Java非阻塞I/O相关的源码，主要是面向缓冲、通道以及选择器的I/O</li><li>9、java.time<br>包含Java新日期和期间相关的代码，最典型的当属LocalDateTime、DateTimeFormatter等</li><li>10、java.math<br>主要包含一些高精度运算的支持数据类</li><li>11、java.math<br>主要包含一些高精度运算的支持数据类</li><li>12、java.net<br>主要包含Java网络通信（典型的如：Socket通信）相关的源代码。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;需要阅读的源码包&quot;&gt;&lt;a href=&quot;#需要阅读的源码包&quot; class=&quot;headerlink&quot; title=&quot;需要阅读的源码包&quot;&gt;&lt;/a&gt;需要阅读的源码包&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、java.lang&lt;br&gt;这里面其实就是Java的基本语法，比如各种基本包装
      
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
