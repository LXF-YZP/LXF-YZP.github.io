<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>观鱼入知命</title>
  
  <subtitle>我会忍受所有的寂寞,也会感叹时光的蹉跎。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-18T01:09:50.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丘山士心平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go语言defer详解</title>
    <link href="http://yoursite.com/2020/08/17/go%E8%AF%AD%E8%A8%80defer%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/17/go语言defer详解/</id>
    <published>2020-08-17T11:57:10.000Z</published>
    <updated>2020-08-18T01:09:50.970Z</updated>
    
    <content type="html"><![CDATA[<p>在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。</p><a id="more"></a><p>为了更好的学习defer的行为，我们首先来看下面一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">written, err = io.Copy(dst, src)</span><br><span class="line">dst.Close()</span><br><span class="line">src.Close()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以运行，但存在’安全隐患’。如果调用dst, err := os.Create(dstName)失败，则函数会执行return退出运行。但之前创建的src(文件句柄)没有被释放。 上面这段代码很简单，所以我们可以一眼看出存在文件未被释放的问题。 如果我们的逻辑复杂或者代码调用过多时，这样的错误未必会被及时发现。 而使用defer则可以避免这种情况的发生，下面是使用defer的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer src.Close()</span><br><span class="line"></span><br><span class="line">dst, err := os.Create(dstName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dst.Close()</span><br><span class="line"></span><br><span class="line">return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过defer，我们可以在代码中优雅的关闭/清理代码中所使用的变量。defer作为golang清理变量的特性，有其独有且明确的行为。以下是defer三条使用规则。</p><h2 id="规则一-当defer被声明时，其参数就会被实时解析"><a href="#规则一-当defer被声明时，其参数就会被实时解析" class="headerlink" title="规则一 当defer被声明时，其参数就会被实时解析"></a>规则一 当defer被声明时，其参数就会被实时解析</h2><p>我们通过以下代码来解释这条规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们说过，defer函数会在return之后被调用。那么这段函数执行完之后，是不用应该输出1呢？</p><p>读者自行编译看一下，结果输出的是0. why？</p><p>这是因为虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量(i)在defer被声明的时候，就已经确定其确定的值了。 换言之，上面的代码等同于下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(0) //因为i=0，所以此时就明确告诉golang在程序退出时，执行输出0的操作</span><br><span class="line">i++</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更为明确的说明这个问题，我们继续定义一个defer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">i := 0</span><br><span class="line">defer fmt.Println(i) //输出0，因为i此时就是0</span><br><span class="line">i++</span><br><span class="line">defer fmt.Println(i) //输出1，因为i此时就是1</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行结果，可以看到defer输出的值，就是定义时的值。<strong>而不是defer真正执行时的变量值(很重要，搞不清楚的话就会产生于预期不一致的结果)</strong></p><p>但为什么是先输出1，在输出0呢？ 看下面的规则二。</p><h2 id="规则二-defer执行顺序为先进后出"><a href="#规则二-defer执行顺序为先进后出" class="headerlink" title="规则二 defer执行顺序为先进后出"></a>规则二 defer执行顺序为先进后出</h2><p>当同时定义了多个defer代码块时，golang安装<strong>先定义后执行</strong>的顺序依次调用defer。不要为什么，golang就是这么定义的。我们用下面的代码加深记忆和理解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func b() &#123;</span><br><span class="line">for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">defer fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环中，依次定义了四个defer代码块。结合规则一，我们可以明确得知每个defer代码块应该输出什么值。 安装先进后出的原则，我们可以看到依次输出了3210.</p><h2 id="规则三-defer可以读取有名返回值"><a href="#规则三-defer可以读取有名返回值" class="headerlink" title="规则三 defer可以读取有名返回值"></a>规则三 defer可以读取有名返回值</h2><p>先看下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func c() (i int) &#123;</span><br><span class="line">defer func() &#123; i++ &#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是2. 在开头的时候，我们说过defer是在return调用之后才执行的。 这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(如果无法读取函数内变量，那又如何进行变量清除呢….)。</p><p>当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p><p>掌握了defer以上三条使用规则，那么当我们遇到defer代码块时，就可以明确得知defer的预期结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go基础知识</title>
    <link href="http://yoursite.com/2020/08/15/go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/08/15/go基础知识/</id>
    <published>2020-08-15T11:57:10.000Z</published>
    <updated>2020-08-18T07:54:33.977Z</updated>
    
    <content type="html"><![CDATA[<ul><li>go语言中“++”、“–”从运算符降级为语句；</li><li>Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；</li><li>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的；</li><li>字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的；</li><li>Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换；</li><li>被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化；</li><li>值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推；</li><li>值类型包括:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct；</li><li>引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型；</li><li>值类型:变量直接存储值，内存通常在栈中分配；</li><li>引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆 上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2></li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;go语言中“++”、“–”从运算符降级为语句；&lt;/li&gt;
&lt;li&gt;Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存；&lt;/li&gt;
&lt;li&gt;字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的
      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go指针</title>
    <link href="http://yoursite.com/2020/08/15/go%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/08/15/go指针/</id>
    <published>2020-08-15T11:57:10.000Z</published>
    <updated>2020-08-18T01:00:02.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识指针地址和指针类型"><a href="#认识指针地址和指针类型" class="headerlink" title="认识指针地址和指针类型"></a>认识指针地址和指针类型</h2><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。</p><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加<code>&amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight plain"><figcaption><span>:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为`*T`，称做 T 的指针类型，`*`代表指针。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">指针实际用法，可以通过下面的例子了解：</span><br></pre></td></tr></table></figure><p>package main<br>import (<br>    “fmt”<br>)<br>func main() {<br>    var cat int = 1<br>    var str string = “banana”<br>    fmt.Printf(“%p %p”, &amp;cat, &amp;str)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>0xc042052088 0xc0420461b0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 8 行，声明整型变量 cat。</span><br><span class="line">- 第 9 行，声明字符串变量 str。</span><br><span class="line">- 第 10 行，使用 fmt.Printf 的动词`%p`打印 cat 和 str 变量的内存地址，指针的值是带有`0x`十六进制前缀的一组数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</span><br><span class="line"></span><br><span class="line">## 从指针获取指针指向的值</span><br><span class="line"></span><br><span class="line">当使用`&amp;`操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用`*`操作符，也就是指针取值，代码如下。</span><br></pre></td></tr></table></figure><p>package main<br>import (<br>    “fmt”<br>)<br>func main() {<br>    // 准备一个字符串类型<br>    var house = “Malibu Point 10880, 90265”<br>    // 对字符串取地址, ptr类型为*string<br>    ptr := &amp;house<br>    // 打印ptr的类型<br>    fmt.Printf(“ptr type: %T\n”, ptr)<br>    // 打印ptr的指针地址<br>    fmt.Printf(“address: %p\n”, ptr)<br>    // 对指针进行取值操作    value := *ptr<br>    // 取值后的类型<br>    fmt.Printf(“value type: %T\n”, value)<br>    // 指针取值后就是指向变量的值<br>    fmt.Printf(“value: %s\n”, value)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>ptr type: *string<br>address: 0xc0420401b0<br>value type: string<br>value: Malibu Point 10880, 90265</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 10 行，准备一个字符串并赋值。</span><br><span class="line">- 第 13 行，对字符串取地址，将指针保存到变量 ptr 中。</span><br><span class="line">- 第 16 行，打印变量 ptr 的类型，其类型为 *string。</span><br><span class="line">- 第 19 行，打印 ptr 的指针地址，地址每次运行都会发生变化。</span><br><span class="line">- 第 22 行，对 ptr 指针变量进行取值操作，变量 value 的类型为 string。</span><br><span class="line">- 第 25 行，打印取值后 value 的类型。</span><br><span class="line">- 第 28 行，打印 value 的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">取地址操作符`&amp;`和取值操作符`*`是一对互补操作符，`&amp;`取出地址，`*`根据地址取出地址指向的值。</span><br><span class="line"></span><br><span class="line">变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</span><br><span class="line"></span><br><span class="line">- 对变量进行取地址操作使用`&amp;`操作符，可以获得这个变量的指针变量。</span><br><span class="line">- 指针变量的值是指针地址。</span><br><span class="line">- 对指针变量进行取值操作使用`*`操作符，可以获得指针变量指向的原变量的值。</span><br><span class="line"></span><br><span class="line">## 使用指针修改值</span><br><span class="line"></span><br><span class="line">通过指针不仅可以取值，也可以修改值。</span><br><span class="line"></span><br><span class="line">前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</span><br></pre></td></tr></table></figure><p>package main<br>import “fmt”<br>// 交换函数<br>func swap(a, b *int) {<br>        // 取a指针的值, 赋给临时变量t<br>        t := *a<br>        // 取b指针的值, 赋给a指针指向的变量<br>        *a = *b<br>        // 将a指针的值赋给b指针指向的变量<br>        *b = t<br>}<br>func main() {<br>            // 准备两个变量, 赋值1和2<br>            x, y := 1, 2<br>            // 交换变量值<br>            swap(&amp;x, &amp;y)<br>            // 输出变量值<br>            fmt.Println(x, y)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>2 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码说明如下：</span><br><span class="line"></span><br><span class="line">- 第 6 行，定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。</span><br><span class="line">- 第 9 行，取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。</span><br><span class="line">- 第 12 行，取 b 的指针值，赋给指针 a 指向的变量。注意，此时`*a`的意思不是取 a 指针的值，而是“a 指向的变量”。</span><br><span class="line">- 第 15 行，将 t 的值赋给指针 b 指向的变量。</span><br><span class="line">- 第 21 行，准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。</span><br><span class="line">- 第 24 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。</span><br><span class="line">- 第 27 行，交换完毕时，输出 x 和 y 的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`*`操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，`*`操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</span><br><span class="line"></span><br><span class="line">如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</span><br></pre></td></tr></table></figure><p>package main<br>import “fmt”<br>func swap(a, b *int) {<br>        b, a = a, b<br>}<br>func main() {<br>        x, y := 1, 2<br>        swap(&amp;x, &amp;y)<br>        fmt.Println(x, y)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>1 2<br>```</p><p>结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识指针地址和指针类型&quot;&gt;&lt;a href=&quot;#认识指针地址和指针类型&quot; class=&quot;headerlink&quot; title=&quot;认识指针地址和指针类型&quot;&gt;&lt;/a&gt;认识指针地址和指针类型&lt;/h2&gt;&lt;p&gt;一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 
      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>go中new和make区别</title>
    <link href="http://yoursite.com/2020/08/14/go%E4%B8%ADnew%E5%92%8Cmake%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/08/14/go中new和make区别/</id>
    <published>2020-08-14T11:57:10.000Z</published>
    <updated>2020-08-14T08:41:30.599Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/14/go中new和make区别/aaa.png" alt></p><p>Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二者都是用来分配空间.</p><p>Go 语言中 new 和 make 是内建的两个函数，主要用来创建分配类型内存. 在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用.</p><h2 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h2><p>new (T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T, 该指针指向 T 的新分配的零值.</p><p>new 要点</p><ul><li>内置函数 new 分配空间.</li><li>传递给 new 函数的是一个类型，不是一个值.</li><li>返回值是 指向这个新分配的零值的指针.</li></ul><h2 id="2-make"><a href="#2-make" class="headerlink" title="2. make"></a>2. make</h2><p>make (T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T, 是经过初始化之后的 T 的引用. make 也是内建函数，你可以从 <a href="http://golang.org/pkg/builtin/#make" target="_blank" rel="noopener">http://golang.org/pkg/builtin/#make</a> 看到它， 它的函数原型 比 new 多了一个（长度）参数，返回值也不同.</p><p><strong><em>make 只能用于 slice,map,channel 三种类型\</em></strong> , 并且只能是这三种对象。和 new 一样，第一个参数是 类型，不是一个值. 但是 make 的返回值就是这个类型（即使一个引用类型）, 而不是指针。具体的返回值，依赖具体传入的类型.</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>new (T) 返回 T 的指针 *T 并指向 T 的零值.</li><li>make (T) 返回的初始化的 T, 只能用于 slice,map,channel, 要获得一个显式的指针，使用 new 进行分配，或者显式地使用一个变量的地址.</li><li>new 函数分配内存，make 函数初始化；</li></ul><p>下图给出了区别：</p><p><img src="/2020/08/14/go中new和make区别/bbb.png" alt></p><p>new 和 make 区别代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := new([]int) //p == nil; with len and cap 0</span><br><span class="line">    fmt.Println(p)</span><br><span class="line"></span><br><span class="line">    v := make([]int, 10, 50) // v is initialed with len 10, cap 50</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"></span><br><span class="line">    /*********Output****************</span><br><span class="line">        &amp;[]</span><br><span class="line">        [0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">    *********************************/</span><br><span class="line"></span><br><span class="line">    (*p)[0] = 18        // panic: runtime error: index out of range</span><br><span class="line">                        // because p is a nil pointer, with len and cap 0</span><br><span class="line">    v[1] = 18           // ok</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/08/14/go中new和make区别/aaa.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Go 语言中的 new 和 make 一直是新手比较容易混淆的东西， 咋一看很相似。不过解释两者之间的不同也非常容易。他们所做的事情，和应用的类型也不相同. 二
      
    
    </summary>
    
    
      <category term="go语言" scheme="http://yoursite.com/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="go语言" scheme="http://yoursite.com/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>kill掉多个进程</title>
    <link href="http://yoursite.com/2020/08/11/kill%E6%8E%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/11/kill掉多个进程/</id>
    <published>2020-08-11T11:57:10.000Z</published>
    <updated>2020-08-11T07:06:29.091Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep beh-oss-minio-test-1.0-SNAPSHOT.jar | grep -v grep| awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux、进程" scheme="http://yoursite.com/tags/Linux%E3%80%81%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux下定时任务命令</title>
    <link href="http://yoursite.com/2020/08/10/linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/08/10/linux下定时任务命令/</id>
    <published>2020-08-10T11:57:10.000Z</published>
    <updated>2020-08-11T08:34:32.055Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、定时任务" scheme="http://yoursite.com/categories/Linux%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>grep命令使用</title>
    <link href="http://yoursite.com/2020/08/09/grep%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/09/grep命令使用/</id>
    <published>2020-08-09T11:57:10.000Z</published>
    <updated>2020-08-11T09:00:54.784Z</updated>
    
    <content type="html"><![CDATA[<p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、以递归的方式查找符合条件的文件。例如，查找指定目录 /etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串 “update” 的文件，并打印出该字符串所在行的内容，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r update /etc/acpi</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi”  </span><br><span class="line">#下包含“update”的文件  </span><br><span class="line">/etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  </span><br><span class="line">Rather than  </span><br><span class="line">/etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of  </span><br><span class="line">IO.) Rather than  </span><br><span class="line">/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update</span><br></pre></td></tr></table></figure><p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过 “-v” 参数可以打印出不符合条件行的内容。</p><p>查找文件名中包含 test 的文件中不包含 test 的行，此时，使用的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v test *test*</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  </span><br><span class="line">testfile1:helLinux!  </span><br><span class="line">testfile1:Linis a free Unix-type operating system.  </span><br><span class="line">testfile1:Lin  </span><br><span class="line">testfile_1:HELLO LINUX!  </span><br><span class="line">testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  </span><br><span class="line">testfile_1:THIS IS A LINUX TESTFILE!  </span><br><span class="line">testfile_2:HELLO LINUX!  </span><br><span class="line">testfile_2:Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure><p><strong>查找指定进程个数</strong></p><p><strong>命令：</strong></p><p>ps -ef|grep svn -c</p><p>ps -ef|grep -c svn</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef|grep svn -c</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ps -ef|grep -c svn </span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>从文件中读取关键词进行搜索</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -f test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -f test2.txt</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行</p><p><strong>从文件中读取关键词进行搜索 且显示行号</strong></p><p><strong>命令：</strong></p><p>cat test.txt | grep -nf test2.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test2.txt </span><br><span class="line"></span><br><span class="line">linux</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt | grep -nf test2.txt</span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">6:Redhat</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出 test.txt 文件中含有从 test2.txt 文件中读取出的关键词的内容行，并显示每一行的行号</p><p><strong>从文件中查找关键词</strong></p><p><strong>命令：</strong></p><p>grep ‘linux’ test.txt</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# grep &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]# grep -n &apos;linux&apos; test.txt </span><br><span class="line"></span><br><span class="line">1:hnlinux</span><br><span class="line"></span><br><span class="line">4:ubuntu linux</span><br><span class="line"></span><br><span class="line">7:linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>找出以u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^u</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^u</span><br><span class="line"></span><br><span class="line">ubuntu</span><br><span class="line"></span><br><span class="line">ubuntu linux</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出非 u 开头的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep ^[^u]</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep ^[^u]</span><br><span class="line"></span><br><span class="line">hnlinux</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">linuxmint</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>输出以 hat 结尾的行内容</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep hat$</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep hat$</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p><strong>显示包含 ed 或者 at 字符的内容行</strong></p><p><strong>命令：</strong></p><p>cat test.txt |grep -E “ed|at”</p><p><strong>输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;peida|com&quot;</span><br><span class="line"></span><br><span class="line">peida.cnblogs.com</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat test.txt |grep -E &quot;ed|at&quot;</span><br><span class="line"></span><br><span class="line">redhat</span><br><span class="line"></span><br><span class="line">Redhat</span><br><span class="line"></span><br><span class="line">[root@localhost test]#</span><br></pre></td></tr></table></figure><p>[参考链接]<a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grep test *file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;结果如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testfile_2:Linux test #列出testfile_2 文件中包含test字符的行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux、grep" scheme="http://yoursite.com/categories/Linux%E3%80%81grep/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>sed命令使用</title>
    <link href="http://yoursite.com/2020/08/08/sed%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/08/sed命令使用/</id>
    <published>2020-08-08T11:57:10.000Z</published>
    <updated>2020-08-11T08:28:58.506Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux、sed" scheme="http://yoursite.com/categories/Linux%E3%80%81sed/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>awk命令使用</title>
    <link href="http://yoursite.com/2020/08/07/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/07/awk命令使用/</id>
    <published>2020-08-07T11:57:10.000Z</published>
    <updated>2020-08-12T03:25:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>./java -jar /home/bdc/beh-oss.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin filetest 5.flv19 single</p><p>java -jar /home/bdc/beh-oss-minio-test-1.0-SNAPSHOT.jar <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /home/bdc/test uploa<br>ad 10 10 10 420000</p><p>./mc ls mycloud/filetest/6.xml | wc -l</p><p>#!/bin/bash</p><p>sum_num=300000<br>for((i=0;i&lt;=10;i++));do<br>  echo $sum_num</p><p>  #java -cp beh-oss-minio-test-1.0-SNAPSHOT.jar com.bonc.beh.oss.MinioTest <a href="http://172.16.48.1:8000" target="_blank" rel="noopener">http://172.16.48.1:8000</a> minioadmin minioadmin /opt/beh/core/MinIO/alone/ upload 10 10 10 $sum_num<br>  sum_num=<code>expr 10000 + $sum_num</code><br>done</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;./java -jar /home/bdc/beh-oss.jar &lt;a href=&quot;http://172.16.48.1:8000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://172.16.48.1:8000&lt;/a&gt; minioadmin
      
    
    </summary>
    
    
      <category term="Linux、awk" scheme="http://yoursite.com/categories/Linux%E3%80%81awk/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux上CPU内存使用查看</title>
    <link href="http://yoursite.com/2020/08/06/linux%E4%B8%8ACPU%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2020/08/06/linux上CPU内存使用查看/</id>
    <published>2020-08-06T11:57:10.000Z</published>
    <updated>2020-08-07T01:16:16.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top 命令的显示结果如下所示：</span><br><span class="line"></span><br><span class="line">top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 </span><br><span class="line">Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie </span><br><span class="line">Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si </span><br><span class="line">Mem: 191272k total, 173656k used, 17616k free, 22052k buffers </span><br><span class="line">Swap: 192772k total, 0k used, 192772k free, 123988k cached </span><br><span class="line"></span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </span><br><span class="line">1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd </span><br><span class="line">14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top </span><br><span class="line">1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init </span><br><span class="line">2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 </span><br><span class="line">3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>统计信息区</strong></p><p>前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p><table><thead><tr><th>01:06:48</th><th>当前时间</th></tr></thead><tbody><tr><td>up 1:22</td><td>系统运行时间，格式为时：分</td></tr><tr><td>1 user</td><td>当前登录用户数</td></tr><tr><td>load average: 0.06, 0.60, 0.48</td><td>系统负载，即任务队列的平均长度。 三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值。</td></tr></tbody></table><p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>Tasks: 29 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>28 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>Cpu(s): 0.3% us</td><td>用户空间占用 CPU 百分比</td></tr><tr><td>1.0% sy</td><td>内核空间占用 CPU 百分比</td></tr><tr><td>0.0% ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>98.7% id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0% wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0% hi</td><td></td></tr><tr><td>0.0% si</td><td></td></tr></tbody></table><p>最后两行为内存信息。内容如下：</p><table><thead><tr><th>Mem: 191272k total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>173656k used</td><td>使用的物理内存总量</td></tr><tr><td>17616k free</td><td>空闲内存总量</td></tr><tr><td>22052k buffers</td><td>用作内核缓存的内存量</td></tr><tr><td>Swap: 192772k total</td><td>交换区总量</td></tr><tr><td>0k used</td><td>使用的交换区总量</td></tr><tr><td>192772k free</td><td>空闲交换区总量</td></tr><tr><td>123988k cached</td><td>缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。 相应的内存再次被换出时可不必再对交换区写入。</td></tr></tbody></table><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><p><strong><em>free [选项]</em></strong></p><p><strong>默认情况下，即在没有选项的情况下，\</strong>“*<em>free”命令显示内存的使用信息。默认按照k（b）的计数单位统计。*</em></p><ul><li>total：表示 总计物理内存的大小。</li><li>used：表示 已使用多少。</li><li>free：表示 可用内存多少。</li><li>Shared：表示多个进程共享的内存总额。</li><li>Buffers/cached：表示 磁盘缓存的大小。</li></ul><p><strong>注意：free命令的选项区分大小写，请认真对照上图中是大写还是小写</strong></p><ol><li>free -b：以bytes为单位来显示内存的信息。</li><li>free -k：以kb为单位来显示内存的信息。</li><li>free -m：以m为单位来显示内存的信息。</li><li>free -g：以G为单位来显示内存的信息。</li><li>free -h：以适于人类可读方式显示内存信息。-h与其他命令最大不同是<strong>-h</strong>选项会在数字后面加上适于人类可读的单位</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;top命令&quot;&gt;&lt;a href=&quot;#top命令&quot; class=&quot;headerlink&quot; title=&quot;top命令&quot;&gt;&lt;/a&gt;top命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;top 命令的显示结果如下所示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombie &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% si &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mem: 191272k total, 173656k used, 17616k free, 22052k buffers &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swap: 192772k total, 0k used, 192772k free, 123988k cached &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>NERDTree快捷键</title>
    <link href="http://yoursite.com/2020/07/23/NERDTree%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/23/NERDTree快捷键/</id>
    <published>2020-07-23T11:57:10.000Z</published>
    <updated>2020-08-04T09:35:20.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="切换工作台和目录"><a href="#切换工作台和目录" class="headerlink" title="切换工作台和目录"></a>切换工作台和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line">D       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line">q       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 tab</span><br><span class="line">gt      后一个 tab</span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 tab 的关闭、切换</span><br><span class="line">cmd+w   关闭当前的 tab</span><br><span class="line">cmd+&#123;   前一个 tab</span><br><span class="line">cmd+&#125;   后一个 tab</span><br></pre></td></tr></table></figure><h3 id="NerdTree-在-vimrc-中的常用配置"><a href="#NerdTree-在-vimrc-中的常用配置" class="headerlink" title="NerdTree 在 .vimrc 中的常用配置"></a>NerdTree 在 .vimrc 中的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="line">autocmd VimEnter * NERDTree</span><br><span class="line"></span><br><span class="line">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class="line">map  :silent! NERDTreeToggle</span><br><span class="line"></span><br><span class="line">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;切换工作台和目录&quot;&gt;&lt;a href=&quot;#切换工作台和目录&quot; class=&quot;headerlink&quot; title=&quot;切换工作台和目录&quot;&gt;&lt;/a&gt;切换工作台和目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + h    光标 focus 左侧树形目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + l    光标 focus 右侧文件显示窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + w    光标自动在左右侧窗口切换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + w + r    移动当前窗口的布局位置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>MacVim编辑器使用</title>
    <link href="http://yoursite.com/2020/07/22/MacVim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/22/MacVim编辑器使用/</id>
    <published>2020-07-22T11:57:10.000Z</published>
    <updated>2020-07-22T03:30:53.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vim-模式区分"><a href="#Vim-模式区分" class="headerlink" title="Vim 模式区分"></a>Vim 模式区分</h3><h5 id="普通模式-Normal-mode"><a href="#普通模式-Normal-mode" class="headerlink" title="普通模式 (Normal mode)"></a>普通模式 (Normal mode)</h5><ul><li>Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑</li></ul><h5 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h5><ul><li>该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.</li></ul><h5 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h5><ul><li>与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式</li></ul><h5 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h5><ul><li>新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)</li></ul><h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><ul><li>在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启</li></ul><a id="more"></a><h3 id="元字符的存在"><a href="#元字符的存在" class="headerlink" title="元字符的存在"></a>元字符的存在</h3><p>元字符是 Vim 对模糊匹配的一个附加属性，通过元字符可以快速找出目标字段.</p><ul><li><code>.</code>: 表示匹配任意 <strong>一个</strong> 字符。例: <code>c..l</code> 表示任意以 c 开头，中间有两个任意字符，l 结尾的字段.</li><li><code>.*</code>: 表示匹配 <strong>任意多个</strong> 字符。例: <code>c.*l</code> 表示任意以 c 开头 l 结尾的字段 (不会将一个字段进行跨行处理，因此非常智能，很频繁使用)</li><li><code>$</code>: 匹配行尾。例: <code>/d.*$</code> 表示匹配到以 d 开头到行尾中的所有内容，<code>/123$</code> 表示以 123 结尾的所有字段</li><li><code>^</code>: 匹配行首。例: <code>^.*d</code> 表示匹配到行首到 d 的所有内容，<code>/^123</code> 表示以 123 开头的字段</li><li><code>\&lt;</code> : 匹配单词词首</li><li><code>\&gt;</code>: 匹配单词词尾。例: <code>/\&lt;f\&gt;</code> 表示只匹配 <code>f</code> 单词，如果其前有任何字符它就不是单词，不会被匹配到.</li><li><code>\( \)</code>: 括号内的内容可以在后面被引用，引用方式为 <code>\1</code>, <code>\2</code></li><li><code>*</code>: 表示其前字符可以重复 0~ 无数 次。如 <code>/be*</code> 会匹配到 <code>b</code>, <code>be</code>, <code>bee</code> …, 因为 e 重复零次就是没有，所以会返回 b</li><li><code>\+</code>: 表示其前字符必须重复 1~ 无数 次，如 <code>/be\+</code> 会匹配到 <code>be</code>, <code>bee</code>, <code>beee</code> …</li><li><code>\=</code>: 代表其前字符必须重复 0 或者 1 次.</li><li><code>\{n,m}</code> : 其前字符必须重复 n 到 m 次</li><li><code>[adz]</code>: 匹配 <code>a</code>, <code>d</code>, <code>z</code> 中的任意 <strong>一个</strong> , 括号内也可是数字，如 <code>[2-5]</code> 表示匹配 <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> 中的任意一个数字</li><li><code>\|</code>; 或的意思，表示只要符合其前或其后任意一个字符即可。例: <code>/one\|two\|three</code> 表示匹配 one, two, three 中的任意一个. <code>end\(if\|while\|for\)</code> 表示会查找到 endif, endwhile, endfor 中的任意一个.</li><li><code>[^a]</code>: 匹配除 <code>a</code> 以外的任意 <strong>字符</strong></li><li><code>[a-c]</code>: 匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个，递增的顺序</li><li><code>\d</code>: 匹配十进制数字中的任意一个，等同于 <code>[0-9]</code>. 例: <code>/\d\d:\d\d:\d\d</code> 表示查找如 <code>17:31:00</code> 格式的字符</li><li><code>\D</code>: 匹配除十进制数字外的任意一个字符，等同于 <code>[^0-9]</code></li><li><code>\x</code>: 匹配十六进制数字中的任意一个，等同于 <code>[0-9A-Fa-f]</code></li><li><code>\X</code>: 匹配除十六进制数字外的任意一个字符，等同于 <code>[^0-9A-Fa-f]</code></li><li><code>\w</code>: 匹配一个单词 (对中文来说非常鸡肋，因为只有 Vim 判定是单词的才会进行匹配，与 <code>w</code>, <code>b</code>, <code>e</code> , 的匹配规则相同)</li><li><code>\W</code>: 匹配除单词外的所有字符。因为在 vim 中中文全部不被认为是单词，因此，此匹配会选中所有中文字段.</li><li><code>\t</code>: 匹配 tab , 可使用此方法将所有 tab 替换为空格</li><li><code>\s</code>: 匹配空白字段，包含 tab 与空格，在 pattern 中使用此查找空白，在 string 中就可以直接使用空格或者 tab 来输入以替换了</li><li><code>\S</code>: 匹配非空白字段，等同于 <code>[^\s]</code></li><li><code>\n</code>: 匹配换行符</li><li><code>\r</code>: 换行，在 pattern 中使用 <code>\n</code> 作为搜索串，在 string 中使用 <code>\r</code> 作为换行命令 (如果在 string 中仍然使用 \n 的话会出错)</li><li><code>\_s</code>: 匹配换行或空白</li><li><code>\_a</code>: 匹配换行或单词 (因为是单词，vim 不会匹配中文)</li><li><code>\C</code>: 区分大小写地查找或替换，例: <code>/\CText</code> 表示只会查找 <code>Text</code>, 不会查找 <code>text</code> 或 <code>tExt</code> 等</li><li><code>\c</code>: 不区分大小写地查找替换 (已经在 vim 中设置了默认不区分了)</li></ul><p>如上所述，<code>.</code>, <code>*</code>, <code>[</code>, <code>]</code>, <code>^</code>, <code>%</code>, <code>/</code>, <code>?</code>, <code>~</code>, <code>$</code> 这十个字符有特殊含义，如果对这十个字符进行匹配，需要添加 <code>\</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h5 id="查找逻辑"><a href="#查找逻辑" class="headerlink" title="查找逻辑"></a>查找逻辑</h5><ul><li><code>/单词</code>: 全文查找 view 关键字 (n 为向下方向)</li><li><code>/\c单词</code>: 全文查找 view 关键字 (大小写不敏感)</li><li><code>?单词</code>: 全文查找 view 关键字 (n 为向上方向)</li><li><code>:noh</code> : 退出查找模式</li><li><code>*</code>: 全文查找光标处词组 (n 为向下方向)</li><li><code>#</code>: 全文查找光标处词组 (n 为向上方向)</li><li><code>n</code>: 下一个列出的关键字</li><li><code>N</code>: 上一个列出的关键字</li></ul><h5 id="查找实例"><a href="#查找实例" class="headerlink" title="查找实例"></a>查找实例</h5><p><code>/\&lt;单词\&gt;</code>: 查找只为 <code>单词</code> 的字符</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>假如有这么一行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thee best time to see thee flowers is in thee spring.</span><br></pre></td></tr></table></figure><ul><li>当我键入<code>:s/thee/the &lt;回车&gt;</code>，那么该行的第一 <code>thee</code> 就被我替换成了 <code>the</code></li><li>如果想将所有的 <code>thee</code> 替换，可以键入<code>:s/thee/the/g</code></li><li>要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :% s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :% s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li></ul><h2 id="文本编辑之删除"><a href="#文本编辑之删除" class="headerlink" title="文本编辑之删除"></a>文本编辑之删除</h2><p>只需要将光标移动到你想要删除的文本位置，按下 <code>x</code> 键即可</p><blockquote><p>提示：当我对某个操作不满意，想要撤回的时候，只要键入 u 即可</p></blockquote><h2 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h2><p>简单来说，如果我想要删除一个单词只需要键入 <code>dw</code>，如果我键入 <code>d$</code>，那么这一整行的内容都被我删了(dd也可以达到相同的效果)</p><h2 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h2><p><strong><em>假如 vim 打开的文件中某一个行有这样一句的内容</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is just a line with words you can move around in.</span><br></pre></td></tr></table></figure><p>我的光标在开头的 T 位置</p><ul><li>键入一次 e，我的光标位置就会出现在 This 这个单词的末尾 s 处，键入两次，就会出现在下一个单词的末尾。</li><li>键入 w，就会出现在下一个单词的开头，多次键入与 e 的效果雷同。</li><li>键入 0(数字0)，能使我的光标出现在行首。</li><li>键入 $，能使我的光标出现在行末。</li></ul><h2 id="使用计数已删除更多"><a href="#使用计数已删除更多" class="headerlink" title="使用计数已删除更多"></a>使用计数已删除更多</h2><p>上面已经提到过删除操作符和动作的组合，你可以在组合中动作之前插入一个数字以删除更多</p><p> d number (数字) motion</p><p>比如键入 <code>d2w</code>，我们就可以删除光标所在位置起的两个单词</p><h2 id="操作整行"><a href="#操作整行" class="headerlink" title="操作整行"></a>操作整行</h2><ul><li>之前用 <code>d$</code> 命令删除整行内容后，我们会发现这一行变成了一个空行，所以可能用清除整行内容来称呼它更加合适</li><li>如果我们要删除当前行，可以键入 <code>dd</code> 命令</li><li>你也可以键入 <code>2dd</code>，来删除当前行起的两行(向下)</li></ul><h2 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h2><ul><li>之前有提到过，如果你操作失误，可以键入 <code>u</code> 来撤销最后一次执行的命令</li><li>如果你嫌一次一次的撤销太麻烦，你可以键入 <code>U</code>，来使当前行恢复到初始状态</li></ul><h2 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h2><p>之前所说的 <code>dd</code> 命令删除了一整行内容，其实呢，并没有消失，而是保存在了 vim 的寄存器中。</p><ul><li>当使用 <code>dd</code> 命令删除了某一行内容后，光标移到某一行，键入 <code>p</code>，刚刚删除掉的那一行内容就会粘贴到当前行的下一行了</li></ul><h2 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h2><ul><li>键入 <code>cw</code>，然后输入正确的内容，我们就可以更改整个单词了。</li></ul><h2 id="复制一行"><a href="#复制一行" class="headerlink" title="复制一行"></a>复制一行</h2><ul><li><code>yy</code> 复制光标所在位置的一行， <code>yw</code>复制光标所在的单词， 使用<code>p</code>进行粘贴；</li></ul><h2 id="在-vim-内执行外部命令的方法"><a href="#在-vim-内执行外部命令的方法" class="headerlink" title="在 vim 内执行外部命令的方法"></a>在 vim 内执行外部命令的方法</h2><p>再用 vim 编程的时候，如果我想输入一个外部命令怎么办，难道我还需要新建个终端窗口吗？当然不需要</p><p>1、 按下我们所熟悉的 <code>:</code> 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。</p><p>2、 接着输入感叹号 <code>!</code> 这个字符，这样就允许您执行外部的 shell 命令了。</p><p>3、 我们以 <code>ls</code> 命令为例。输入 <code>!ls &lt;回车&gt;</code> 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样</p><p>[参考链接]<a href="https://juejin.im/post/5aed4b0651882567127868df#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5aed4b0651882567127868df#heading-14</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vim-模式区分&quot;&gt;&lt;a href=&quot;#Vim-模式区分&quot; class=&quot;headerlink&quot; title=&quot;Vim 模式区分&quot;&gt;&lt;/a&gt;Vim 模式区分&lt;/h3&gt;&lt;h5 id=&quot;普通模式-Normal-mode&quot;&gt;&lt;a href=&quot;#普通模式-Normal-mode&quot; class=&quot;headerlink&quot; title=&quot;普通模式 (Normal mode)&quot;&gt;&lt;/a&gt;普通模式 (Normal mode)&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vim 默认模式，又称为命令模式，可使用 hjkl 进行移动和简单编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;插入模式&quot;&gt;&lt;a href=&quot;#插入模式&quot; class=&quot;headerlink&quot; title=&quot;插入模式&quot;&gt;&lt;/a&gt;插入模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;该模式下可以尽情地输入，普通模式通过 i, a, o, cc 等命令可进入插入模式.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;可视模式&quot;&gt;&lt;a href=&quot;#可视模式&quot; class=&quot;headerlink&quot; title=&quot;可视模式&quot;&gt;&lt;/a&gt;可视模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;与普通模式类似，不同的是当移动时会进行扩展当前的选择区域。普通模式按 v(进入字符选择模式) 或 V (进入行选择模式) 进入该模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;替换模式&quot;&gt;&lt;a href=&quot;#替换模式&quot; class=&quot;headerlink&quot; title=&quot;替换模式&quot;&gt;&lt;/a&gt;替换模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;新输入的文本会替换光标所在处的文本，并使光标依次向后移动,普通模式下通过按 R 进入该模式(小写r可以替换单个字符，大写R可以替换单词，句子)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;命令行模式&quot;&gt;&lt;a href=&quot;#命令行模式&quot; class=&quot;headerlink&quot; title=&quot;命令行模式&quot;&gt;&lt;/a&gt;命令行模式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在该模式下可以在窗口的下方输入一行命令，然后执行。当一条命令执行完会自动退出命令模式进入普通模式，命令模式通过输入 : 进行开启&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>使用VIM打开文件报错</title>
    <link href="http://yoursite.com/2020/07/21/%E4%BD%BF%E7%94%A8VIM%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/21/使用VIM打开文件报错/</id>
    <published>2020-07-21T11:57:10.000Z</published>
    <updated>2020-08-18T01:01:00.021Z</updated>
    
    <content type="html"><![CDATA[<p>下载完vim的主题之后打开文件报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /Users/luxiaofeng/.vim/colors/molokai.vim</span><br><span class="line">Error detected while processing /Users/luxiaofeng/.vim/colors/molokai.vim:</span><br><span class="line">line   10:</span><br><span class="line">E411: highlight group not found: clear^M</span><br><span class="line">line   11:</span><br><span class="line">E15: Invalid expression: version &gt; 580^M</span><br><span class="line">line  275:</span><br><span class="line">E171: Missing :endif</span><br><span class="line">Press ENTER or type command to continue</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开那个文件后：</span><br><span class="line">:set ff=unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载完vim的主题之后打开文件报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="linux、vim" scheme="http://yoursite.com/tags/linux%E3%80%81vim/"/>
    
  </entry>
  
  <entry>
    <title>vim安装插件之后的各种报错</title>
    <link href="http://yoursite.com/2020/07/20/vim%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/07/20/vim安装插件之后的各种报错/</id>
    <published>2020-07-20T11:57:10.000Z</published>
    <updated>2020-07-28T09:13:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件nerdtree"><a href="#安装插件nerdtree" class="headerlink" title="安装插件nerdtree"></a>安装插件nerdtree</h2><p>启动MacVim报错<code>Error detected while processing function &lt;SNR&gt;2_lod_cmd</code>或者<code>Error detected while processing function &lt;SNR&gt;3_lod_cmd</code></p><p>原因是在<code>.vimrc</code>中配置的插件为<code>Plug &#39;scrooloose/nerdtree&#39;, { &#39;on&#39;: &#39;NERDTreeToggle&#39; }</code>. 改为 <code>Plug &#39;scrooloose/nerdtree&#39;</code>之后报错消失；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装插件nerdtree&quot;&gt;&lt;a href=&quot;#安装插件nerdtree&quot; class=&quot;headerlink&quot; title=&quot;安装插件nerdtree&quot;&gt;&lt;/a&gt;安装插件nerdtree&lt;/h2&gt;&lt;p&gt;启动MacVim报错&lt;code&gt;Error detected
      
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim插件安装</title>
    <link href="http://yoursite.com/2020/07/19/Vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/07/19/Vim插件安装/</id>
    <published>2020-07-19T11:57:10.000Z</published>
    <updated>2020-08-05T01:36:27.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装vim-plug插件"><a href="#安装vim-plug插件" class="headerlink" title="安装vim-plug插件"></a>安装vim-plug插件</h2><ul><li><p>首先下载插件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:junegunn/vim-plug.git</span><br></pre></td></tr></table></figure></li><li><p>下载 plug.vim(<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a>) 并将其放在 “自动加载” 目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；" target="_blank" rel="noopener">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；</a></p></li><li><p>在<code>~/.vimrc</code>中添加一个 vim-plug 部分</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&apos;data&apos;) . &apos;/plugged&apos;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &apos;plugin&apos;</span><br><span class="line">call plug#begin(&apos;~/.vim/plugged&apos;)</span><br><span class="line"></span><br><span class="line">&quot; Make sure you use single quotes</span><br><span class="line"></span><br><span class="line">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br><span class="line">Plug &apos;junegunn/vim-easy-align&apos;</span><br><span class="line"></span><br><span class="line">&quot; Any valid git URL is allowed</span><br><span class="line">Plug &apos;https://github.com/junegunn/vim-github-dashboard.git&apos;</span><br><span class="line"></span><br><span class="line">&quot; Multiple Plug commands can be written in a single line using | separators</span><br><span class="line">Plug &apos;SirVer/ultisnips&apos; | Plug &apos;honza/vim-snippets&apos;</span><br><span class="line"></span><br><span class="line">&quot; On-demand loading</span><br><span class="line">Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;:  &apos;NERDTreeToggle&apos; &#125;</span><br><span class="line">Plug &apos;tpope/vim-fireplace&apos;, &#123; &apos;for&apos;: &apos;clojure&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a non-master branch</span><br><span class="line">Plug &apos;rdnetto/YCM-Generator&apos;, &#123; &apos;branch&apos;: &apos;stable&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br><span class="line">Plug &apos;fatih/vim-go&apos;, &#123; &apos;tag&apos;: &apos;*&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin options</span><br><span class="line">Plug &apos;nsf/gocode&apos;, &#123; &apos;tag&apos;: &apos;v.20150303&apos;, &apos;rtp&apos;: &apos;vim&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br><span class="line">Plug &apos;junegunn/fzf&apos;, &#123; &apos;dir&apos;: &apos;~/.fzf&apos;, &apos;do&apos;: &apos;./install --all&apos; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Unmanaged plugin (manually installed and updated)</span><br><span class="line">Plug &apos;~/my-prototype-plugin&apos;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>重新加载.vimrc 并<code>:PlugInstall</code>安装插件,执行完成之后，使用vim打开文件有报错的话，一般是因为Windows下的换行符和Linux下的换行符不一样导致的，那个文件报错就使用vim打开那个文件，使用命令:set ff=unix修改换行符；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装vim-plug插件&quot;&gt;&lt;a href=&quot;#安装vim-plug插件&quot; class=&quot;headerlink&quot; title=&quot;安装vim-plug插件&quot;&gt;&lt;/a&gt;安装vim-plug插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载插件 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:junegunn/vim-plug.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载 plug.vim(&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/a&gt;) 并将其放在 “自动加载” 目录中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方法我这里下载失败了，我直接在/Users/luxiaofeng/.vim/目录下创建了文件夹autoload在该文件夹下创建文件plug.vim，然后将&lt;a href=&quot;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim里面的内容复制到文件里面；&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;~/.vimrc&lt;/code&gt;中添加一个 vim-plug 部分&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vim技巧" scheme="http://yoursite.com/categories/Vim%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Linux、Vim" scheme="http://yoursite.com/tags/Linux%E3%80%81Vim/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap1.7源码详解</title>
    <link href="http://yoursite.com/2020/07/18/ConcurrentHashMap1.7%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/18/ConcurrentHashMap1.7源码详解/</id>
    <published>2020-07-18T11:57:10.000Z</published>
    <updated>2020-07-21T09:47:02.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.</span><br></pre></td></tr></table></figure><p>大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。</p><a id="more"></a><h4 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h4><p>HashEntry 是 ConcurrentHashMap 的基础单元 (节点)，是实际数据的载体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V value;</span><br><span class="line">        volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Sets next field with volatile write semantics.  (See above</span><br><span class="line">         * about use of putOrderedObject.)</span><br><span class="line">         */</span><br><span class="line">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">            UNSAFE.putOrderedObject(this, nextOffset, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Unsafe mechanics</span><br><span class="line">        static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        static final long nextOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class k = HashEntry.class;</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(&quot;next&quot;));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>Segment 继承 ReentrantLock 锁，用于存放数组 HashEntry[]。在这里可以看出，无论 1.7 还是 1.8 版本，ConcurrentHashMap 底层并不是对 HashMap 的扩展，而是同样从底层基于数组 + 链表进行功能实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = 2249069246763182397L;</span><br><span class="line"></span><br><span class="line">        static final int MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line"></span><br><span class="line">        // 数据节点存储在这里(基础单元是数组)</span><br><span class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        transient int count;</span><br><span class="line"></span><br><span class="line">        transient int modCount;</span><br><span class="line"></span><br><span class="line">        transient int threshold;</span><br><span class="line"></span><br><span class="line">        final float loadFactor;</span><br><span class="line"></span><br><span class="line">        Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            this.loadFactor = lf;</span><br><span class="line">            this.threshold = threshold;</span><br><span class="line">            this.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Creates a new, empty map with a default initial capacity (16),</span><br><span class="line">* load factor (0.75) and concurrencyLevel (16).</span><br><span class="line">*/</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line">//static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br><span class="line"></span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 对于concurrencyLevel的理解, 可以理解为segments数组的长度，即理论上多线程并发数(分段锁), 默认16</span><br><span class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        // Find power-of-two sizes best matching arguments</span><br><span class="line">        int sshift = 0;</span><br><span class="line">        int ssize = 1;</span><br><span class="line">        // 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span><br><span class="line">        // ssize = 2^sshift 即 ssize = 1 &lt;&lt; sshift</span><br><span class="line">        while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 段偏移量，32是因为hash是int值，int值32位，默认值情况下此时segmentShift = 28</span><br><span class="line">        this.segmentShift = 32 - sshift;</span><br><span class="line">        // 散列算法的掩码，默认值情况下segmentMask = 15, 定位segment的时候需要根据segment[]长度取模, 即hash(key)&amp;(ssize - 1)</span><br><span class="line">        this.segmentMask = ssize - 1;</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        // 计算每个segment中table的容量, 初始容量=16, 并发数=16。</span><br><span class="line">        int c = initialCapacity / ssize;</span><br><span class="line">        // 处理无法整除的情况，取上限</span><br><span class="line">        if (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        // MIN_SEGMENT_TABLE_CAPACITY默认时2，cap必须是2的n次方</span><br><span class="line">        int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        // 确保cap是2^n</span><br><span class="line">        while (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= 1;</span><br><span class="line">        // create segments and segments[0]</span><br><span class="line">        // 创建segments并初始化第一个segment数组,其余的segment延迟初始化</span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">        // 默认并发数=16</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br><span class="line">        this.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h4><p>put 方法实际上只有两步：1. 根据键的值定位键值对在那个 segment 片段 2. 调用 Segment 的 put 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s;</span><br><span class="line">      if (value == null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">//计算键的hash值</span><br><span class="line">      int hash = hash(key);</span><br><span class="line">//通过hash值运算把键值对定位到segment[j]片段上</span><br><span class="line">      int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">//检查segment[j]是否已经初始化了，没有的话调用ensureSegment初始化segment[j]</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br><span class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br><span class="line">          s = ensureSegment(j);</span><br><span class="line">//向片段中插入键值对</span><br><span class="line">      return s.put(key, hash, value, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;</span><br><span class="line">    int h = hashSeed;       // 这个 hashSeed 是和 虚拟机的参数有关.. 在不配置的情况下 默认为 0 . 我们就是用默认的分析吧</span><br><span class="line"></span><br><span class="line">    if ((0 != h) &amp;&amp; (k instanceof String)) &#123;    // 如果配置了参数.. 且是 String 类型的，就使用 hash32</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //k.hashCode ... 这里可以看出.. 虽然 key 没有明确判断不能为 null .. 但是 一旦是 null</span><br><span class="line">    // 这里就会空指针了...</span><br><span class="line">    h ^= k.hashCode ();      //hashmap 一样的操作..</span><br><span class="line"></span><br><span class="line">    // Spread bits to regularize both segment and index locations,</span><br><span class="line">    // using variant of single-word Wang/Jenkins hash.</span><br><span class="line">    </span><br><span class="line">    h += (h &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 10);</span><br><span class="line">    h += (h &lt;&lt;   3);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  6);</span><br><span class="line">    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ensureSegment(int k)<br>  我们从 ConcurrentHashMap 的构造函数可以发现 Segment 数组只初始化了 Segment [0], 其余的 Segment 是用到了再初始化，用了延迟加载的策略，而延迟加载调用的就是 ensureSegment 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">      final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">      long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">      Segment&lt;K,V&gt; seg;</span><br><span class="line">//按照segment[0]的HashEntry数组长度和加载因子初始化Segment[k]</span><br><span class="line">      if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</span><br><span class="line">          int cap = proto.table.length;</span><br><span class="line">          float lf = proto.loadFactor;</span><br><span class="line">          int threshold = (int)(cap * lf);</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">          if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">              == null) &#123; // recheck</span><br><span class="line">              Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">              while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                     == null) &#123;</span><br><span class="line">                  if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                      break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return seg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="put(K key, int hash, V value, boolean onlyIfAbsent)"></a>put(K key, int hash, V value, boolean onlyIfAbsent)</h4><p>调用 Segment 的 put 方法插入键值对到 Segment 的 HashEntry 数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">//Segment继承ReentrantLock，尝试获取独占锁</span><br><span class="line">      HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">              scanAndLockForPut(key, hash, value);</span><br><span class="line">      V oldValue;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">//定位键值对在HashEntry数组上的位置</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">//获取这个位置的第一个键值对</span><br><span class="line">          HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">              if (e != null) &#123;//此处有链表结构，一直循环到e==null</span><br><span class="line">                  K k;</span><br><span class="line">//存在与待插入键值对相同的键，则替换value</span><br><span class="line">                  if ((k = e.key) == key ||</span><br><span class="line">                          (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                      oldValue = e.value;</span><br><span class="line">                      if (!onlyIfAbsent) &#123;//onlyIfAbsent默认为false</span><br><span class="line">                          e.value = value;</span><br><span class="line">                          ++modCount;</span><br><span class="line">                      &#125;</span><br><span class="line">                      break;</span><br><span class="line">                  &#125;</span><br><span class="line">                  e = e.next;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">//node不为null,设置node的next为first，node为当前链表的头节点</span><br><span class="line">                  if (node != null)</span><br><span class="line">                      node.setNext(first);</span><br><span class="line">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span><br><span class="line">                  else</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                  int c = count + 1;</span><br><span class="line">//扩容条件 (1)entry数量大于阈值 (2) 当前数组tab长度小于最大容量。满足以上条件就扩容</span><br><span class="line">                  if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">//扩容</span><br><span class="line">                      rehash(node);</span><br><span class="line">                  else</span><br><span class="line">//tab的index位置设置为node,</span><br><span class="line">                      setEntryAt(tab, index, node);</span><br><span class="line">                  ++modCount;</span><br><span class="line">                  count = c;</span><br><span class="line">                  oldValue = null;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">场景：线程 A 和线程 B 同时执行相同 Segment 对象的 put 方法;</span><br><span class="line">线程 A 执行 tryLock () 方法成功获取锁，则把 HashEntry 对象插入到相应的位置;</span><br><span class="line">线程 B 获取锁失败，则执行 scanAndLockForPut () 方法，在 scanAndLockForPut 方法中，会通过重复执行 tryLock () 方法尝试获取锁，在多处理器环境下，重复次数为 64，单处理器重复次数为 1，当执行 tryLock () 方法的次数超过上限时，则执行 lock () 方法挂起线程 B;</span><br><span class="line">当线程 A 执行完插入操作时，会通过 unlock () 方法释放锁，接着唤醒线程 B 继续执行;</span><br></pre></td></tr></table></figure><ul><li><p>scanAndLockForPut(K key, int hash, V value)<br>在不超过最大重试次数 MAX_SCAN_RETRIES 通过 CAS 尝试获取锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">//first,e:键值对的hash值定位到数组tab的第一个键值对</span><br><span class="line">      HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">      HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">      HashEntry&lt;K,V&gt; node = null;</span><br><span class="line">      int retries = -1; // negative while locating node</span><br><span class="line">//线程尝试通过CAS获取锁</span><br><span class="line">      while (!tryLock()) &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt; f; // to recheck first below</span><br><span class="line">          if (retries &lt; 0) &#123;</span><br><span class="line">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span><br><span class="line">              if (e == null) &#123;</span><br><span class="line">                  if (node == null) // speculatively create node</span><br><span class="line">//初始化键值对，next指向null</span><br><span class="line">                      node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                  retries = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              else if (key.equals(e.key))</span><br><span class="line">                  retries = 0;</span><br><span class="line">              else</span><br><span class="line">                  e = e.next;</span><br><span class="line">          &#125;</span><br><span class="line">//超过最大自旋次数，阻塞</span><br><span class="line">          else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">              lock();</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">//头节点发生变化，重新遍历</span><br><span class="line">          else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                  (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">              e = first = f; // re-traverse if entry changed</span><br><span class="line">              retries = -1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>rehash(HashEntry&lt;K,V&gt; node)<br>用于对 Segment 的 table 数组进行扩容，扩容后的数组长度是原数组的两倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">//扩容前的旧tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">//扩容前数组长度</span><br><span class="line">      int oldCapacity = oldTable.length;</span><br><span class="line">//扩容后数组长度（扩容前两倍）</span><br><span class="line">      int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">//计算新的阈值</span><br><span class="line">      threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">//新的tab数组</span><br><span class="line">      HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">              (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">//新的掩码</span><br><span class="line">      int sizeMask = newCapacity - 1;</span><br><span class="line">//遍历旧的数组</span><br><span class="line">      for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">//遍历数组的每一个元素</span><br><span class="line">          HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">//元素e指向的下一个节点，如果存在hash冲突那么e不为空</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//计算元素在新数组的索引</span><br><span class="line">              int idx = e.hash &amp; sizeMask;</span><br><span class="line">// 桶中只有一个元素，把当前的e设置给新的table</span><br><span class="line">              if (next == null)   //  Single node on list</span><br><span class="line">                  newTable[idx] = e;</span><br><span class="line">//桶中有布置一个元素的链表</span><br><span class="line">              else &#123; // Reuse consecutive sequence at same slot</span><br><span class="line">                  HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">// idx 是当前链表的头结点 e 的新位置</span><br><span class="line">                  int lastIdx = idx;</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                       last != null;</span><br><span class="line">                       last = last.next) &#123;</span><br><span class="line">//k是单链表元素在新数组的位置</span><br><span class="line">                      int k = last.hash &amp; sizeMask;</span><br><span class="line">                      //lastRun是最后一个扩容后不在原桶处的Entry</span><br><span class="line">                      if (k != lastIdx) &#123;</span><br><span class="line">                          lastIdx = k;</span><br><span class="line">                          lastRun = last;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">//lastRun以及它后面的元素都在一个桶中</span><br><span class="line">                  newTable[lastIdx] = lastRun;</span><br><span class="line">                  // Clone remaining nodes</span><br><span class="line">                  //遍历到lastRun即可</span><br><span class="line">                  for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                      V v = p.value;</span><br><span class="line">                      int h = p.hash;</span><br><span class="line">                      int k = h &amp; sizeMask;</span><br><span class="line">                      HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                      newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//处理引起扩容的那个待添加的节点</span><br><span class="line">      int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br><span class="line">      node.setNext(newTable[nodeIndex]);</span><br><span class="line">      newTable[nodeIndex] = node;</span><br><span class="line">//把Segment的table指向扩容后的table</span><br><span class="line">      table = newTable;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h4><p> get 获取元素不需要加锁，效率高，获取 key 定位到的 segment 片段还是遍历 table 数组的 HashEntry 元素时使用了 UNSAFE.getObjectVolatile 保证了能够无锁且获取到最新的 volatile 变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public V get(Object key) &#123;</span><br><span class="line">      Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</span><br><span class="line">      HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">//计算key的hash值</span><br><span class="line">      int h = hash(key);</span><br><span class="line">//根据hash值计算key在哪个segment片段</span><br><span class="line">      long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">//获取segments[u]的table数组</span><br><span class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">          (tab = s.table) != null) &#123;</span><br><span class="line">//遍历table中的HashEntry元素</span><br><span class="line">          for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                   (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">               e != null; e = e.next) &#123;</span><br><span class="line">              K k;</span><br><span class="line">//找到相同的key，返回value</span><br><span class="line">              if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                  return e.value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>size 方法用来计算 ConcurrentHashMap 中储存元素的个数。那么在统计所有的 segment 元素的个数是否都需要上锁呢？如果不上锁在统计的过程中可能存在其他线程并发存储 / 删除元素，而如果上锁又会降低读写效率。ConcurrentHashMap 在实现时使用了折中的方法，它会无锁遍历三次把所有的 segment 的 modCount 加到 sum 里面，如果与前一次遍历结果相比 sum 没有改变那么说明这两次遍历没有其他线程修改 ConcurrentHashMap, 返回 segment 的 count 的和；如果每次遍历与上一次相比都不一样那就上锁进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> public int size() &#123;</span><br><span class="line">     // Try a few times to get accurate count. On failure due to</span><br><span class="line">     // continuous async changes in table, resort to locking.</span><br><span class="line">     final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">     int size;</span><br><span class="line">     boolean overflow; // true if size overflows 32 bits</span><br><span class="line">     long sum;         // sum of modCounts</span><br><span class="line">     long last = 0L;   // previous sum</span><br><span class="line">     int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">     try &#123;</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">//达到RETRIES_BEFORE_LOCK，也就是三次</span><br><span class="line">             if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                 for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                     ensureSegment(j).lock(); // force creation</span><br><span class="line">             &#125;</span><br><span class="line">             sum = 0L;</span><br><span class="line">             size = 0;</span><br><span class="line">             overflow = false;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                 Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">//遍历计算segment的modCount和count的和</span><br><span class="line">                 if (seg != null) &#123;</span><br><span class="line">                     sum += seg.modCount;</span><br><span class="line">                     int c = seg.count;</span><br><span class="line">//是否溢出int范围</span><br><span class="line">                     if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                         overflow = true;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">//last是上一次的sum值，相等跳出循环</span><br><span class="line">             if (sum == last)</span><br><span class="line">                 break;</span><br><span class="line">             last = sum;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">//解锁</span><br><span class="line">         if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">             for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                 segmentAt(segments, j).unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h4><p>调用 Segment 的 remove 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    return s == null ? null : s.remove(key, hash, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key-int-hash-Object-value"><a href="#remove-Object-key-int-hash-Object-value" class="headerlink" title="remove(Object key, int hash, Object value)"></a>remove(Object key, int hash, Object value)</h4><p>获取同步锁，移除指定的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  final V remove(Object key, int hash, Object value) &#123;</span><br><span class="line">//获取同步锁</span><br><span class="line">      if (!tryLock())</span><br><span class="line">          scanAndLock(key, hash);</span><br><span class="line">      V oldValue = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">          int index = (tab.length - 1) &amp; hash;</span><br><span class="line">          HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">//遍历链表用来保存当前链表节点的前一个节点</span><br><span class="line">          HashEntry&lt;K,V&gt; pred = null;</span><br><span class="line">          while (e != null) &#123;</span><br><span class="line">              K k;</span><br><span class="line">              HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">//找到key对应的键值对</span><br><span class="line">              if ((k = e.key) == key ||</span><br><span class="line">                      (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                  V v = e.value;</span><br><span class="line">//键值对的值与传入的value相等</span><br><span class="line">                  if (value == null || value == v || value.equals(v)) &#123;</span><br><span class="line">//当前元素为头节点，把当前元素的下一个节点设为头节点</span><br><span class="line">                      if (pred == null)</span><br><span class="line">                          setEntryAt(tab, index, next);</span><br><span class="line">//不是头节点，把当前链表节点的前一个节点的next指向当前节点的下一个节点</span><br><span class="line">                      else</span><br><span class="line">                          pred.setNext(next);</span><br><span class="line">                      ++modCount;</span><br><span class="line">                      --count;</span><br><span class="line">                      oldValue = v;</span><br><span class="line">                  &#125;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              pred = e;</span><br><span class="line">              e = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      return oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>scanAndLock(Object key, int hash)<br>扫描是否含有指定的 key 并且获取同步锁，当方法执行完毕也就是跳出循环肯定成功获取到同步锁，跳出循环有两种方式：1.tryLock 方法尝试获取独占锁成功 2. 尝试获取超过最大自旋次数 MAX_SCAN_RETRIES 线程堵塞，当线程从等待队列中被唤醒获取到锁跳出循环。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p>检查 ConcurrentHashMap 是否为空。同样没有使用同步锁，通过两次遍历：1. 确定每个 segment 是否为 0, 其中任何一个 segment 的 count 不为 0, 就返回，都为 0, 就累加 modCount 为 sum.2. 第一个循环执行完还没有推出，map 可能为空，再做一次遍历，如果在这个过程中任何一个 segment 的 count 不为 0 返回 false，同时 sum 减去每个 segment 的 modCount，若循环执行完程序还没有退出，比较 sum 是否为 0，为 0 表示两次检查没有元素插入，map 确实为空，否则 map 不为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">//累计segment的modCount值</span><br><span class="line">      long sum = 0L;</span><br><span class="line">      final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">      for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">          Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">          if (seg != null) &#123;</span><br><span class="line">              if (seg.count != 0)</span><br><span class="line">                  return false;</span><br><span class="line">              sum += seg.modCount;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//再次检查</span><br><span class="line">      if (sum != 0L) &#123; // recheck unless no modifications</span><br><span class="line">          for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">              Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">              if (seg != null) &#123;</span><br><span class="line">                  if (seg.count != 0)</span><br><span class="line">                      return false;</span><br><span class="line">                  sum -= seg.modCount;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (sum != 0L)</span><br><span class="line">              return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ConcurrentHashMap 引入分段锁的概念提高了并发量，每当线程要修改哈希表时并不是锁住整个表，而是去操作某一个 segment 片段，只对 segment 做同步，通过细化锁的粒度提高了效率，相对与 HashTable 对整个哈希表做同步处理更实用与多线程环境</p><p>segments 数组的大小仅在上述初始化创建代码中确定，一旦 map 创建成功后分段个数不会改变，每次扩容也只针对某个分段内的桶进行扩容。</p><p>[参考链接]<a href="https://www.cnblogs.com/rain4j/p/10972090.html" target="_blank" rel="noopener">https://www.cnblogs.com/rain4j/p/10972090.html</a></p><p>“$VIM/vimrc”<br>     user vimrc file: “$HOME/.vimrc”<br> 2nd user vimrc file: “<del>/.vim/vimrc”<br>      user exrc file: “$HOME/.exrc”<br>  system gvimrc file: “$VIM/gvimrc”<br>    user gvimrc file: “$HOME/.gvimrc”<br>2nd user gvimrc file: “</del>/.vim/gvimrc”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;  ConcurrentHashMap 相当于多线程版本的 HashMap, 不会有线程安全问题，在多线程环境下使用 HashMap 可能产生死循环等问题，在这篇博客里做了很好的解释: 老生常谈，HashMap 的死循环 , 我们知道除了 HashMap，还有线程安全的 HashTable,HashTable 的实现原理与 HashMap 一致，只是 HashTable 所有的方法都使用了 synchronized 来修饰确保线程安全性，这在多线程竞争激烈的环境下效率是很低的；ConcurrentHashMap 通过锁分段，把整个哈希表 ConcurrentHashMap 分成了多个片段（segment），来确保线程安全。下面是 JDK 对 ConcurrentHashMap 的介绍：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大意是 ConcurrentHashMap 支持并发的读写，支持 HashTable 的所有方法，实现并发读写不会锁定整个 ConcurrentHashMap。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="多线程安全、Java集合、并发容器" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81Java%E9%9B%86%E5%90%88%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="http://yoursite.com/2020/07/16/jdk%E6%BA%90%E7%A0%81%E5%8C%85/"/>
    <id>http://yoursite.com/2020/07/16/jdk源码包/</id>
    <published>2020-07-16T11:57:10.000Z</published>
    <updated>2020-07-17T01:42:22.411Z</updated>
    
    <content type="html"><![CDATA[<h5 id="需要阅读的源码包"><a href="#需要阅读的源码包" class="headerlink" title="需要阅读的源码包"></a>需要阅读的源码包</h5><ul><li>1、java.lang<br>这里面其实就是Java的基本语法，比如各种基本包装类型（Integer、Long、Double等）、基本类（Object，Class，Enum，Exception，Thread）等等…</li><li>2、java.lang.annotation<br>包含Java注解基本元素相关的源码</li><li>3、java.lang.reflect<br>包含Java反射基本元素相关的代码</li><li>4、java.util<br>这里面放的都是Java的基本工具，最典型和常用的就是各种容器和集合（List、Map、Set）</li><li>5、java.util.concurrent<br>大名鼎鼎的JUC包，里面包含了Java并发和多线程编程相关的代码</li><li>6、java.util.function +java.util.stream<br>包含Java函数式编程的常见接口和代码</li><li>7、java.io<br>包含Java传统I/O相关的源码，主要是面向字节和流的I/O</li><li>8、java.nio<br>包含Java非阻塞I/O相关的源码，主要是面向缓冲、通道以及选择器的I/O</li><li>9、java.time<br>包含Java新日期和期间相关的代码，最典型的当属LocalDateTime、DateTimeFormatter等</li><li>10、java.math<br>主要包含一些高精度运算的支持数据类</li><li>11、java.math<br>主要包含一些高精度运算的支持数据类</li><li>12、java.net<br>主要包含Java网络通信（典型的如：Socket通信）相关的源代码。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;需要阅读的源码包&quot;&gt;&lt;a href=&quot;#需要阅读的源码包&quot; class=&quot;headerlink&quot; title=&quot;需要阅读的源码包&quot;&gt;&lt;/a&gt;需要阅读的源码包&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、java.lang&lt;br&gt;这里面其实就是Java的基本语法，比如各种基本包装
      
    
    </summary>
    
    
      <category term="jdk源码" scheme="http://yoursite.com/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别</title>
    <link href="http://yoursite.com/2020/07/13/jdk1.7%E5%92%8C1.8%E4%B8%ADConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/13/jdk1.7和1.8中ConcurrentHashMap和HashMap的一些区别/</id>
    <published>2020-07-13T11:57:10.000Z</published>
    <updated>2020-07-15T02:55:50.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-在-JDK8-与-JDK7-中的区别"><a href="#HashMap-在-JDK8-与-JDK7-中的区别" class="headerlink" title="HashMap 在 JDK8 与 JDK7 中的区别"></a>HashMap 在 JDK8 与 JDK7 中的区别</h3><ul><li>插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。</li><li>JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）</li><li>扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。</li><li>JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移</li></ul><a id="more"></a><h3 id="ConcurrentHashMap-在-JDK7-与-JDK8-中的区别"><a href="#ConcurrentHashMap-在-JDK7-与-JDK8-中的区别" class="headerlink" title="ConcurrentHashMap 在 JDK7 与 JDK8 中的区别"></a>ConcurrentHashMap 在 JDK7 与 JDK8 中的区别</h3><ul><li><p>ConcurrentHashMap 在 jdk8 中初始化采用了延迟初始化策略，他会在第一次执行 put 的时候初始化 table。</p></li><li><p>JDK7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK8 采用 CAS (读)+Synchronized (写) 保证线程安全。</p></li><li><p>锁的粒度：原来是对需要进行数据操作的 Segment 加锁，JDK8 调整为对每个数组元素加锁（Node）。</p></li><li><p>链表转化为红黑树：定位结点的 hash 算法简化会带来弊端，Hash 冲突加剧，因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。</p></li><li><p>查询时间复杂度：从原来的遍历链表 O (n)，变成遍历红黑树 O (logN)。</p></li><li><p>JDK8 推荐使用 mappingCount 方法而不是 size 方法获取当前 map 表的大小，因为这个方法的返回值是 long 类型，size 方法是返回值类型是 int</p></li></ul><h3 id="ConcurrentHashMap-与-HashMap-相比，有以下不同点"><a href="#ConcurrentHashMap-与-HashMap-相比，有以下不同点" class="headerlink" title="ConcurrentHashMap 与 HashMap 相比，有以下不同点"></a>ConcurrentHashMap 与 HashMap 相比，有以下不同点</h3><ul><li>ConcurrentHashMap 线程安全，而 HashMap 非线程安全;</li><li>HashMap 允许 Key 和 Value 为 null，而 ConcurrentHashMap 不允许;</li><li>HashMap 迭代器是强一致性，ConcurrentHashMap 迭代器是弱一致性，HashMap 不允许通过 Iterator 遍历的同时通过 HashMap 修改，而 ConcurrentHashMap 允许该行为，并且该更新对后续的遍历可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-在-JDK8-与-JDK7-中的区别&quot;&gt;&lt;a href=&quot;#HashMap-在-JDK8-与-JDK7-中的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap 在 JDK8 与 JDK7 中的区别&quot;&gt;&lt;/a&gt;HashMap 在 JDK8 与 JDK7 中的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;插入数据时，hash 冲突，jdk7 总是把数据插入到链表的头部，jdk8 要先判断 node 是红黑树，还是链表，如果是链表，长度超过 8 也要转换成红黑树，链表的话，插入到链表尾部，如果是 remove 数据，红黑树长度小于 6 也会转换成链表。&lt;/li&gt;
&lt;li&gt;JDK7 中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致 CPU 飙升），JDK8 中链表使用的尾插法（JDK8 中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）&lt;/li&gt;
&lt;li&gt;扩容 resize 时，jdk7 的扩容，按旧链表正序遍历，在新链表的头部依次插入，在多线程的情况下，有一定概率会出现链表环，出现死锁。jdk8 扩容，按旧链表正序遍历，在新链表尾部依次插入，不会出现 jdk7 中的链表环，但在多线程的情况下有一定概率出现脏数据，数据丢失问题。&lt;/li&gt;
&lt;li&gt;JDK7 和 JDK8 扩容过程中转移元素的逻辑不一样，JDK7 是每次转移一个元素，JDK8 是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hashmap扩容浅谈</title>
    <link href="http://yoursite.com/2020/07/12/hashmap%E6%89%A9%E5%AE%B9%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2020/07/12/hashmap扩容浅谈/</id>
    <published>2020-07-12T11:57:10.000Z</published>
    <updated>2020-07-13T09:57:16.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-7-中Hashmap扩容机制"><a href="#Java-7-中Hashmap扩容机制" class="headerlink" title="Java 7 中Hashmap扩容机制"></a>Java 7 中Hashmap扩容机制</h3><h5 id="一、什么时候扩容："><a href="#一、什么时候扩容：" class="headerlink" title="一、什么时候扩容："></a>一、什么时候扩容：</h5><p>扩容必须满足两个条件：<br>1、 存放新值的时候当前已有元素的个数必须大于等于阈值<br>2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）</p><a id="more"></a><h5 id="二、下面我们看源码，如下："><a href="#二、下面我们看源码，如下：" class="headerlink" title="二、下面我们看源码，如下："></a>二、下面我们看源码，如下：</h5><p>首先是put()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　　　//判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span><br><span class="line">　　　　if (table == EMPTY_TABLE) &#123;</span><br><span class="line">　　　　　　inflateTable(threshold);//如果为空，则初始化</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　//判断key是否为空</span><br><span class="line">　　　　if (key == null)</span><br><span class="line">　　　　　　return putForNullKey(value);//hashmap允许key为空</span><br><span class="line">　　　　</span><br><span class="line">　　　　//计算当前key的哈希值　　　　</span><br><span class="line">　　　　int hash = hash(key);</span><br><span class="line">　　　　//通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span><br><span class="line">　　　　int i = indexFor(hash, table.length);</span><br><span class="line">　　　　for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">　　　　　　Object k;</span><br><span class="line">　　　　　　//如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span><br><span class="line">　　　　　　if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">　　　　　　　　V oldValue = e.value;</span><br><span class="line">　　　　　　　　e.value = value;</span><br><span class="line">　　　　　　　　e.recordAccess(this);</span><br><span class="line">　　　　　　　　return oldValue;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　modCount++;</span><br><span class="line">　　　　//存放值的具体方法</span><br><span class="line">　　　　addEntry(hash, key, value, i);</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在put()方法中有调用addEntry()方法，这个方法里面是具体的存值，在存值之前还要判断是否需要扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">　　　　//1、判断当前个数是否大于等于阈值</span><br><span class="line">　　　　//2、当前存放是否发生哈希碰撞</span><br><span class="line">　　　　//如果上面两个条件否发生，那么就扩容</span><br><span class="line">　　　　if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">　　　　　　//扩容，并且把原来数组中的元素重新放到新数组中</span><br><span class="line">　　　　　　resize(2 * table.length);</span><br><span class="line">　　　　　　hash = (null != key) ? hash(key) : 0;</span><br><span class="line">　　　　　　bucketIndex = indexFor(hash, table.length);</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　createEntry(hash, key, value, bucketIndex);</span><br><span class="line">　　&#125;</span><br><span class="line">```　　</span><br><span class="line"></span><br><span class="line">如果需要扩容，调用扩容的方法resize()</span><br></pre></td></tr></table></figure><p>void resize(int newCapacity) {<br>　　　　Entry[] oldTable = table;<br>　　　　int oldCapacity = oldTable.length;<br>　　　　//判断是否有超出扩容的最大值，如果达到最大值则不进行扩容操作<br>　　　　if (oldCapacity == MAXIMUM_CAPACITY) {<br>　　　　　　threshold = Integer.MAX_VALUE;<br>　　　　　　return;<br>　　　　}</p><p>　　　　Entry[] newTable = new Entry[newCapacity];<br>　　　　// transfer()方法把原数组中的值放到新数组中<br>　　　　transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>　　　　//设置hashmap扩容后为新的数组引用<br>　　　　table = newTable;<br>　　　　//设置hashmap扩容新的阈值<br>　　　　threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer()在实际扩容时候把原来数组中的元素放入新的数组中</span><br></pre></td></tr></table></figure><p>void transfer(Entry[] newTable, boolean rehash) {<br>　　　　int newCapacity = newTable.length;<br>　　　　for (Entry&lt;K,V&gt; e : table) {<br>　　　　　　while(null != e) {<br>　　　　　　　　Entry&lt;K,V&gt; next = e.next;<br>　　　　　　　　if (rehash) {<br>　　　　　　　　　　e.hash = null == e.key ? 0 : hash(e.key);<br>　　　　　　　　}<br>　　　　　　　　//通过key值的hash值和新数组的大小算出在当前数组中的存放位置<br>　　　　　　　　int i = indexFor(e.hash, newCapacity);<br>　　　　　　　　e.next = newTable[i];<br>　　　　　　　　newTable[i] = e;<br>　　　　　　　　e = next;<br>　　　　　　}<br>　　　　}<br>　　}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 三、总结：</span><br><span class="line"></span><br><span class="line">Hashmap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</span><br><span class="line">因为上面这两个条件，所以存在下面这些情况</span><br><span class="line">&gt;&gt; 就是hashmap在存值的时候（默认大小为16，负载因子0.75，阈值12），可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。</span><br><span class="line"></span><br><span class="line">&gt;&gt; 当然也有可能存储更多值（超多16个值，最多可以存26个值）都还没有扩容。原理：前11个值全部hash碰撞，存到数组的同一个位置（虽然hash冲突，但是这时元素个数小于阈值12，并没有同时满足扩容的两个条件。所以不会扩容），后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，也没有同时满足扩容的两个条件，所以叶不会扩容），前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java 8 中Hashmap扩容机制</span><br><span class="line"></span><br><span class="line">##### 一、Java8的扩容机制：</span><br><span class="line">Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：当前存放新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">&gt;&gt;（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,&quot;zhangsan&quot;），而map里面原有数据&lt;&quot;name&quot;,&quot;lisi&quot;&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</span><br><span class="line"></span><br><span class="line">&gt;&gt;（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</span><br><span class="line">##### 二、背景知识：</span><br><span class="line"></span><br><span class="line">　　Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key/value值，还存了后一个Entry对的地址。</span><br><span class="line"></span><br><span class="line">　　Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但是数组的对象以前是Entry对，现在换成了Node对象（可以理解是Entry对，结构一样，存储时也会存key/value键值对、后一个Node的地址），以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树。</span><br><span class="line"></span><br><span class="line">##### 三、源码：</span><br><span class="line"></span><br><span class="line">　　在jdk7中，当new Hashmap()的时候会对对象进行初始化，而jdk8中new Hashmap()并没有对对象进行初始化，而是在put()方法中通过判断对象是否为空，如果为空通过调用resize()来初始化对象。</span><br></pre></td></tr></table></figure><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><p>复制代码<br>    /**<br>     * Implements Map.put and related methods<br>     *<br>     * @param hash key值计算传来的下标<br>     * @param key<br>     * @param value<br>     * @param onlyIfAbsent true只是在值为空的时候存储数据，false都存储数据<br>     * @param evict<br>     * @return 返回被覆盖的值，如果没有覆盖则返回null<br>     */<br>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        // 申明entry数组对象tab[]:当前Entry[]对象<br>        Node&lt;K,V&gt;[] tab;<br>        // 申明entry对象p:这里表示存放的单个节点<br>        Node&lt;K,V&gt; p;<br>        // n:为当前Entry对象长度<br>　　　　 // i:为当前存放对象节点的位置下标<br>        int n, i;</p><pre><code>    /**     * 流程判断     * 1、如果当前Node数组(tab)为空，则直接创建(通过resize()创建)，并将当前创建后的长度设置给n     * 2、如果要存放对象所在位置的Node节点为空，则直接将对象存放位置创建新Node，并将值直接存入     * 3、存放的Node数组不为空，且存放的下标节点Node不为空（该Node节点为链表的首节点）     *   1）比较链表的首节点存放的对象和当前存放对象是否为同一个对象，如果是则直接覆盖并将原来的值返回     *   2）如果不是分两种情况     *      （1）存储处节点为红黑树node结构，调用方法putTreeVal()直接将数据插入     *      （2）不是红黑树，则表示为链表，则进行遍历     *          A.如果存入的链表下一个位置为空，则先将值直接存入，存入后检查当前存入位置是否已经大于链表的第8个位置     *              a.如果大于,调用treeifyBin方法判断是扩容 还是 需要将该链表转红黑树（大于8且总数据量大于64则转红黑色，否则对数组进行扩容）     *              b.当前存入位置链表长度没有大于8，则存入成功，终端循环操作。     *          B.如果存入链表的下一个位置有值，且该值和存入对象“一样”，则直接覆盖，并将原来的值返回     *          上面AB两种情况执行完成后，判断返回的原对象是否为空，如果不为空，则将原对象的原始value返回     * 上面123三种情况下，如果没有覆盖原值，则表示新增存入数据，存储数据完成后，size+1,然后判断当前数据量是否大于阈值，     * 如果大于阈值，则进行扩容。     */    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            // 按照红黑树直接将数据存入            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);//该方法判断是扩容还是需要将该链表转红黑树                    break;                }                if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 如果不是替换数据存入，而是新增位置存入后，则将map的size进行加1，然后判断容量是否超过阈值，超过则扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treeifyBin()方法判断是扩容还是将当前链表转红黑树</span><br></pre></td></tr></table></figure><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * 从指定hash位置处的链表nodes头部开始，全部替换成红黑树结构。 * 除非整个数组对象（Map集合）数据量很小（小于64），该情况下则通过resize()对这个Map进行扩容，而代替将链表转红黑树的操作。 */final void treeifyBin(HashMap.Node&lt;K,V&gt;[] tab, int hash) {    int n, index; HashMap.Node&lt;K,V&gt; e;    // 如果Map为空或者当前存入数据n（可以理解为map的size()）的数量小于64便进行扩容    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    // 如果size()大于64则将正在存入的该值所在链表转化成红黑树    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        HashMap.TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            HashMap.TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><p>```</p><h5 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h5><p>1）Java 8 在新增数据存入成功后进行扩容<br>2）扩容会发生在两种情况下（满足任意一种条件即发生扩容）：<br>   a 当前存入数据大于阈值即发生扩容<br>   b 存入数据到某一条链表上，此时数据大于8，且总数量小于64即发生扩容<br>3）此外需要注意一点java7是在存入数据前进行判断是否扩容，而java8是在存入数据库在进行扩容的判断。</p><p>ConcurrentHashMap知识参考：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html" target="_blank" rel="noopener">https://www.cnblogs.com/zerotomax/p/8687425.html</a></p><p>Java8 HashMap扩容可参考：<a href="https://blog.csdn.net/goosson/article/details/81029729" target="_blank" rel="noopener">https://blog.csdn.net/goosson/article/details/81029729</a> （注：该文章中关于Java8 底层数据结构描述不准确，只有当数据量大于64才会有红黑树+链表）</p><p>这里补充一下jdk8关于红黑树和链表的知识：</p><p>　　第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;=7,从0开始，及第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p><p>[参考链接]<a href="https://www.cnblogs.com/yanzige/p/8392142.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanzige/p/8392142.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-7-中Hashmap扩容机制&quot;&gt;&lt;a href=&quot;#Java-7-中Hashmap扩容机制&quot; class=&quot;headerlink&quot; title=&quot;Java 7 中Hashmap扩容机制&quot;&gt;&lt;/a&gt;Java 7 中Hashmap扩容机制&lt;/h3&gt;&lt;h5 id=&quot;一、什么时候扩容：&quot;&gt;&lt;a href=&quot;#一、什么时候扩容：&quot; class=&quot;headerlink&quot; title=&quot;一、什么时候扩容：&quot;&gt;&lt;/a&gt;一、什么时候扩容：&lt;/h5&gt;&lt;p&gt;扩容必须满足两个条件：&lt;br&gt;1、 存放新值的时候当前已有元素的个数必须大于等于阈值&lt;br&gt;2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、容器" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hashmap中hash方法的一些看法</title>
    <link href="http://yoursite.com/2020/07/11/hashmap%E4%B8%ADhash%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/11/hashmap中hash方法的一些看法/</id>
    <published>2020-07-11T11:57:10.000Z</published>
    <updated>2020-07-13T03:48:19.968Z</updated>
    
    <content type="html"><![CDATA[<p>hashcode一般用 int 来表示，32 位。<br>下面两个 hashcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">只有第 32 位（从右到左）不一样;</span><br></pre></td></tr></table></figure><p>在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.</p><a id="more"></a><p>大家又知道，hashcode 对 8 取模，效果等同于 hashcode &amp; (8 - 1)。</p><p>那么，前面的 A 和 （8 - 1）相与的结果如何呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0111 1111 1111 1111 1111 1111 1111 1111  ------A</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">结果为 7，也就是，会放进 array [7]。</span><br></pre></td></tr></table></figure><p>大家再看 B 的计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111  ------B</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 8 -1</span><br><span class="line">相与</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0111  ------ 7</span><br><span class="line">虽然 B 的第 32 位为 1,前面的高位，全是 0。</span><br></pre></td></tr></table></figure><p>所以，问题明白了吗，我们计算出来的 hashcode，低位相同，高位不同；但是，因为和我们进行与计算的队友太过垃圾，导致我们出现了 hash 冲突。</p><h5 id="怎么来解决这个问题呢？"><a href="#怎么来解决这个问题呢？" class="headerlink" title="怎么来解决这个问题呢？"></a>怎么来解决这个问题呢？</h5><p>我们能不能把高位也参与计算呢？自然，是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hashmap 中如何优化</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">```   </span><br><span class="line">这里，其实分了 3 个步骤：</span><br><span class="line"></span><br><span class="line">&gt;&gt; 计算 hashcode，作为操作数 1</span><br><span class="line"></span><br><span class="line">&gt;&gt; h = key.hashCode()</span><br><span class="line">&gt;&gt; 将第一步的 hashcode，右移 16 位，作为操作数 2</span><br><span class="line"></span><br><span class="line">&gt;&gt; h &gt;&gt;&gt; 16</span><br><span class="line">&gt;&gt; 操作数 1 和 操作数 2 进行异或操作，得到最终的 hashcode</span><br><span class="line"></span><br><span class="line">还是拿前面的来算，</span><br></pre></td></tr></table></figure><p>0111 1111 1111 1111 1111 1111 1111 1111  ——A<br>0000 0000 0000 0000 0111 1111 1111 1111   —– A &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>这里算出来的结果是 2147450880，再去对 7 进行与运算：</p><p>0111 1111 1111 1111 1000 0000 0000 0000    — 2147450880<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 8 -1<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  —— 0<br>这里的 A，算出来，依然在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再拿 B 来算一下：</span><br></pre></td></tr></table></figure><p>1111 1111 1111 1111 1111 1111 1111 1111  —— B<br>0000 0000 0000 0000 1111 1111 1111 1111   —– B &gt;&gt;&gt; 16<br>异或（相同则为0，否则为1）<br>1111 1111 1111 1111 0000 0000 0000 0000    — -65536<br>0000 0000 0000 0000 0000 0000 0000 0111  —— 7<br>与运算<br>0000 0000 0000 0000 0000 0000 0000 0000  ——- 0<br>最终算出来为 0，所以，应该放在 array [0]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里两个虽然算出来都是array[0](只是凑巧)</span><br><span class="line"></span><br><span class="line">下边提供下源代码：</span><br></pre></td></tr></table></figure><p>public class BinaryTest {<br>    public static void main(String[] args) {<br>        int a = 0b00001111111111111111111111111011;<br>        int b = 0b10001101111111111111110111111011;</p><pre><code>    int i = tabAt(32, a);    System.out.println(&quot;index for a:&quot; + i);    i = tabAt(32, b);    System.out.println(&quot;index for b:&quot; + i);}static final int tabAt(int  arraySize, int hash) {    int h = hash;    int finalHashCode = h ^ (h &gt;&gt;&gt; 16);    int i = finalHashCode &amp; (arraySize - 1);    return i;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虽然说，我测试了几个数字，还是有些冲突，但是，你把高 16 位弄进来参与计算，总比你不弄进来计算要好吧。</span><br><span class="line"></span><br><span class="line">大家也可以看看 hashmap 中，hash 方法的注释：</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Computes key.hashCode() and spreads (XORs) higher bits of hash</li><li>to lower.  Because the table uses power-of-two masking, sets of</li><li>hashes that vary only in bits above the current mask will</li><li>always collide. (Among known examples are sets of Float keys</li><li>holding consecutive whole numbers in small tables.)  So we</li><li>apply a transform that spreads the impact of higher bits</li><li>downward. There is a tradeoff between speed, utility, and</li><li>quality of bit-spreading. Because many common sets of hashes</li><li>are already reasonably distributed (so don’t benefit from</li><li>spreading), and because we use trees to handle large sets of</li><li>collisions in bins, we just XOR some shifted bits in the</li><li>cheapest possible way to reduce systematic lossage, as well as</li><li>to incorporate impact of the highest bits that would otherwise</li><li>never be used in index calculations because of table bounds.</li><li>/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">里面提到了 2 点：</span><br></pre></td></tr></table></figure></li></ul><p>So we apply a transform that spreads the impact of higher bits downward.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，我们进行了一个转换，把高位的作用利用起来。</span><br></pre></td></tr></table></figure><p>we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as<br>to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们仅仅异或了从高位移动下来的二进制位，用最经济的方式，削减系统性能损失，同样，因为数组大小的限制，导致高位在索引计算中一直用不到，我们通过这种转换将其利用起来。</span><br><span class="line"></span><br><span class="line">#### ConcurrentHashMap 如何优化</span><br><span class="line">在 concurrentHashMap 中，其主要是：</span><br></pre></td></tr></table></figure><p>final V putVal(K key, V value, boolean onlyIfAbsent) {<br>    if (key == null || value == null) throw new NullPointerException();<br>    int hash = spread(key.hashCode());</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里主要是使用 spread 方法来计算 hash 值：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家如果要仔细观察每一步的二进制，可以使用下面的 demo：</span><br></pre></td></tr></table></figure><p>static final int spread(int h) {<br>    // 1<br>    String s = Integer.toBinaryString(h);<br>    System.out.println(“h:” + s);</p><pre><code>// 2String lower16Bits = Integer.toBinaryString(h &gt;&gt;&gt; 16);System.out.println(&quot;lower16Bits:&quot; + lower16Bits);// 3int temp = h ^ (h &gt;&gt;&gt; 16);System.out.println(&quot;h ^ (h &gt;&gt;&gt; 16):&quot; + Integer.toBinaryString(temp));// 4int result = (temp) &amp; HASH_BITS;System.out.println(&quot;final:&quot; + Integer.toBinaryString(result));return result;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里和 HashMap 相比，多了点东西，也就是多出来了：</span><br></pre></td></tr></table></figure><p>&amp; HASH_BITS;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 (h ^ (h &gt;&gt;&gt; 16)) 计算出来的 hashcode，可能是负数。这里，和 HASH_BITS 进行了相与：</span><br></pre></td></tr></table></figure><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash<br>1111 1111 1111 1111 1111 1111 1111 1111   假设计算出来的hashcode为负数，因为第32位为1<br>0111 1111 1111 1111 1111 1111 1111 1111       0x7fffffff<br>    进行相与<br>0111 …………………………….    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​这里，第 32 位，因为 0x7fffffff 的第 32 位，总为 0，所以相与后的结果，第 32 位也总为 0 ，所以，这样的话，hashcode 就总是正数了，不会是负数。</span><br><span class="line"></span><br><span class="line">***concurrentHashMap 中，node 的 hashcode，为啥不能是负数***</span><br><span class="line">当 hashcode 为正数时，表示该哈希桶为正常的链表结构。</span><br><span class="line">当 hashcode 为负数时，有几种情况：</span><br><span class="line"></span><br><span class="line">***ForwardingNode***</span><br><span class="line">此时，其 hash 值为：</span><br></pre></td></tr></table></figure><p>static final int MOVED     = -1; // hash for forwarding nodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当节点为 ForwardingNode 类型时（表示哈希表在扩容进行中，该哈希桶已经被迁移到了新的临时 hash 表，此时，要 get 的话，需要去临时 hash 表查找；要 put 的话，是不行的，会帮助扩容）</span><br><span class="line"></span><br><span class="line">***TreeBin***</span><br></pre></td></tr></table></figure><p>static final int TREEBIN   = -2; // hash for roots of trees</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示，该哈希桶，已经转了红黑树。</span><br><span class="line"></span><br><span class="line">***扩容时的位运算***</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Returns the stamp bits for resizing a table of size n.</li><li>Must be negative when shifted left by RESIZE_STAMP_SHIFT.</li><li>/<br>static final int resizeStamp(int n) {<br>   return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这里，假设，n 为 4，即，hashmap 中数组容量为 4.</span><br><span class="line"></span><br><span class="line">+ 下面这句，求 4 的二进制表示中，前面有多少个 0.</span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(n)</span><br><span class="line"></span><br><span class="line">表示为 32 位后，如下</span><br><span class="line"></span><br><span class="line">0000 0000 0000 0000, 0000 0000 0000 0100</span><br><span class="line"></span><br><span class="line">所以，前面有 29 个 0，即，这里的结果为 29.</span><br><span class="line"></span><br><span class="line">+ (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)</span><br><span class="line"></span><br><span class="line">这一句呢，其中 RESIZE_STAMP_BITS 是个常量，为 16. 相当于，把 1 向左移动 15 位。</span><br><span class="line"></span><br><span class="line">二进制为：</span><br></pre></td></tr></table></figure></li></ul><p>1000 0000 0000 0000   – 1 &lt;&lt; 15</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 0000 0000 0001 1101   – 29<br>0000 0000 0000 0000 1000 0000 0000 0000   – 1 &lt;&lt; 15<br>进行或运算<br>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以，最终结果是，</span><br><span class="line">![](hashmap中hash方法的一些看法/aaa.png)</span><br><span class="line"></span><br><span class="line">这个数，换算为 10 进制，为 32972，是个正数。</span><br><span class="line">这个数，有啥用呢？</span><br><span class="line">在 addCount 函数中，当整个哈希表的键值对数量，超过 sizeCtl 时（一般为 0.75 * 数组长度），就会触发扩容。</span><br></pre></td></tr></table></figure><p>java.util.concurrent.ConcurrentHashMap#addCount</p><p>int sc =  sizeCtl;<br>boolean bSumExteedSizeControl = newBaseCount &gt;= (long) sc;<br>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1 处，如果扩容条件满足</span><br><span class="line"></span><br><span class="line">+ 2 处，如果 sc 小于 0，这个 sc 是啥，就是前面说的 sizeCtl，此时应该是等于：0.75 * 数组长度，不可能为负数</span><br><span class="line"></span><br><span class="line">+ 3 处，将 sc（此时为正数），cas 修改为：</span><br></pre></td></tr></table></figure><p>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个数有点意思了，rs 就是前面我们的 resizeStamp 得到的结果。</span><br><span class="line"></span><br><span class="line">按照前面的 demo，我们拿到的结果为：</span><br></pre></td></tr></table></figure><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为</span><br></pre></td></tr></table></figure><p>private static int RESIZE_STAMP_BITS = 16;<br>private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;<br>所以，RESIZE_STAMP_SHIFT 为 16.</p><p>0000 0000 0000 0000 1000 0000 0001 1101   –  相当于把29的第一位，变成了1，其他都没变。<br>1000 0000 0001 1101 0000 0000 0000 0000 —   左移16位，即   rs &lt;&lt; RESIZE_STAMP_SHIFT<br>1000 0000 0001 1101 0000 0000 0000 0010    – (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)<br>最终，这个数，第一位是 1，说明了，这个数，肯定是负数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大家如果看过其他人写的资料，也就知道，当 sizeCtl 为负数时，表示正在扩容。</span><br><span class="line"></span><br><span class="line">所以，这里</span><br></pre></td></tr></table></figure><p>if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这句话就是，如果当前线程成功地，利用 cas，将 sizeCtl 从正数，变成负数，就可以进行扩容。</span><br><span class="line"></span><br><span class="line">扩容时，其他线程怎么执行</span><br></pre></td></tr></table></figure><p>// 1<br>if (bContinue) {<br>    int rs = resizeStamp(n);<br>    // 2<br>    if (sc &lt; 0) {<br>        // 2.1<br>        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>            transferIndex &lt;= 0)<br>            break;<br>        // 2.2<br>        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>            transfer(tab, nt);<br>    }<br>    // 3<br>    else if (U.compareAndSwapInt(this, SIZECTL, sc,<br>                                   (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))<br>        transfer(tab, null);<br>    newBaseCount = sumCount();<br>} else {<br>    break;<br>}</p><pre><code>此时，因为上面的线程触发了扩容，sc 已经变成了负数了，此时，新的线程进来，会判断 2 处。2 处是满足的，会进入 2.1 处判断，这里的部分条件看不懂，大概是：扩容已经结束，就不再执行，直接 break否则，进入 2.2 处，辅助扩容，同时，把 sc 变成 sc + 1，增加扩容线程数。[参考链接]http://iambigboss.top/post/73353_1_1.html</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashcode一般用 int 来表示，32 位。&lt;br&gt;下面两个 hashcode:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0111 1111 1111 1111 1111 1111 1111 1111  ------A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1111  ------B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;只有第 32 位（从右到左）不一样;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 hashmap 中，由数组 + 链表 + 红黑树组成，其中，数组乃重中之重，假设数组长度为 2 的 n 次方，（hashmap 的数组，强制要求长度为 2 的 n 次方），这里假设为 8.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合、Java基础" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E3%80%81Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
